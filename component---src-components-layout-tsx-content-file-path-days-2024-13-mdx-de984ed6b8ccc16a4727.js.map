{"version":3,"file":"component---src-components-layout-tsx-content-file-path-days-2024-13-mdx-de984ed6b8ccc16a4727.js","mappings":"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","sources":["webpack://joel-allan-nz.github.io/./days/2024/13.mdx","webpack://joel-allan-nz.github.io/./src/components/Layout.tsx"],"sourcesContent":["/*@jsxRuntime classic @jsx React.createElement @jsxFrag React.Fragment*/\nimport {useMDXComponents as _provideComponents} from \"@mdx-js/react\";\nimport React from \"react\";\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    p: \"p\",\n    em: \"em\",\n    pre: \"pre\",\n    code: \"code\"\n  }, _provideComponents(), props.components), {CodeBox} = _components;\n  if (!CodeBox) _missingMdxReference(\"CodeBox\", true);\n  return React.createElement(React.Fragment, null, React.createElement(_components.h2, null, \"Part One\"), \"\\n\", React.createElement(_components.p, null, \"Quick and dirty! The plan is simply to use cross multiplication to look for the intersections between the lines represented by the lines B and Prize, then see if there's an intercept for A and (Prize total - B)\"), \"\\n\", React.createElement(\"br\"), \"\\n\", React.createElement(_components.p, null, \"There is an edgecase this solution doesn't cover - the possibility of lines A + B\\nbeing \", React.createElement(_components.em, null, \"the same line\"), \" as prize. In that case you'd want need to optimize with B vs\\n3A, and minimizing the cost of presses required. That shouldn't be terribly difficult\\nto implement, but I'm betting Topaz has carefully curated the inputs such that it\\ndoesn't come up.\"), \"\\n\", React.createElement(CodeBox, {\n    boxname: \"one\",\n    names: \"typescript|C#\"\n  }, React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-js\"\n  }, \"export function partOne(input: string[]): number | string {\\n  var regions = parse(input)\\n  return regions\\n    .values()\\n    .reduce(\\n      (total, current) =>\\n        total +\\n        current.length * current.reduce((t, c) => t + 4 - c.Edges.length, 0),\\n      0\\n    )\\n}\\n\\ninterface Node {\\n  X: number\\n  Y: number\\n  C: string\\n  Region: number\\n  Edges: Node[]\\n}\\n\\nfunction parse(input: string[]): Map<number, Node[]> {\\n  const nodes: Node[] = []\\n  let lastRow: Node[] = []\\n  input.forEach((line, y) => {\\n    const currentRow: Node[] = []\\n    line.split('').forEach((c, x) => {\\n      currentRow.push({ X: x, Y: y, C: c, Region: 0, Edges: [] })\\n      nodes.push(currentRow[x])\\n      if (x > 0 && currentRow[x - 1].C == c) {\\n        currentRow[x - 1].Edges.push(currentRow[x])\\n        currentRow[x].Edges.push(currentRow[x - 1])\\n      }\\n      if (y > 0 && lastRow[x].C == c) {\\n        currentRow[x].Edges.push(lastRow[x])\\n        lastRow[x].Edges.push(currentRow[x])\\n      }\\n    })\\n    lastRow = currentRow\\n  })\\n\\n  let region = 1\\n  nodes.forEach((node) => {\\n    if (node.Region == 0) {\\n      node.Region = region\\n      region++\\n      findRegion(node)\\n    }\\n  })\\n  return Map.groupBy(nodes, (node) => node.Region)\\n}\\n\\nfunction findRegion(node: Node) {\\n  node.Edges.forEach((neighbour) => {\\n    if (neighbour.Region == 0) {\\n      neighbour.Region = node.Region\\n      findRegion(neighbour)\\n    }\\n  })\\n}\\n\")), React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-csharp\"\n  }, \"public override object PartOne()\\n{\\n    var regions = Parse();\\n\\n    return regions.Values.Sum(region => region.Count * region.Sum(FindTotalPerimeter()));\\n\\n    static Func<NodeData, int> FindTotalPerimeter() => y => 4 - y.Edges.Count;\\n}\\n\\ninternal class NodeData(int x, int y, char c, int region)\\n{\\n    internal int X = x;\\n    internal int Y = y;\\n    internal char C = c;\\n    internal int Region = region;\\n    internal List<NodeData> Edges = [];\\n}\\n\\nprivate Dictionary<int, List<NodeData>> Parse()\\n{\\n    Dictionary<(int x, int y), NodeData> graph = [];\\n    for (int y = 0; y < Input.Length; y++)\\n    {\\n        for (int x = 0; x < Input.Length; x++)\\n        {\\n            NodeData n = new(x, y, Input[y][x], 0);\\n            if (graph.TryGetValue((x - 1, y), out var left) && left.C == n.C)\\n            {\\n                left.Edges.Add(n);\\n                n.Edges.Add(left);\\n            }\\n            if (graph.TryGetValue((x, y - 1), out var up) && up.C == n.C)\\n            {\\n                up.Edges.Add(n);\\n                n.Edges.Add(up);\\n            }\\n            graph.Add((x, y), n);\\n        }\\n    }\\n\\n    int region = 1;\\n    foreach (var node in graph.Values)\\n    {\\n        if (node.Region == 0)\\n        {\\n            node.Region = region;\\n            region++;\\n            FindRegion(node);\\n        }\\n    }\\n    return graph.Values.GroupBy(x => x.Region).ToDictionary(key => key.Key, value => value.ToList());\\n}\\n\\nprivate static void FindRegion(NodeData node)\\n{\\n    foreach (var neighbour in node.Edges)\\n    {\\n        if (neighbour.Region == 0)\\n        {\\n            neighbour.Region = node.Region;\\n            FindRegion(neighbour);\\n        }\\n    }\\n}\\n\"))), \"\\n\", React.createElement(_components.h2, null, \"Part Two\"), \"\\n\", React.createElement(_components.p, null, \"The exaaaact same, but with much bigger Prize values.\"), \"\\n\", React.createElement(\"br\"), \"\\n\", React.createElement(_components.p, null, \"If not for this much larger prize size you could simply simulate pressing A or B\\nan arbitrary number of times (the puzzle itself suggests part 1 games shouldn't require\\nmore than 100 button presses each). Cross multiplying to find the intercepts is still\\na much more efficient approach!\"), \"\\n\", React.createElement(\"br\"), \"\\n\", React.createElement(CodeBox, {\n    boxname: \"two\",\n    names: \"typescript|C#\"\n  }, React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-js\"\n  }, \"export function partTwo(input: string[]): number | string {\\n  var regions = parse(input)\\n\\n  return regions.values().reduce((total, region) => {\\n    return (\\n      total +\\n      region.reduce((t, node) => t + region.length * countNodeVertices(node), 0)\\n    )\\n  }, 0)\\n}\\n\\nfunction countNodeVertices(node: Node): number {\\n  if (node.Edges.length == 0) return 4\\n  if (node.Edges.length == 1) return 2\\n\\n  const edgeCombinations = node.Edges.slice(0, -1).flatMap((edge, index) => {\\n    return node.Edges.slice(index + 1).map((e) => [edge, e])\\n  })\\n\\n  let outsideCorner = true\\n  const pairSum = edgeCombinations.reduce((total, pair) => {\\n    if (\\n      (pair[0].X == pair[1].X && pair[1].X == node.X) ||\\n      (pair[0].Y == pair[1].Y && pair[1].Y == node.Y)\\n    )\\n      outsideCorner = false\\n    else {\\n      let insideCorner =\\n        pair[0].Edges.filter((e) => pair[1].Edges.includes(e)).length == 1\\n      if (insideCorner) return total + 1\\n    }\\n    return total\\n  }, 0)\\n  return outsideCorner ? pairSum + 1 : pairSum\\n}\\n\")), React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-csharp\"\n  }, \"public override object PartTwo()\\n{\\n    var regions = Parse();\\n\\n    return regions.Values.Sum(region => FindRegionCost(region));\\n\\n    static int FindRegionCost(List<NodeData> region)\\n    {\\n        return region.Sum(node => CountNodeVertices(node)) * region.Count;\\n    }\\n}\\n\\nprivate static int CountNodeVertices(NodeData node)\\n{\\n    if (node.Edges.Count == 0)\\n        return 4;\\n\\n    if (node.Edges.Count == 1)\\n        return 2;\\n\\n    var pairCombinations = node.Edges.UniquePairs();\\n    // if the node is within a straight section of nodes, then it can't be an outside corner.\\n    bool outsideCorner = true;\\n    var pairSum = pairCombinations.Sum(pair =>\\n    {\\n        if (IsStraightLine(node, pair))\\n            outsideCorner = false;\\n        else\\n        {\\n            bool insideCorner = pair[0].Edges.Intersect(pair[1].Edges).Count() == 1;\\n            if (insideCorner)\\n                return 1;\\n        }\\n        return 0;\\n\\n        static bool IsStraightLine(NodeData node, NodeData[] pair)\\n        {\\n            return (pair[0].X == pair[1].X && pair[0].X == node.X) ||\\n            (pair[0].Y == pair[1].Y && pair[0].Y == node.Y);\\n        }\\n    });\\n\\n    return outsideCorner ? pairSum + 1 : pairSum;\\n}\\n\"))));\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? React.createElement(MDXLayout, props, React.createElement(_createMdxContent, props)) : _createMdxContent(props);\n}\nexport default MDXContent;\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","import GATSBY_COMPILED_MDX from \"/home/joel/personal/advent-of-code/joel-allan-nz.github.io/days/2024/13.mdx\";\nimport React from 'react';\nimport {MDXProvider} from '@mdx-js/react';\nimport CodeBox from './CodeBox';\nimport TryYourself from './TryYourself';\nimport AdventSideNav from './AdventSideNav';\nimport Header from './Header';\nimport Footer from './Footer';\nconst shortcodes = {\n  CodeBox\n};\nfunction Layout(_ref) {\n  let {pageContext, children} = _ref;\n  return React.createElement(React.Fragment, null, React.createElement(Header, null), React.createElement(\"div\", {\n    className: \"min-h-screen bg-chicPrimary\"\n  }, React.createElement(AdventSideNav, {\n    props: pageContext.list\n  }), React.createElement(\"div\", {\n    className: \"adventofcode max-w-[60%] ml-[20%]\"\n  }, React.createElement(\"h1\", null, React.createElement(\"a\", {\n    href: \"https://adventofcode.com/\" + pageContext.year + \"/day/\" + pageContext.puzz\n  }, pageContext.year + \" Day \" + pageContext.puzz + \" - \" + pageContext.title)), React.createElement(MDXProvider, {\n    components: shortcodes\n  }, children), pageContext.puzz && pageContext.year ? React.createElement(TryYourself, {\n    year: pageContext.year,\n    puzz: pageContext.puzz\n  }) : React.createElement(React.Fragment, null))), React.createElement(Footer, null));\n}\nexport default function GatsbyMDXWrapper(props) {\n  return React.createElement(Layout, props, React.createElement(GATSBY_COMPILED_MDX, props));\n}\nexport const Head = () => React.createElement(React.Fragment, null, React.createElement(\"title\", null, \"Joel-Allan-NZ - Advent of Code\"), React.createElement(\"html\", {\n  lang: \"en\"\n}), React.createElement(\"link\", {\n  rel: \"preconnect\",\n  href: \"https://fonts.googleapis.com\"\n}), React.createElement(\"link\", {\n  rel: \"preconnect\",\n  href: \"https://fonts.gstatic.com\"\n}), React.createElement(\"link\", {\n  href: \"https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&family=VT323&display=swap\",\n  rel: \"stylesheet\"\n}));\n"],"names":["_createMdxContent","props","_components","Object","assign","h2","p","em","pre","code","_provideComponents","components","CodeBox","id","component","Error","_missingMdxReference","React","boxname","names","className","wrapper","MDXLayout","shortcodes","Layout","_ref","pageContext","children","Header","AdventSideNav","list","href","year","puzz","title","MDXProvider","TryYourself","Footer","GatsbyMDXWrapper","GATSBY_COMPILED_MDX","Head","lang","rel"],"sourceRoot":""}