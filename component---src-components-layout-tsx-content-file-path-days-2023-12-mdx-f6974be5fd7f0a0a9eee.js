"use strict";(self.webpackChunkjoel_allan_nz_github_io=self.webpackChunkjoel_allan_nz_github_io||[]).push([[9760],{1257:function(e,n,t){t.r(n),t.d(n,{Head:function(){return d},default:function(){return h}});var r=t(8453),l=t(6540);function i(e){const n=Object.assign({h2:"h2",p:"p",ul:"ul",li:"li",code:"code",pre:"pre"},(0,r.RP)(),e.components),{CodeBox:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("CodeBox",!0),l.createElement(l.Fragment,null,l.createElement(n.h2,null,"Part One"),"\n",l.createElement(n.p,null,"This one's a bit trickier than the average!"),"\n",l.createElement("br"),"\n",l.createElement(n.p,null,"I opted to approach it as a dynamic programming problem, memoizing the results of\neach problem and subproblem to minimize redundancy."),"\n",l.createElement("br"),"\n",l.createElement(n.p,null,"The actual function isn't complicated, but it is a little intimidating looking. There\nare several base cases:"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"If we've already found the result of an identical problem/sub-problem, then return it."),"\n",l.createElement(n.li,null,"If there are no remaining groups (or lengths) of springs left, then it's either a valid solution (no remaining ",l.createElement(n.code,null,"#"),"), or not."),"\n",l.createElement(n.li,null,"If the lengths of remaining groups/lengths + the required spaces between them are larger than the space remaining, then it's an invalid solution."),"\n",l.createElement(n.li,null,"If the the remaining space is equal to the size of the last spring group, but the space contains a ",l.createElement(n.code,null,"."),", the solution is invalid. If it doesn't contain a ",l.createElement(n.code,null,"."),", then there's exactly one solution for this subproblem."),"\n"),"\n",l.createElement(n.p,null,"With those cases covered, we can take the current space and break it down into subproblems to solve.\nThe first possible sub-problem is the same spring space minus the first character (provided it isn't a ",l.createElement(n.code,null,"#")," and therefore meaningful). The second is to consider the spring space less the length of the first group of broken springs. IE if you have ",l.createElement(n.code,null,"??????")," and ",l.createElement(n.code,null,"3"),", you can consider it to be ",l.createElement(n.code,null,"###???")," and start examing ",l.createElement(n.code,null,"???")," with the next group size."),"\n",l.createElement("br"),"\n",l.createElement(n.p,null,"Once you work your way through that, you have a solution!"),"\n",l.createElement(t,{names:"typescript|C#"},l.createElement(n.pre,null,l.createElement(n.code,{className:"language-js"},"export function partOne(input: string[]): number | string {\n  const cache = new Map<string, number>()\n  let result = input.reduce((total, line) => {\n    var split = line.split(/ /)\n    split[0] = split[0].split(/\\.+/).join('.')\n    return (\n      total +\n      findValidArrangements(\n        cache,\n        split[0],\n        split[1].split(/,/).map((x) => parseInt(x))\n      )\n    )\n  }, 0)\n  return result\n}\n\nfunction findValidArrangements(\n  cache: Map<string, number>,\n  springs: string,\n  lengths: number[]\n): number {\n  const line = springs + ' ' + lengths.join(',')\n\n  let result = cache.get(line)\n  if (result) return result\n\n  if (lengths.length == 0) return springs.includes('#') ? 0 : 1\n  if (springs.length - lengths.reduce((a, b) => a + b) - lengths.length < -1)\n    return 0\n\n  const lengthFits = !springs.slice(0, lengths[0]).includes('.')\n  if (springs.length == lengths[0]) return lengthFits ? 1 : 0\n\n  return (cache[line] ??=\n    (springs[0] != '#'\n      ? findValidArrangements(cache, trimWorking(springs, 1), lengths)\n      : 0) +\n    (lengthFits && springs[lengths[0]] != '#'\n      ? findValidArrangements(\n          cache,\n          trimWorking(springs, lengths[0] + 1),\n          lengths.slice(1)\n        )\n      : 0))\n}\n\nfunction trimWorking(untrimmed: string, start: number) {\n  if (start >= untrimmed.length) return ''\n\n  return untrimmed[start] == '.'\n    ? untrimmed.slice(start + 1)\n}\n")),l.createElement(n.pre,null,l.createElement(n.code,{className:"language-csharp"},"public override object PartOne()\n{\n    Dictionary<string, long> cache = [];\n    return Parse().Sum(line => FindValidArrangements(cache, line.spring.Split('.').Aggregate((x, y) => x + '.' + y), line.lengthString, line.lengths));\n}\n\nprivate IEnumerable<(string spring, string lengthString, int[] lengths)> Parse()\n{\n    foreach (var line in Input)\n    {\n        var split = line.Split(' ');\n        yield return (split[0], split[1], split[1].Split(',').Select(x => int.Parse(x)).ToArray());\n    }\n}\n\nprivate IEnumerable<(string spring, string lengthString, int[] lengths)> ParseUnfolded()\n{\n    foreach (var line in Input)\n    {\n        var split = line.Split(' ');\n        List<string> fiveSplit0 = [split[0], split[0], split[0], split[0], split[0]];\n        split[0] = fiveSplit0.Aggregate((x, y) => x + \"?\" + y);\n        List<string> fiveSplit1 = [split[1], split[1], split[1], split[1], split[1]];\n        split[1] = fiveSplit1.Aggregate((x, y) => x + ',' + y);\n\n        yield return (split[0], split[1], split[1].Split(',').Select(x => int.Parse(x)).ToArray());\n    }\n}\n\nprivate static long FindValidArrangements(Dictionary<string, long> cache, string springs, string lengthString, int[] lengths)\n{\n    if (cache.TryGetValue(springs + lengthString, out var cached))\n        return cached;\n\n    if (lengths.Length == 0)\n        return springs.Contains('#') ? 0 : 1;\n\n    if (springs.Length - lengths.Sum() - lengths.Length < -1)\n        return 0;\n\n    bool lengthFits = !springs[0..lengths[0]].Contains('.');\n\n    if (springs.Length == lengths[0])\n        return lengthFits ? 1 : 0;\n\n    var afterLengthString = lengthString.Length < 3 ? \"\" : lengths[0] < 10 ? lengthString[2..] : lengthString[3..];\n    var result = 0L;\n\n    if (springs[0] != '#')\n        result += FindValidArrangements(cache, TrimWorking(springs, 1), lengthString, lengths);\n\n    if (lengthFits && springs[lengths[0]] != '#')\n        result += FindValidArrangements(cache, TrimWorking(springs, lengths[0] + 1), afterLengthString, lengths[1..]);\n\n    cache[springs + lengthString] = result;\n    return result;\n}\n\nprivate static string TrimWorking(string untrimmed, int start)\n{\n    if (start >= untrimmed.Length)\n        return \"\";\n\n    return untrimmed[start] == '.' ? untrimmed[(start + 1)..] : untrimmed[start..];\n}\n"))),"\n",l.createElement(n.h2,null,"Part Two"),"\n",l.createElement(n.p,null,"The same problem, but on a bigger scale. The repetition of elements makes the memoization even more important, significantly reducing the amount of recursion required."),"\n",l.createElement("br"),"\n",l.createElement(n.p,null,"I typically make sure to use ",l.createElement(n.code,null,"Map<Tkey,TValue>.set()")," for type-safety, but I cheat a little in this typescript solution in order to use a null coalescing assignment ",l.createElement(n.code,null,"??="),". The performance gains in this particular example were staggering (but difficult to explain). There's something tricky going on under the hood with how the assignment is made, but it's a problem for another day."),"\n",l.createElement(t,{names:"typescript|C#"},l.createElement(n.pre,null,l.createElement(n.code,{className:"language-ts"},"export function partTwo(input: string[]): number | string {\n  const cache = new Map<string, number>()\n\n  let result = 0\n  for (const line of input) {\n    const [row, groups] = line\n      .split(' ')\n      .map((x, i) =>\n        i == 1 ? x.split(',').map((y) => parseInt(y)) : x.split(/\\.+/).join('.')\n      )\n    result += findValidArrangements(\n      cache,\n      Array(5).fill(row).join('?'),\n      Array(5).fill(groups).flat()\n    )\n  }\n  return result\n}\n")),l.createElement(n.pre,null,l.createElement(n.code,{className:"language-csharp"},"public override object PartTwo()\n{\n    Dictionary<string, long> cache = [];\n    return ParseUnfolded().Sum(line => FindValidArrangements(cache, line.spring.Split('.').Aggregate((x, y) => x + '.' + y), line.lengthString, line.lengths));\n}\n"))))}var s=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,r.RP)(),e.components);return n?l.createElement(n,e,l.createElement(i,e)):i(e)};var a=t(2779),o=t(7206),c=t(791),g=t(4813),u=t(572);const p={CodeBox:a.A};function m(e){let{pageContext:n,children:t}=e;return l.createElement(l.Fragment,null,l.createElement(g.A,null),l.createElement("div",{className:"min-h-screen bg-chicPrimary"},l.createElement(c.A,{props:n.list}),l.createElement("div",{className:"adventofcode max-w-[60%] ml-[20%]"},l.createElement("h1",null,l.createElement("a",{href:"https://adventofcode.com/"+n.year+"/day/"+n.puzz},n.year+" Day "+n.puzz+" - "+n.title)),l.createElement(r.xA,{components:p},t),n.puzz&&n.year?l.createElement(o.A,{year:n.year,puzz:n.puzz}):l.createElement(l.Fragment,null))),l.createElement(u.A,null))}function h(e){return l.createElement(m,e,l.createElement(s,e))}const d=()=>l.createElement(l.Fragment,null,l.createElement("title",null,"Joel-Allan-NZ - Advent of Code"),l.createElement("html",{lang:"en"}),l.createElement("link",{rel:"preconnect",href:"https://fonts.googleapis.com"}),l.createElement("link",{rel:"preconnect",href:"https://fonts.gstatic.com"}),l.createElement("link",{href:"https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&family=VT323&display=swap",rel:"stylesheet"}))}}]);
//# sourceMappingURL=component---src-components-layout-tsx-content-file-path-days-2023-12-mdx-f6974be5fd7f0a0a9eee.js.map