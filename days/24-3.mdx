---
slug: 'advent-of-code/2024/3'
year: 2024
puzz: 3
---

## Part One

Our first "just use regexp" problem of the year.

<br />

`String.prototype.matchAll()` with capture groups returns a match object in the form `[totalmatch, capture1, capture2, ...]`, so we can trivially access our desired numbers as a collection of pairs of capture groups.

<br />I opted to then defer the actual number parsing and math to a helper function,
(correctly) expecting that I'd need to use it again in part 2.

```js
export function partOne(input: string[]): number | string {
  const singleLineInput = input.reduce((total, current) => total + current, '')
  const matches =
    singleLineInput.matchAll(/mul\((\d+),(\d+)\)/g).toArray() ?? []

  return valueOfMatches(matches.map((x) => [x[1], x[2]]))
}

function valueOfMatches(matches: string[][]): number {
  return matches.reduce(
    (total, match) => total + parseInt(match[0]) * parseInt(match[1]),
    0
  )
}
```

## Part Two

There's no doubt in my mind that you could also complete part 2 with regexp, perhaps using lookbehind to ensure that there is a _do()_ more recently than a _don't()_.

<br />
However, this seemed like it would end up being a headache if requiring any debugging,
so I opted for a more typescript-y approach. I find the ranges of values that start
with a _don't()_ and end with a _do()_ (ie the ranges where we need to ignore _mult()_),
and then simply filtered out any match that started within those ranges.
<br />
Confident that there would be at most 2<sup>31</sup> characters within the
input, I opted to use 2<sup>32</sup> as a catch-all maximum range value.
<br />
Rather than filter out redundant _don't()_ or _do()_ values up front, `findDisabledRanges()`
handles them with a simple `forEach()` loop.

```js
export function partTwo(input: string[]): number | string {
  const singleLineInput = input.reduce((total, current) => total + current, '')
  const matches =
    singleLineInput.matchAll(/mul\((\d+),(\d+)\)/g).toArray() ?? []

  const donts = singleLineInput
    .matchAll(/don\'t\(\)/g)
    .toArray()
    .map((match) => match.index)

  const dos = singleLineInput
    .matchAll(/do\(\)/g)
    .toArray()
    .map((match) => match.index)

  const disabledRanges = findDisabledRanges(donts, dos)

  const inDoRange = matches?.filter(
    (match) =>
      !disabledRanges.some(
        (range) => match.index > range[0] && match.index < range[1]
      )
  )

  return valueOfMatches(inDoRange.map((match) => [match[1], match[2]]))
}

function findDisabledRanges(donts: number[], dos: number[]): number[][] {
  const disabledRanges: number[][] = [
    [donts[0], dos.find((x) => x > donts[0]) ?? 2 ** 32],
  ]

  donts.slice(1).forEach((dont) => {
    if (dont > disabledRanges.at(-1)![1])
      disabledRanges.push([dont, dos.find((x) => x > dont) ?? 2 ** 32])
  })
  return disabledRanges
}
```
