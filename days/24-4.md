---
slug: '/2024/4'
year: 2024
puzz: 4
---

## Part One

Another day revolving around text searching!
<br><br>
I opted not to try to get too clever with this one, instead using basic regexp and a single diagonal search (left-to-right, top-to-bottom) to count half of the possible _XMAS_/_SMAX_ matches, then repeating that process on a version of the input that had been rotated 90 degrees clockwise.
<br><br>
I'm certainly not in love with the way prettier has arranged the parentheses within `countDiagonal()`,
but hopefully it's still reasonably legible here.

```js
export function partOne(input: string[]): number | string {
  return [input, rotateStringArray(input)].reduce((total, current) => {
    const straight = current.reduce(
      (t, c) =>
        t + (c.match(/XMAS/g)?.length ?? 0) + (c.match(/SAMX/g)?.length ?? 0),
      0
    )
    return total + straight + countDiagonal(current)
  }, 0)
}

function rotateStringArray(input: string[]): string[] {
  const rotated: string[] = []
  for (let i = 0; i < input[0].length; i++) {
    rotated.push(
      input
        .map((current) => current[i])
        .reverse()
        .join('')
    )
  }
  return rotated
}

function countDiagonal(input: string[]): number {
  return input.reduce((total, current, y) => {
    return (
      total +
      current
        .split('')
        .reduce(
          (t, c, x) =>
            IsMatchStartPoint(input, x, y, [0, 1, 2, 3]) ? t + 1 : t,
          0
        )
    )
  }, 0)
}
```

## Part Two

A rarity where the second part is less fiddly than the first!
<br><br>
I approached the problem by acknowledging that a valid MAS X must have:

- A central 'A'
- Two 'M's, and two 'S's in the corners (ie on diagonals to the central 'A')
- The 'M' and 'S' must be on opposite sides of the central 'A'. If we have two 'M's and two 'S's, then as long as one set of 'M' and 'S' are opposite, the other must also be.
  <br><br>
  From there it's simply a matter of checking 'A' values in valid locations, and confirming they have the correct corners around them.
  <br><br>
  Once again prettier is not terribly helpful at making nested `Array.prototype.reduce()` legible outside of the editor itself, but hopefully this is readable enough!

```js
export function partTwo(input: string[]): number | string {
  return input.reduce((total, current, y) => {
    return (
      total +
      current
        .split('')
        .reduce(
          (t, c, x) =>
            input[y][x] == 'A' && isACross(input, y, x) ? t + 1 : t,
          0
        )
    )
  }, 0)
}

function isACross(input: string[], y: number, x: number): boolean {
  if (x == 0 || y == 0 || y > input.length - 2 || x > input[y].length - 2)
    return false

  const corners = [
    input[y - 1][x - 1],
    input[y + 1][x - 1],
    input[y - 1][x + 1],
    input[y + 1][x + 1],
  ]
  const count = { M: 0, S: 0, X: 0, A: 0 }
  corners.forEach((x) => count[x as keyof typeof count]++)

  return count.M == 2 && count.S == 2 && corners[0] != corners[3]
}
```
