{"version":3,"file":"component---src-components-layout-tsx-content-file-path-days-2024-14-mdx-ea595f7b4b99cade8389.js","mappings":"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","sources":["webpack://joel-allan-nz.github.io/./days/2024/14.mdx","webpack://joel-allan-nz.github.io/./src/components/Layout.tsx"],"sourcesContent":["/*@jsxRuntime classic @jsx React.createElement @jsxFrag React.Fragment*/\nimport {useMDXComponents as _provideComponents} from \"@mdx-js/react\";\nimport React from \"react\";\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    p: \"p\",\n    pre: \"pre\",\n    code: \"code\"\n  }, _provideComponents(), props.components), {CodeBox} = _components;\n  if (!CodeBox) _missingMdxReference(\"CodeBox\", true);\n  return React.createElement(React.Fragment, null, React.createElement(_components.h2, null, \"Part One\"), \"\\n\", React.createElement(_components.p, null, \"Not too much to discuss here - I parse the values and associate the velocities with their respective current position as a BathroomRobot.\"), \"\\n\", React.createElement(\"br\"), \"\\n\", React.createElement(_components.p, null, \"Then it's simply applying 100 steps of movement to each robot, and checking how many\\nare in each quadrant. I chose to use multiplication and a modulo to find the final\\nposition rather than simulating each step for obvious reasons\"), \"\\n\", React.createElement(CodeBox, {\n    boxname: \"one\",\n    names: \"typescript|C#\"\n  }, React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-js\"\n  }, \"export function partOne(input: string[]): number | string {\\n  const xSize = 101,\\n    ySize = 103\\n  const xMid = Math.floor(xSize / 2),\\n    yMid = Math.floor(ySize / 2)\\n  const robots = parse(input)\\n  const quadrants = [0, 0, 0, 0]\\n\\n  robots.forEach((robot) => {\\n    updateRobotPosition(robot, 100, xSize, ySize)\\n    if (robot.x != xMid && robot.y != yMid) {\\n      let quad = robot.x > xMid ? 1 : 0\\n      if (robot.y > yMid) quad += 2\\n      quadrants[quad]++\\n    }\\n  })\\n\\n  return quadrants.reduce((total, current) => total * current, 1)\\n}\\n\\ninterface BathroomRobot {\\n  x: number\\n  y: number\\n  vx: number\\n  vy: number\\n}\\n\\nfunction parse(input: string[]): BathroomRobot[] {\\n  return input.map((line) => {\\n    const values = [...line.matchAll(/[-\\\\d]+/g)].map((x) => parseInt(x[0]))\\n\\n    return { x: values[0], y: values[1], vx: values[2], vy: values[3] }\\n  })\\n}\\n\\nfunction updateRobotPosition(\\n  robot: BathroomRobot,\\n  steps: number,\\n  xSize: number,\\n  ySize: number\\n) {\\n  const finalX = robot.x + steps * robot.vx\\n  const finalY = robot.y + steps * robot.vy\\n\\n  robot.x = finalX % xSize\\n  robot.y = finalY % ySize\\n\\n  if (robot.x < 0) robot.x += xSize\\n  if (robot.y < 0) robot.y += ySize\\n}\\n\")), React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-csharp\"\n  }, \"public override object PartOne()\\n{\\n    int xSize = 101, ySize = 103;\\n    int xMid = xSize / 2, yMid = ySize / 2;\\n    var robots = Parse();\\n    int[] quadrants = [0, 0, 0, 0];\\n\\n    foreach (var robot in robots)\\n    {\\n        robot.UpdatePosition(100, xSize, ySize);\\n        if (robot.X == xMid || robot.Y == yMid)\\n            continue;\\n\\n        int quadrant = (robot.X > xMid) ? 1 : 0;\\n\\n        if (robot.Y > yMid)\\n            quadrant += 2;\\n\\n        quadrants[quadrant]++;\\n    }\\n\\n    return quadrants.Aggregate((x, y) => x * y);\\n}\\n\\nprivate List<BathroomRobot> Parse()\\n{\\n    return Input.Select(line =>\\n    {\\n        var values = Regex.Matches(line, @\\\"[-\\\\d]+\\\")\\n                          .Select(x => int.Parse(x.Value))\\n                          .ToList();\\n\\n        return new BathroomRobot(values[0], values[1], values[2], values[3]);\\n    }).ToList();\\n}\\n\\ninternal class BathroomRobot(int x, int y, int vx, int vy)\\n{\\n    internal int X = x;\\n    internal int Y = y;\\n    internal int VX = vx;\\n    internal int VY = vy;\\n\\n    internal void UpdatePosition(int steps, int xSize, int ySize)\\n    {\\n        int finalX = X + steps * VX;\\n        int finalY = Y + steps * VY;\\n\\n        X = finalX % xSize;\\n        Y = finalY % ySize;\\n\\n        if (X < 0)\\n            X += xSize;\\n        if (Y < 0)\\n            Y += ySize;\\n    }\\n}\\n\\n\"))), \"\\n\", React.createElement(_components.h2, null, \"Part Two\"), \"\\n\", React.createElement(_components.p, null, \"As this is a \\\"wait until you see the right thing\\\" sort of puzzle, this might be the first time my solution doesn't work for you!\"), \"\\n\", React.createElement(\"br\"), \"\\n\", React.createElement(_components.p, null, \"My approach (without displaying a visualization) is to assume that a christmas tree\\nwill require a large number of robots next to each other in at least one row, and\\nwith at least one robot neighbour each. 24 is an entirely arbitrary number (my input\\nsucceeded with a targetSize as small as 14), but it should help to avoid false positives.\"), \"\\n\", React.createElement(CodeBox, {\n    boxname: \"two\",\n    names: \"typescript|C#\"\n  }, React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-js\"\n  }, \"export function partTwo(input: string[]): number | string {\\n  const xSize = 101,\\n    ySize = 103\\n  const robots = parse(input)\\n  let steps = 0\\n  while (true) {\\n    steps++\\n    robots.forEach((robot) => updateRobotPosition(robot, 1, xSize, ySize))\\n    if (hasContiguousRowOfSize(robots, 24)) return steps\\n  }\\n}\\n\\nfunction hasContiguousRowOfSize(\\n  robots: BathroomRobot[],\\n  targetSize: number\\n): boolean {\\n  const positions = new Map<number, Set<number>>()\\n\\n  robots.forEach((robot) => {\\n    if (!positions.has(robot.y))\\n      positions.set(robot.y, new Set<number>([robot.x]))\\n    else positions.get(robot.y)?.add(robot.x)\\n  })\\n\\n  return positions.values().some((row) => {\\n    let contiguous = 0\\n    if (row.size >= targetSize) {\\n      row.values().forEach((x) => {\\n        if (row.has(x + 1)) {\\n          contiguous++\\n        }\\n      })\\n    }\\n    return contiguous >= targetSize\\n  })\\n}\\n\\n\")), React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-csharp\"\n  }, \"public override object PartTwo()\\n{\\n    int xSize = 101, ySize = 103;\\n    var robots = Parse();\\n    int steps = 0;\\n\\n    while (true)\\n    {\\n        steps++;\\n        foreach (var robot in robots)\\n            robot.UpdatePosition(1, xSize, ySize);\\n\\n        if (HasContigousRowOfSize(robots, 24))\\n            return steps;\\n    }\\n}\\n\\nprivate static bool HasContigousRowOfSize(List<BathroomRobot> robots, int size)\\n{\\n    Dictionary<int, HashSet<int>> positions = [];\\n\\n    foreach (var robot in robots)\\n        positions.AddToOrCreateCollection(robot.Y, robot.X);\\n\\n    foreach (var row in positions.Values)\\n    {\\n        if (row.Count >= size)\\n        {\\n            var contiguous = 0;\\n            foreach (var x in row)\\n            {\\n                if (row.Contains(x + 1))\\n                    contiguous++;\\n            }\\n            if (contiguous >= size)\\n                return true;\\n        }\\n    }\\n    return false;\\n}\\n\\n\"))));\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? React.createElement(MDXLayout, props, React.createElement(_createMdxContent, props)) : _createMdxContent(props);\n}\nexport default MDXContent;\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","import GATSBY_COMPILED_MDX from \"/home/joel/personal/advent-of-code/joel-allan-nz.github.io/days/2024/14.mdx\";\nimport React from 'react';\nimport {MDXProvider} from '@mdx-js/react';\nimport CodeBox from './CodeBox';\nimport TryYourself from './TryYourself';\nimport AdventSideNav from './AdventSideNav';\nimport Header from './Header';\nimport Footer from './Footer';\nconst shortcodes = {\n  CodeBox\n};\nfunction Layout(_ref) {\n  let {pageContext, children} = _ref;\n  return React.createElement(React.Fragment, null, React.createElement(Header, null), React.createElement(\"div\", {\n    className: \"min-h-screen bg-chicPrimary\"\n  }, React.createElement(AdventSideNav, {\n    props: pageContext.list\n  }), React.createElement(\"div\", {\n    className: \"adventofcode max-w-[60%] ml-[20%]\"\n  }, React.createElement(\"h1\", null, React.createElement(\"a\", {\n    href: \"https://adventofcode.com/\" + pageContext.year + \"/day/\" + pageContext.puzz\n  }, pageContext.year + \" Day \" + pageContext.puzz + \" - \" + pageContext.title)), React.createElement(MDXProvider, {\n    components: shortcodes\n  }, children), pageContext.puzz && pageContext.year ? React.createElement(TryYourself, {\n    year: pageContext.year,\n    puzz: pageContext.puzz\n  }) : React.createElement(React.Fragment, null))), React.createElement(Footer, null));\n}\nexport default function GatsbyMDXWrapper(props) {\n  return React.createElement(Layout, props, React.createElement(GATSBY_COMPILED_MDX, props));\n}\nexport const Head = () => React.createElement(React.Fragment, null, React.createElement(\"title\", null, \"Joel-Allan-NZ - Advent of Code\"), React.createElement(\"html\", {\n  lang: \"en\"\n}), React.createElement(\"link\", {\n  rel: \"preconnect\",\n  href: \"https://fonts.googleapis.com\"\n}), React.createElement(\"link\", {\n  rel: \"preconnect\",\n  href: \"https://fonts.gstatic.com\"\n}), React.createElement(\"link\", {\n  href: \"https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&family=VT323&display=swap\",\n  rel: \"stylesheet\"\n}));\n"],"names":["_createMdxContent","props","_components","Object","assign","h2","p","pre","code","_provideComponents","components","CodeBox","id","component","Error","_missingMdxReference","React","boxname","names","className","wrapper","MDXLayout","shortcodes","Layout","_ref","pageContext","children","Header","AdventSideNav","list","href","year","puzz","title","MDXProvider","TryYourself","Footer","GatsbyMDXWrapper","GATSBY_COMPILED_MDX","Head","lang","rel"],"sourceRoot":""}