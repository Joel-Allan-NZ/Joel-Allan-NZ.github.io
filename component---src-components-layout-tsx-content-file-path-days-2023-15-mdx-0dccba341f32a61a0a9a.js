"use strict";(self.webpackChunkjoel_allan_nz_github_io=self.webpackChunkjoel_allan_nz_github_io||[]).push([[4087],{4765:function(e,n,t){t.r(n),t.d(n,{Head:function(){return x},default:function(){return b}});var r=t(8453),l=t(6540);function a(e){const n=Object.assign({h2:"h2",p:"p",pre:"pre",code:"code"},(0,r.RP)(),e.components),{CodeBox:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("CodeBox",!0),l.createElement(l.Fragment,null,l.createElement(n.h2,null,"Part One"),"\n",l.createElement(n.p,null,"Another day all about coding speed and not losing time to misunderstanding the requirements. All we have to do for part 1 is apply a basic hash function to the input string, one character at a time."),"\n",l.createElement(t,{names:"typescript|C#"},l.createElement(n.pre,null,l.createElement(n.code,{className:"language-ts"},"export function partOne(input: string[]): number | string {\n  return input[0]\n    .split(',')\n    .reduce((total, current) => total + HASH(current), 0)\n}\n\nfunction HASH(s: string): number {\n  return s\n    .split('')\n    .reduce(\n      (total, char, index) => ((total + s.charCodeAt(index)) * 17) % 256,\n      0\n    )\n}\n")),l.createElement(n.pre,null,l.createElement(n.code,{className:"language-csharp"},"public override object PartOne()\n{\n    return Input[0].Split(',').Sum(x => HASHString(x));\n}\n\nprivate static int HASHString(string s)\n{\n    return Encoding.ASCII.GetBytes(s).Aggregate(0, (a, b) => ((a + b) * 17) % 256);\n}\n"))),"\n",l.createElement(n.h2,null,"Part Two"),"\n",l.createElement(n.p,null,"Still all about speed here, just adding more requirements. The possible box count lends itself easily to using an array or similar collection, but I opted for a Dictionary/Map purely to avoid any unnecessary allocations. Not meaningful for this problem, just (a potentially bad) habit."),"\n",l.createElement(t,{names:"typescript|C#"},l.createElement(n.pre,null,l.createElement(n.code,{className:"language-ts"},"export function partTwo(input: string[]): number | string {\n  const boxes = new Map<number, string[]>()\n\n  input[0].split(',').forEach((instruction) => {\n    const label =\n      instruction[instruction.length - 1] == '-'\n        ? instruction.slice(0, -1)\n        : instruction.slice(0, -2)\n\n    const hashed = HASH(label)\n\n    let box = boxes.get(hashed)\n    if (!box) {\n      box = []\n      boxes.set(hashed, box)\n    }\n\n    const index = box.findIndex((lens) => lens.slice(0, -1) == label)\n    if (instruction[instruction.length - 1] == '-') {\n      if (index != -1) box.splice(index, 1)\n    } else {\n      if (index == -1) box.push(label + instruction[instruction.length - 1])\n      else box[index] = label + instruction[instruction.length - 1]\n    }\n  })\n\n  return boxes.entries().reduce((total, box) => {\n    let index = 0\n    return (\n      total +\n      box[1].reduce((t, lens) => {\n        index++\n        return t + (box[0] + 1) * index * parseInt(lens[lens.length - 1])\n      }, 0)\n    )\n  }, 0)\n}\n")),l.createElement(n.pre,null,l.createElement(n.code,{className:"language-csharp"},"public override object PartTwo()\n{\n    Dictionary<int, List<string>> boxes = [];\n\n    foreach (var instruction in Input[0].Split(','))\n    {\n        var label = instruction[^1] == '-' ? instruction[0..^1] : instruction[0..^2];\n        var hashed = HASHString(label);\n        if (!boxes.TryGetValue(hashed, out var box))\n        {\n            box = [];\n            boxes[hashed] = box;\n        }\n        var index = box.FindIndex(x => x[0..^1] == label);\n\n        if (index == -1 && instruction[^2] == '=')\n            box.Add(label + instruction[^1]);\n        else if (instruction[^2] == '=')\n            box[index] = label + instruction[^1];\n        else if (index != -1)\n            box.RemoveAt(index);\n    }\n\n    return boxes.Sum(box =>\n    {\n        int index = 0;\n        return box.Value.Sum(lens =>\n        {\n            index++;\n            return (box.Key + 1)\n            * index * (lens[^1] - '0');\n        });\n    });\n}\n"))))}var o=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,r.RP)(),e.components);return n?l.createElement(n,e,l.createElement(a,e)):a(e)};var i=t(2779),s=t(7206),c=t(791),u=t(4813),m=t(572);const p={CodeBox:i.A};function d(e){let{pageContext:n,children:t}=e;return l.createElement(l.Fragment,null,l.createElement(u.A,null),l.createElement("div",{className:"min-h-screen bg-chicPrimary"},l.createElement(c.A,{props:n.list}),l.createElement("div",{className:"adventofcode max-w-[60%] ml-[20%]"},l.createElement("h1",null,l.createElement("a",{href:"https://adventofcode.com/"+n.year+"/day/"+n.puzz},n.year+" Day "+n.puzz+" - "+n.title)),l.createElement(r.xA,{components:p},t),n.puzz&&n.year?l.createElement(s.A,{year:n.year,puzz:n.puzz}):l.createElement(l.Fragment,null))),l.createElement(m.A,null))}function b(e){return l.createElement(d,e,l.createElement(o,e))}const x=()=>l.createElement(l.Fragment,null,l.createElement("title",null,"Joel-Allan-NZ - Advent of Code"),l.createElement("html",{lang:"en"}),l.createElement("link",{rel:"preconnect",href:"https://fonts.googleapis.com"}),l.createElement("link",{rel:"preconnect",href:"https://fonts.gstatic.com"}),l.createElement("link",{href:"https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&family=VT323&display=swap",rel:"stylesheet"}))}}]);
//# sourceMappingURL=component---src-components-layout-tsx-content-file-path-days-2023-15-mdx-0dccba341f32a61a0a9a.js.map