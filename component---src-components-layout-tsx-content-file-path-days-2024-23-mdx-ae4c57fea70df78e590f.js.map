{"version":3,"file":"component---src-components-layout-tsx-content-file-path-days-2024-23-mdx-ae4c57fea70df78e590f.js","mappings":"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","sources":["webpack://joel-allan-nz.github.io/./days/2024/23.mdx","webpack://joel-allan-nz.github.io/./src/components/Layout.tsx"],"sourcesContent":["/*@jsxRuntime classic @jsx React.createElement @jsxFrag React.Fragment*/\nimport {useMDXComponents as _provideComponents} from \"@mdx-js/react\";\nimport React from \"react\";\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    p: \"p\",\n    code: \"code\",\n    pre: \"pre\"\n  }, _provideComponents(), props.components), {CodeBox} = _components;\n  if (!CodeBox) _missingMdxReference(\"CodeBox\", true);\n  return React.createElement(React.Fragment, null, React.createElement(_components.h2, null, \"Part One\"), \"\\n\", React.createElement(_components.p, null, \"All we need to do here is find \", React.createElement(\"a\", {\n    href: \"https://en.wikipedia.org/wiki/Clique_(graph_theory)\"\n  }, \"cliques\"), \" of three computers where at least one has a name starting with \", React.createElement(_components.code, null, \"t\"), \". Nothing clever here, I just lazily take all computers that meet the naming requirement and find cliques of three computers containing them.\"), \"\\n\", React.createElement(CodeBox, {\n    boxname: \"one\",\n    names: \"typescript|C#\"\n  }, React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-js\"\n  }, \"export function partOne(input: string[]): number | string {\\n  const graph = parse(input)\\n  const trios = new Set<string>()\\n\\n  const tKeys = graph.keys().filter((key) => key.startsWith('t'))\\n  tKeys.forEach((key) => {\\n    const neighbours = graph.get(key)!\\n    neighbours.forEach((neighbour) => {\\n      const intersect = new Set([...neighbours]).intersection(\\n        new Set([...graph.get(neighbour)!])\\n      )\\n      intersect.forEach((n) => {\\n        const v = [key, n, neighbour]\\n        trios.add(v.sort().join('|'))\\n      })\\n    })\\n  })\\n  return trios.size\\n}\\n\\nfunction parse(input: string[]): Map<string, string[]> {\\n  const graph = new Map<string, string[]>()\\n  input.forEach((line) => {\\n    let split = line.split('-')\\n    if (!graph.has(split[0])) graph.set(split[0], [split[1]])\\n    else graph.get(split[0])?.push(split[1])\\n\\n    if (!graph.has(split[1])) graph.set(split[1], [split[0]])\\n    else graph.get(split[1])?.push(split[0])\\n  })\\n  return graph\\n}\\n\")), React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-csharp\"\n  }, \"public override object PartOne()\\n{\\n    HashSet<(string a, string b, string c)> trios = [];\\n    Dictionary<string, List<string>> graph = Parse();\\n\\n    foreach (var kvp in graph.Where(node => node.Key.StartsWith('t')))\\n    {\\n        foreach (var neighbour in kvp.Value)\\n        {\\n            var intersect = graph[neighbour].Intersect(kvp.Value);\\n            foreach (var n in intersect)\\n            {\\n                string[] res = [kvp.Key, n, neighbour];\\n                string[] ordered = [.. res.Order()];\\n                trios.Add((ordered[0], ordered[1], ordered[2]));\\n            }\\n        }\\n    }\\n    return trios.Count;\\n}\\n\\nprivate Dictionary<string, List<string>> Parse()\\n{\\n    Dictionary<string, List<string>> graph = [];\\n\\n    var splitLine = Input.Select(x => x.Split('-'));\\n    foreach (var split in splitLine)\\n    {\\n        if (!graph.TryGetValue(split[0], out var neighbours))\\n            graph[split[0]] = [split[1]];\\n        else\\n            graph[split[0]].Add(split[1]);\\n\\n        if (!graph.TryGetValue(split[1], out neighbours))\\n            graph[split[1]] = [split[0]];\\n        else\\n            graph[split[1]].Add(split[0]);\\n    }\\n    return graph;\\n}\\n\"))), \"\\n\", React.createElement(_components.h2, null, \"Part Two\"), \"\\n\", React.createElement(_components.p, null, \"Finding a maximal clique is a considerably bigger \", React.createElement(\"a\", {\n    href: \"https://en.wikipedia.org/wiki/Clique_problem\"\n  }, \"problem\"), \" than part 1. It screamed \\\"hey, this is probably \", React.createElement(\"a\", {\n    href: \"https://en.wikipedia.org/wiki/NP-hardness\"\n  }, \"NP-Hard\"), \"\\\", which in turn means I was unlikely to find a great solution just by thinking extra hard.\"), \"\\n\", React.createElement(\"br\"), \"\\n\", React.createElement(_components.p, null, \"I chose to use the \", React.createElement(\"a\", {\n    href: \"https://en.wikipedia.org/wiki/Bron–Kerbosch_algorithm\"\n  }, \"Bron–Kerbosch\"), \" algorithm , and specifically the second variant that includes a pivot node;\\nthis graph of computers is dense, and the pivot approach is effective for that type\\nof problem.\"), \"\\n\", React.createElement(_components.p, null, React.createElement(\"br\"), \"I won't flail around explaining a well-known and thoroughly understood\\nalgorithm like Bron-Kerbosch, I'll just say that it's pretty straight-forward to\\nimplement, and nice and quick for this problem.\"), \"\\n\", React.createElement(CodeBox, {\n    boxname: \"two\",\n    names: \"typescript|C#\"\n  }, React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-js\"\n  }, \"export function partTwo(input: string[]): number | string {\\n  const graph = parse(input)\\n  const cliques: string[] = []\\n\\n  bronKerbosch(\\n    new Set<string>(),\\n    new Set([...graph.keys()]),\\n    new Set<string>(),\\n    graph,\\n    cliques\\n  )\\n  return cliques.reduce((longest, current) =>\\n    current.length > longest.length ? current : longest\\n  )\\n}\\n\\nfunction bronKerbosch(\\n  r: Set<string>,\\n  p: Set<string>,\\n  x: Set<string>,\\n  graph: Map<string, string[]>,\\n  cliques: string[]\\n) {\\n  if (p.size == 0 && x.size == 0) {\\n    cliques.push([...r].sort().join(','))\\n    return\\n  }\\n  const pivot = [...p.union(x)].reduce(\\n    (max, current) =>\\n      graph.get(current)!.length > (graph.get(max)?.length ?? 0)\\n        ? current\\n        : max,\\n    ''\\n  )\\n  const pc: Set<string> = new Set(\\n    [...p].filter((x) => !graph.get(pivot)!.includes(x))\\n  )\\n\\n  pc.forEach((node) => {\\n    const neighbourSet = new Set(graph.get(node)!)\\n    bronKerbosch(\\n      new Set([...r, node]),\\n      p.intersection(neighbourSet),\\n      x.intersection(neighbourSet),\\n      graph,\\n      cliques\\n    )\\n    p.delete(node)\\n    x.add(node)\\n  })\\n}\\n\")), React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-csharp\"\n  }, \"public override object PartTwo()\\n{\\n    Dictionary<string, List<string>> graph = Parse();\\n    List<string> cliques = [];\\n\\n    BronKerbosch2([], [.. graph.Keys], [], graph, cliques);\\n\\n    return cliques.MaxBy(x => x.Length) ?? \\\"\\\";\\n}\\n\\nstatic void BronKerbosch2(HashSet<string> R, HashSet<string> P, HashSet<string> X, Dictionary<string, List<string>> G, List<string> O)\\n{\\n    if (P.Count == 0 && X.Count == 0)\\n    {\\n        O.Add(string.Join(\\\",\\\", R.Order()));\\n        return;\\n    }\\n    var pivot = P.Union(X).MaxBy(c => G[c].Count)!;\\n    HashSet<string> PC = [.. P.Except(G[pivot])];\\n\\n    foreach (var node in PC)\\n    {\\n        BronKerbosch2([.. R.Union([node])], [.. P.Intersect(G[node])], [.. X.Intersect(G[node])], G, O);\\n        P.Remove(node);\\n        X.Add(node);\\n    }\\n}\\n\\n\"))));\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? React.createElement(MDXLayout, props, React.createElement(_createMdxContent, props)) : _createMdxContent(props);\n}\nexport default MDXContent;\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","import GATSBY_COMPILED_MDX from \"/home/joel/personal/advent-of-code/joel-allan-nz.github.io/days/2024/23.mdx\";\nimport React from 'react';\nimport {MDXProvider} from '@mdx-js/react';\nimport CodeBox from './CodeBox';\nimport TryYourself from './TryYourself';\nimport AdventSideNav from './AdventSideNav';\nimport Header from './Header';\nimport Footer from './Footer';\nconst shortcodes = {\n  CodeBox\n};\nfunction Layout(_ref) {\n  let {pageContext, children} = _ref;\n  return React.createElement(React.Fragment, null, React.createElement(Header, null), React.createElement(\"div\", {\n    className: \"min-h-screen bg-chicPrimary\"\n  }, React.createElement(AdventSideNav, {\n    props: pageContext.list\n  }), React.createElement(\"div\", {\n    className: \"adventofcode max-w-[60%] ml-[20%]\"\n  }, React.createElement(\"h1\", null, React.createElement(\"a\", {\n    href: \"https://adventofcode.com/\" + pageContext.year + \"/day/\" + pageContext.puzz\n  }, pageContext.year + \" Day \" + pageContext.puzz + \" - \" + pageContext.title)), React.createElement(MDXProvider, {\n    components: shortcodes\n  }, children), pageContext.puzz && pageContext.year ? React.createElement(TryYourself, {\n    year: pageContext.year,\n    puzz: pageContext.puzz\n  }) : React.createElement(React.Fragment, null))), React.createElement(Footer, null));\n}\nexport default function GatsbyMDXWrapper(props) {\n  return React.createElement(Layout, props, React.createElement(GATSBY_COMPILED_MDX, props));\n}\nexport const Head = () => React.createElement(React.Fragment, null, React.createElement(\"title\", null, \"Joel-Allan-NZ - Advent of Code\"), React.createElement(\"html\", {\n  lang: \"en\"\n}), React.createElement(\"link\", {\n  rel: \"preconnect\",\n  href: \"https://fonts.googleapis.com\"\n}), React.createElement(\"link\", {\n  rel: \"preconnect\",\n  href: \"https://fonts.gstatic.com\"\n}), React.createElement(\"link\", {\n  href: \"https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&family=VT323&display=swap\",\n  rel: \"stylesheet\"\n}));\n"],"names":["_createMdxContent","props","_components","Object","assign","h2","p","code","pre","_provideComponents","components","CodeBox","id","component","Error","_missingMdxReference","React","href","boxname","names","className","wrapper","MDXLayout","shortcodes","Layout","_ref","pageContext","children","Header","AdventSideNav","list","year","puzz","title","MDXProvider","TryYourself","Footer","GatsbyMDXWrapper","GATSBY_COMPILED_MDX","Head","lang","rel"],"sourceRoot":""}