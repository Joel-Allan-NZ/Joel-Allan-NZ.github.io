"use strict";(self.webpackChunkjoel_allan_nz_github_io=self.webpackChunkjoel_allan_nz_github_io||[]).push([[2355],{2580:function(n,e,t){t.r(e),t.d(e,{Head:function(){return h},default:function(){return g}});var s=t(8453),i=t(6540);function l(n){const e=Object.assign({h2:"h2",p:"p",pre:"pre",code:"code",em:"em",ol:"ol",li:"li",a:"a"},(0,s.RP)(),n.components),{CodeBox:t}=e;return t||function(n,e){throw new Error("Expected "+(e?"component":"object")+" `"+n+"` to be defined: you likely forgot to import, pass, or provide it.")}("CodeBox",!0),i.createElement(i.Fragment,null,i.createElement(e.h2,null,"Part One"),"\n",i.createElement(e.p,null,"Another pretty straight-forward part one. Model the system, press the button, count the pulse, return an answer."),"\n",i.createElement("br"),"\n",i.createElement(e.p,null,"Given that this look suspiciously like a program of some type being executed (logic\ngates), part 2 is probably going to be a nightmare ðŸ˜†"),"\n",i.createElement(t,{names:"typescript|C#"},i.createElement(e.pre,null,i.createElement(e.code,{className:"language-ts"},"export function partOne(input: string[]): number | string {\n  var modules = parse(input)\n  const pulses = [0, 0]\n\n  for (let i = 0; i < 1000; i++) {\n    const result = buttonPulses(modules, i)\n    pulses[0] += result[0]\n    pulses[1] += result[1]\n  }\n\n  return pulses[0] * pulses[1]\n}\n\ninterface Module {\n  type: string\n  name: string\n  connections: string[]\n  high: boolean\n  inputs: Map<string, boolean> | undefined\n}\n\ninterface Pulse {\n  high: boolean\n  origin: string\n  destination: string\n}\n\nfunction parse(input: string[]): Map<string, Module> {\n  const modules = new Map<string, Module>()\n  const outputOnly = new Set<string>()\n\n  input.forEach((line) => {\n    const split = line.split(/\\, | /)\n    const type = split[0][0]\n    const name = type == 'b' ? split[0] : split[0].slice(1)\n    modules.set(name, {\n      type,\n      name,\n      connections: split.slice(2),\n      high: false,\n      inputs: undefined,\n    })\n  })\n\n  modules.entries().forEach((kvp) => {\n    if (kvp[1].type == '&') {\n      kvp[1].inputs = new Map<string, boolean>()\n      modules.values().forEach((value) => {\n        if (value.connections.includes(kvp[0]))\n          kvp[1].inputs!.set(value.name, false)\n      })\n    }\n    kvp[1].connections.forEach((connection) => {\n      if (!modules.has(connection)) outputOnly.add(connection)\n    })\n  })\n\n  outputOnly.forEach((name) =>\n    modules.set(name, {\n      type: 'b',\n      name,\n      connections: [],\n      high: true,\n      inputs: undefined,\n    })\n  )\n\n  return modules\n}\n\nfunction buttonPulses(\n  modules: Map<string, Module>,\n  presses: number,\n  monitoring: Map<string, number> | undefined = undefined\n): number[] {\n  let queue: Pulse[] = []\n  const pulses = [1, 0]\n  queue.push({ high: false, origin: 'button', destination: 'broadcaster' })\n\n  while (queue.length > 0) {\n    const pulse = queue.shift()!\n    const destination = modules.get(pulse.destination)!\n\n    if (monitoring && pulse.high && monitoring.has(pulse.origin))\n      if (monitoring.get(pulse.origin) == -1)\n        monitoring.set(pulse.origin, presses)\n\n    handlePulse(destination, pulse, pulses, queue)\n  }\n  return pulses\n}\n\nfunction handlePulse(\n  destination: Module,\n  pulse: Pulse,\n  pulses: number[],\n  next: Pulse[]\n): void {\n  if (destination.type == '%') {\n    if (!pulse.high) {\n      destination.high = !destination.high\n      countPulses(destination.high, destination.connections.length, pulses)\n\n      destination.connections.forEach((connection) =>\n        next.push({\n          high: destination.high,\n          origin: destination.name,\n          destination: connection,\n        })\n      )\n    }\n  } else if (destination.type == '&') {\n    destination.inputs!.set(pulse.origin, pulse.high)\n    const output = destination.inputs!.values().some((x) => !x)\n    countPulses(output, destination.connections.length, pulses)\n\n    destination.connections.forEach((connection) =>\n      next.push({\n        high: output,\n        origin: destination.name,\n        destination: connection,\n      })\n    )\n  } else {\n    pulses[0] += destination.connections.length\n    destination.connections.forEach((connection) =>\n      next.push({\n        high: false,\n        origin: destination.name,\n        destination: connection,\n      })\n    )\n  }\n}\n\nfunction countPulses(high: boolean, length: number, pulses: number[]) {\n  if (high) pulses[1] += length\n  else pulses[0] += length\n}\n")),i.createElement(e.pre,null,i.createElement(e.code,{className:"language-csharp"},"public override object PartOne()\n{\n    var modules = Parse(Input);\n    long[] pulses = [0, 0];\n    for (int i = 0; i < 1000; i++)\n    {\n        var pulseResult = ButtonPulses(modules, i);\n        pulses[0] += pulseResult[0];\n        pulses[1] += pulseResult[1];\n    }\n    return pulses[0] * pulses[1];\n}\n\nprivate static Dictionary<string, Module> Parse(string[] input)\n{\n    Dictionary<string, Module> modules = [];\n    HashSet<string> outputOnly = [];\n\n    foreach (var line in input)\n    {\n        var split = line.Split([' ', ','], StringSplitOptions.RemoveEmptyEntries);\n        var type = split[0][0];\n        var name = type == 'b' ? split[0] : split[0][1..];\n        modules.Add(name, new(type, name, split[2..], false));\n    }\n\n    foreach (var kvp in modules)\n    {\n        if (kvp.Value.Type == '&')\n        {\n            foreach (var value in modules.Values)\n            {\n                if (value.Connections.Contains(kvp.Key))\n                    kvp.Value.Inputs.Add(value.Name, false);\n            }\n        }\n        foreach (var value in kvp.Value.Connections)\n        {\n            if (!modules.ContainsKey(value))\n                outputOnly.Add(value);\n        }\n    }\n\n    foreach (var v in outputOnly)\n        modules.Add(v, new('b', v, [], true));\n\n    return modules;\n}\n\nprivate static long[] ButtonPulses(Dictionary<string, Module> modules, int presses, Dictionary<string, long>? monitoring = null)\n{\n    Queue<Pulse> queue = [];\n    long[] pulses = [1, 0];\n    queue.Enqueue(new(false, \"button\", \"broadcaster\"));\n    while (queue.Count > 0)\n    {\n        var pulse = queue.Dequeue();\n        var destination = modules[pulse.Destination];\n\n        if (monitoring != null && pulse.High && monitoring.ContainsKey(pulse.Origin))\n        {\n            if (monitoring[pulse.Origin] == -1)\n                monitoring[pulse.Origin] = presses;\n        }\n\n        HandlePulse(destination, pulse, pulses, queue);\n    }\n    return pulses;\n}\n\nprivate static void HandlePulse(Module destination, Pulse pulse, long[] pulses, Queue<Pulse> nextPulses)\n{\n    if (destination.Type == '%')\n    {\n        if (!pulse.High)\n        {\n            destination.Value = !destination.Value;\n            countPulses(destination.Value, destination.Connections.Length, pulses);\n\n            foreach (var connection in destination.Connections)\n                nextPulses.Enqueue(new(destination.Value, destination.Name, connection));\n        }\n    }\n    else if (destination.Type == '&')\n    {\n        destination.Inputs[pulse.Origin] = pulse.High;\n        var output = destination.Inputs.Values.Any(x => !x);\n        countPulses(output, destination.Connections.Length, pulses);\n\n        foreach (var connection in destination.Connections)\n            nextPulses.Enqueue(new(output, destination.Name, connection));\n    }\n    else\n    {\n        pulses[0] += destination.Connections.Length;\n        foreach (var connection in destination.Connections)\n            nextPulses.Enqueue(new(false, destination.Name, connection));\n    }\n\n    static void countPulses(bool high, long length, long[] pulses)\n    {\n        if (high) pulses[1] += length;\n        else pulses[0] += length;\n    }\n}\n\ninternal class Pulse(bool high, string origin, string destination)\n{\n    internal bool High = high;\n    internal string Origin = origin;\n    internal string Destination = destination;\n}\n\ninternal class Module(char type, string name, string[] connections, bool value)\n{\n    internal char Type = type;\n    internal string Name = name;\n    internal string[] Connections = connections;\n    internal bool Value = value;\n    internal Dictionary<string, bool> Inputs = [];\n}\n"))),"\n",i.createElement(e.h2,null,"Part Two"),"\n",i.createElement(e.p,null,"Dire predictions aside, this one wasn't too bad!"),"\n",i.createElement("br"),"\n",i.createElement(e.p,null,"Attempting to use the same approach as part one quickly proved not to scale realistically,\nso the new idea is to find when pulses are fed to the grandparents of the target\nmodule, and use them to find the first time that a high pulse could be sent to ",i.createElement(e.code,null,"rx"),"."),"\n",i.createElement("br"),"\n",i.createElement(e.p,null,"This approach is built on a ",i.createElement(e.em,null,"number")," of assumptions."),"\n",i.createElement(e.ol,null,"\n",i.createElement(e.li,null,"\n",i.createElement(e.p,null,"All inputs are structured with a single ",i.createElement(e.code,null,"&")," parent leading into ",i.createElement(e.code,null,"rx"),". There's no direct evidence to support this, but problem inputs are intended to be similarly difficult. Therefore we can be reasonably confident on this."),"\n"),"\n",i.createElement(e.li,null,"\n",i.createElement(e.p,null,"The system cycles. Again, no obvious direct evidence from the clue or input, but we can reason that it's likely. Emperically demonstrated with a valid answer based on that underlying assumption."),"\n"),"\n",i.createElement(e.li,null,"\n",i.createElement(e.p,null,"The inputs to ",i.createElement(e.code,null,"rx"),"'s parent will have prime-number length cycles. This proved to be true for my input, but it's possible (though unlikely IMO) that there are inputs that do not have prime length cycles. For those inputs finding the ",i.createElement(e.a,{href:"https://en.wikipedia.org/wiki/Least_common_multiple"},"LCM")," of parent cycles would be required."),"\n"),"\n"),"\n",i.createElement("br"),"\n",i.createElement(e.p,null,"If those assumptions prove to be incorrect for your input then this will fail for\nyou, but in my opinion that's unlikely. Good luck!"),"\n",i.createElement(t,{names:"typescript|C#"},i.createElement(e.pre,null,i.createElement(e.code,{className:"language-ts"},"export function partTwo(input: string[]): number | string {\n  const modules = parse(input)\n  const grandParentHigh = new Map<string, number>()\n  const rxParents = modules.values().filter((x) => x.connections.includes('rx'))\n\n  rxParents.forEach((parent) =>\n    parent.inputs?.keys().forEach((input) => grandParentHigh.set(input, -1))\n  )\n\n  let pressed = 0\n\n  while (modules.get('rx')!.high) {\n    pressed++\n    buttonPulses(modules, pressed, grandParentHigh)\n    if (grandParentHigh.values().every((v) => v != -1)) {\n      console.log(grandParentHigh.values())\n      return grandParentHigh.values().reduce((total, value) => value * total, 1)\n    }\n  }\n  return pressed\n}\n")),i.createElement(e.pre,null,i.createElement(e.code,{className:"language-csharp"},'public override object PartTwo()\n{\n    var modules = Parse(Input);\n    var rxParents = modules.Values.Where(x => x.Connections.Contains("rx"));\n    var rxGrandParents = rxParents.SelectMany(x => x.Inputs.Keys);\n    Dictionary<string, long> grandParentHigh = [];\n\n    foreach (var gp in rxGrandParents)\n        grandParentHigh[gp] = -1;\n\n    int pressed = 0;\n    while (modules["rx"].Value)\n    {\n        pressed++;\n        ButtonPulses(modules, pressed, grandParentHigh);\n        if (grandParentHigh.Values.All(x => x != -1))\n            return grandParentHigh.Values.Aggregate((x, y) => x * y);\n    }\n    return pressed;\n}\n'))))}var o=function(n){void 0===n&&(n={});const{wrapper:e}=Object.assign({},(0,s.RP)(),n.components);return e?i.createElement(e,n,i.createElement(l,n)):l(n)};var a=t(2779),r=t(7206),u=t(791),c=t(4813),p=t(572);const d={CodeBox:a.A};function m(n){let{pageContext:e,children:t}=n;return i.createElement(i.Fragment,null,i.createElement(c.A,null),i.createElement("div",{className:"min-h-screen bg-chicPrimary"},i.createElement(u.A,{props:e.list}),i.createElement("div",{className:"adventofcode max-w-[60%] ml-[20%]"},i.createElement("h1",null,i.createElement("a",{href:"https://adventofcode.com/"+e.year+"/day/"+e.puzz},e.year+" Day "+e.puzz+" - "+e.title)),i.createElement(s.xA,{components:d},t),e.puzz&&e.year?i.createElement(r.A,{year:e.year,puzz:e.puzz}):i.createElement(i.Fragment,null))),i.createElement(p.A,null))}function g(n){return i.createElement(m,n,i.createElement(o,n))}const h=()=>i.createElement(i.Fragment,null,i.createElement("title",null,"Joel-Allan-NZ - Advent of Code"),i.createElement("html",{lang:"en"}),i.createElement("link",{rel:"preconnect",href:"https://fonts.googleapis.com"}),i.createElement("link",{rel:"preconnect",href:"https://fonts.gstatic.com"}),i.createElement("link",{href:"https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&family=VT323&display=swap",rel:"stylesheet"}))}}]);
//# sourceMappingURL=component---src-components-layout-tsx-content-file-path-days-2023-20-mdx-406ddc3f6b3503cecd03.js.map