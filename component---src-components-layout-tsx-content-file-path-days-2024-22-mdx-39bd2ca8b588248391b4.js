"use strict";(self.webpackChunkjoel_allan_nz_github_io=self.webpackChunkjoel_allan_nz_github_io||[]).push([[6916],{5622:function(e,t,n){n.r(t),n.d(t,{Head:function(){return d},default:function(){return h}});var r=n(8453),s=n(6540);function a(e){const t=Object.assign({h2:"h2",p:"p",pre:"pre",code:"code",em:"em"},(0,r.RP)(),e.components),{CodeBox:n}=t;return n||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("CodeBox",!0),s.createElement(s.Fragment,null,s.createElement(t.h2,null,"Part One"),"\n",s.createElement(t.p,null,"A lot of words to say you need to implement a simple update-the-secret function. I opted for bit shifting over multiplying/dividing by powers of two, but I don't think it leads to anything like a measurable difference."),"\n",s.createElement(n,{boxname:"one",names:"typescript|C#"},s.createElement(t.pre,null,s.createElement(t.code,{className:"language-js"},"export function partOne(input: string[]): number | string {\n  const secrets = input.map((x) => parseInt(x))\n\n  return secrets.reduce((total, secret) => {\n    for (let i = 0; i < 2000; i++) secret = getNextSecret(secret)\n\n    return total + secret\n  }, 0)\n}\n\nfunction getNextSecret(secret: number): number {\n  secret ^= secret << 6\n  secret = ((secret % 16777216) + 16777216) % 16777216\n\n  secret ^= secret >> 5\n  secret = ((secret % 16777216) + 16777216) % 16777216\n\n  secret ^= secret << 11\n  return ((secret % 16777216) + 16777216) % 16777216\n}\n")),s.createElement(t.pre,null,s.createElement(t.code,{className:"language-csharp"},"public override object PartOne()\n{\n    var secrets = Input.Select(x => long.Parse(x));\n\n    return secrets.Sum(secret =>\n    {\n        for (int i = 0; i < 2000; i++)\n            secret = GetNextSecret(secret);\n\n        return secret;\n    });\n}\n\nprivate static long GetNextSecret(long secret)\n{\n    secret ^= (secret << 6);\n    secret %= 16777216;\n\n    secret ^= (secret >> 5);\n    secret %= 16777216;\n\n    secret ^= (secret << 11);\n    return secret % 16777216;\n}\n"))),"\n",s.createElement(t.h2,null,"Part Two"),"\n",s.createElement(t.p,null,"A very straightforward approach, but I use a couple small tricks for performance. Firstly, I use a little addition to treat the possible changes/differences between consecutive secrets as a number between 0 and 19. Pairing this with a 4-dimensional array allows for very quick access; quicker than repeatedly needing to hash values."),"\n",s.createElement("br"),"\n",s.createElement(t.p,null,"Secondly, I ",s.createElement(t.em,null,"do")," use some hashing with a little bit of a lazy hash function where\nI generate a number without collisions from the four entries in ",s.createElement(t.code,null,"lastFour"),". Quicker\nin this instance than repeatedly reinitializing the set of arrays."),"\n",s.createElement(n,{boxname:"two",names:"typescript|C#"},s.createElement(t.pre,null,s.createElement(t.code,{className:"language-js"},"export function partTwo(input: string[]): number | string {\n  const secrets = input.map((x) => parseInt(x))\n  const permTotals: number[][][][] = []\n  for (let i = 0; i < 19; i++) {\n    permTotals.push([])\n    for (let j = 0; j < 19; j++) {\n      permTotals[i].push([])\n      for (let k = 0; k < 19; k++) permTotals[i][j].push(Array(19).fill(0))\n    }\n  }\n  let max = 0\n  secrets.forEach(\n    (secret) => (max = countSecretTotals(secret, permTotals, max))\n  )\n  return max\n}\n\nfunction countSecretTotals(\n  secret: number,\n  permTotals: number[][][][],\n  max: number\n) {\n  const seen = new Set<number>()\n  const secretValues: number[] = [secret % 10]\n\n  for (let i = 0; i < 2000; i++) {\n    secret = getNextSecret(secret)\n    secretValues.push(secret % 10)\n\n    if (i > 2) {\n      const lastFour = [\n        9 + secretValues[i + 1] - secretValues[i],\n        9 + secretValues[i] - secretValues[i - 1],\n        9 + secretValues[i - 1] - secretValues[i - 2],\n        9 + secretValues[i - 2] - secretValues[i - 3],\n      ]\n      const s =\n        lastFour[0] * 1000000 +\n        lastFour[1] * 10000 +\n        lastFour[2] * 100 +\n        lastFour[3]\n\n      if (!seen.has(s)) {\n        const res =\n          permTotals[lastFour[0]][lastFour[1]][lastFour[2]][lastFour[3]] +\n          (secret % 10)\n        permTotals[lastFour[0]][lastFour[1]][lastFour[2]][lastFour[3]] = res\n        if (res > max) max = res\n        seen.add(s)\n      }\n    }\n  }\n  return max\n}\n")),s.createElement(t.pre,null,s.createElement(t.code,{className:"language-csharp"},"public override object PartTwo()\n{\n    var secrets = Input.Select(x => long.Parse(x));\n    int[,,,] permTotals = new int[19, 19, 19, 19];\n    long max = 0;\n\n    foreach (var secret in secrets)\n    {\n        max = CountSecretTotals(secret, permTotals, max);\n    }\n    return max;\n}\n\nprivate static long CountSecretTotals(long secret, int[,,,] permTotals, long max)\n{\n    HashSet<int> seen = [];\n    int[] secrets = new int[2001];\n    secrets[0] = (int)(secret % 10);\n\n    for (int i = 0; i < 2000; i++)\n    {\n        secret = GetNextSecret(secret);\n        secrets[i + 1] = (int)(secret % 10);\n        if (i > 2)\n        {\n            int[] lastFour = [secrets[i + 1] - secrets[i] + 9,\n                secrets[i] - secrets[i - 1] + 9,\n                secrets[i - 1] - secrets[i - 2] + 9,\n                secrets[i - 2] - secrets[i - 3] + 9];\n            var s = lastFour[0] * 1000000 + lastFour[1] * 10000 + lastFour[2] * 100 + lastFour[3];\n\n            if (!seen.Contains(s))\n            {\n                var res = permTotals[lastFour[0], lastFour[1], lastFour[2], lastFour[3]] + (int)(secret % 10);\n                permTotals[lastFour[0], lastFour[1], lastFour[2], lastFour[3]] = res;\n                if (res > max)\n                    max = res;\n\n                seen.Add(s);\n            }\n        }\n    }\n    return max;\n}\n"))))}var l=function(e){void 0===e&&(e={});const{wrapper:t}=Object.assign({},(0,r.RP)(),e.components);return t?s.createElement(t,e,s.createElement(a,e)):a(e)};var c=n(2779),o=n(7206),i=n(791),u=n(4813),m=n(572);const p={CodeBox:c.A};function f(e){let{pageContext:t,children:n}=e;return s.createElement(s.Fragment,null,s.createElement(u.A,null),s.createElement("div",{className:"min-h-screen bg-chicPrimary"},s.createElement(i.A,{props:t.list}),s.createElement("div",{className:"adventofcode max-w-[60%] ml-[20%]"},s.createElement("h1",null,s.createElement("a",{href:"https://adventofcode.com/"+t.year+"/day/"+t.puzz},t.year+" Day "+t.puzz+" - "+t.title)),s.createElement(r.xA,{components:p},n),t.puzz&&t.year?s.createElement(o.A,{year:t.year,puzz:t.puzz}):s.createElement(s.Fragment,null))),s.createElement(m.A,null))}function h(e){return s.createElement(f,e,s.createElement(l,e))}const d=()=>s.createElement(s.Fragment,null,s.createElement("title",null,"Joel-Allan-NZ - Advent of Code"),s.createElement("html",{lang:"en"}),s.createElement("link",{rel:"preconnect",href:"https://fonts.googleapis.com"}),s.createElement("link",{rel:"preconnect",href:"https://fonts.gstatic.com"}),s.createElement("link",{href:"https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&family=VT323&display=swap",rel:"stylesheet"}))}}]);
//# sourceMappingURL=component---src-components-layout-tsx-content-file-path-days-2024-22-mdx-39bd2ca8b588248391b4.js.map