"use strict";(self.webpackChunkjoel_allan_nz_github_io=self.webpackChunkjoel_allan_nz_github_io||[]).push([[1918],{4097:function(n,e,t){t.r(e),t.d(e,{Head:function(){return h},default:function(){return x}});var o=t(8453),r=t(6540);function i(n){const e=Object.assign({h2:"h2",p:"p",pre:"pre",code:"code"},(0,o.RP)(),n.components),{CodeBox:t}=e;return t||function(n,e){throw new Error("Expected "+(e?"component":"object")+" `"+n+"` to be defined: you likely forgot to import, pass, or provide it.")}("CodeBox",!0),r.createElement(r.Fragment,null,r.createElement(e.h2,null,"Part One"),"\n",r.createElement(e.p,null,"Much like yesterday we're greeted with a very long problem summary. Part one boils down to parsing the data and using it to create a valid adjacency graph, then traversing that graph to find the most distant point from the start. I opted for a basic ",r.createElement("a",{href:"https://en.wikipedia.org/wiki/Breadth-first_search"},"breadth first search.")," Nothing fancy; gets the job done."),"\n",r.createElement(t,{names:"typescript|C#"},r.createElement(e.pre,null,r.createElement(e.code,{className:"language-js"},"export function partOne(input: string[]): number | string {\n  const { start, connections, coords } = parse(input)\n  const loop = exploreLoop(connections, start)\n\n  return loop\n    .values()\n    .reduce((max, current) => (current > max ? current : max), 0)\n}\n\ninterface Coord {\n  x: number\n  y: number\n}\n\nfunction parse(input: string[]): {\n  start: Coord\n  connections: Map<number, number[]>\n  coords: Map<number, Coord>\n} {\n  const start: Coord = { x: 0, y: 0 }\n  const possibleConnections = new Map<number, number[]>()\n  const coords = new Map<number, Coord>()\n\n  input.forEach((line, y) => {\n    line.split('').forEach((c, x) => {\n      possibleConnections.set(\n        coordToNumber({ x, y }),\n        neighbours(x, y, c).map((coord) => coordToNumber(coord))\n      )\n\n      if (c == 'S') {\n        start.x = x\n        start.y = y\n      }\n    })\n  })\n\n  const connections = new Map<number, number[]>()\n\n  possibleConnections.keys().forEach((key) => {\n    connections.set(\n      key,\n      possibleConnections\n        .get(key)!\n        .filter(\n          (n) =>\n            possibleConnections.has(n) &&\n            possibleConnections.get(n)!.includes(key)\n        )\n    )\n  })\n  return { start, connections, coords }\n}\n\nfunction coordToNumber(coord: Coord): number {\n  return coord.x * 100000 + coord.y\n}\n\nfunction numberToCoord(number: number): Coord {\n  return {\n    x: Math.floor(number / 100000),\n    y: number % 100000,\n  }\n}\n\nfunction neighbours(x: number, y: number, c: string): Coord[] {\n  switch (c) {\n    case '|':\n      return [\n        { x, y: y - 1 },\n        { x, y: y + 1 },\n      ]\n    case '-':\n      return [\n        { x: x - 1, y },\n        { x: x + 1, y },\n      ]\n    case 'L':\n      return [\n        { x, y: y - 1 },\n        { x: x + 1, y },\n      ]\n    case 'J':\n      return [\n        { x, y: y - 1 },\n        { x: x - 1, y },\n      ]\n    case '7':\n      return [\n        { x, y: y + 1 },\n        { x: x - 1, y },\n      ]\n    case 'F':\n      return [\n        { x, y: y + 1 },\n        { x: x + 1, y },\n      ]\n    case 'S':\n      return [\n        { x, y: y + 1 },\n        { x: x + 1, y },\n        { x: x - 1, y },\n        { x, y: y - 1 },\n      ]\n    default:\n      return []\n  }\n}\n\nfunction exploreLoop(\n  graph: Map<number, number[]>,\n  start: Coord\n): Map<number, number> {\n  const toVisit = [coordToNumber(start)]\n  const distances = new Map<number, number>()\n  distances.set(toVisit[0], 0)\n\n  while (toVisit.length > 0) {\n    var current = toVisit.shift()!\n    graph.get(current)?.forEach((neighbour) => {\n      if (!distances.has(neighbour)) {\n        distances.set(neighbour, distances.get(current)! + 1)\n        toVisit.push(neighbour)\n      }\n    })\n  }\n  return distances\n}\n")),r.createElement(e.pre,null,r.createElement(e.code,{className:"language-csharp"},"public override object PartOne()\n{\n    var (start, pipes) = Parse();\n\n    return ExploreLoop(pipes, start).Max(x => x.Value);\n}\n\nprivate static Dictionary<(int x, int y), int> ExploreLoop(Dictionary<(int x, int y), List<(int x, int y)>> pipes, (int x, int y) start)\n{\n    Queue<(int x, int y)> toVisit = [];\n    toVisit.Enqueue(start);\n    Dictionary<(int x, int y), int> distances = [];\n    distances.Add(start, 0);\n\n    while (toVisit.Count > 0)\n    {\n        var current = toVisit.Dequeue();\n        foreach (var neighbour in pipes[current])\n        {\n            if (distances.TryGetValue(neighbour, out var distance))\n                continue;\n\n            distances.Add(neighbour, distances[current] + 1);\n            toVisit.Enqueue(neighbour);\n        }\n    }\n    return distances;\n}\n\nprivate ((int x, int y) start, Dictionary<(int x, int y), List<(int x, int y)>> pipes) Parse()\n{\n    var start = (x: 0, y: 0);\n    Dictionary<(int x, int y), (int x, int y)[]> possibleConnections = [];\n    for (int y = 0; y < Input.Length; y++)\n    {\n        for (int x = 0; x < Input[y].Length; x++)\n        {\n            possibleConnections.Add((x, y), Neighbours(x, y, Input[y][x]));\n\n            if (Input[y][x] == 'S')\n                start = (x, y);\n        }\n    }\n\n    Dictionary<(int x, int y), List<(int x, int y)>> confirmedConnections = [];\n\n    foreach (var pipe in possibleConnections)\n    {\n        var possibleNeighbours = pipe.Value.Where(n => possibleConnections.TryGetValue(n, out var neighbours) &&\n                                                    neighbours.Contains(pipe.Key))\n                                           .ToList();\n        confirmedConnections.Add(pipe.Key, possibleNeighbours);\n    }\n    return (start, confirmedConnections);\n}\n\nprivate static (int x, int y)[] Neighbours(int x, int y, char c) => c switch\n{\n    '|' => [(x, y - 1), (x, y + 1)],\n    '-' => [(x - 1, y), (x + 1, y)],\n    'L' => [(x, y - 1), (x + 1, y)],\n    'J' => [(x, y - 1), (x - 1, y)],\n    '7' => [(x, y + 1), (x - 1, y)],\n    'F' => [(x, y + 1), (x + 1, y)],\n    'S' => [(x, y + 1), (x + 1, y), (x - 1, y), (x, y - 1)],\n    _ => []\n};\n"))),"\n",r.createElement(e.h2,null,"Part Two"),"\n",r.createElement(e.p,null,"This was a little bit trickier, and required some thinking."),"\n",r.createElement("br"),"\n",r.createElement(e.p,null,"The core idea is to find tiles entirely enclosed by the loop, with the added problem\nof being able to 'squeeze' between adjacent pipes that aren't connected. One approach\nthat should be immediately obvious is to double the area, and create new nodes/edges\nto represent squeezable paths. However, that approach comes with an equally obvious\ndownside: tracking how many tiles are 'real' vs expanded seems like a headache."),"\n",r.createElement("br"),"\n",r.createElement(e.p,null,"I opted for a different but equally fiddly approach, where I didn't increase the\narea but instead created a new set of rules for traversing squeezable space. For\nthis I consider the current position as being at the bottom right corner of a tile,\nand being able to squeeze as if you were on that side of it. All spaces that aren't\nenclosed should either be able to navigate via squeezing to an edge of the map (and\ntherefore they can't be enclosed), or be part of a space that isn't adjacent to the\nloop."),"\n",r.createElement("br"),"\n",r.createElement(e.p,null,"Notice a logical error there? What about spaces that are adjacent to the loop, but\ncan't squeeze out to a side due to some other non-loop blockage? The simple answer\nis... I made an assumption that such a structure wouldn't exist in the input, and\nwas proved correct (for my input at least). If it fails for you, then now you know\na possible reason why (and it should be a pretty trivial fix)!"),"\n",r.createElement(t,{names:"typescript|C#"},r.createElement(e.pre,null,r.createElement(e.code,{className:"language-ts"},"export function partTwo(input: string[]): number | string {\n  const { start, connections, coords } = parse(input)\n  const loop = exploreLoop(connections, start)\n  const loopKeys = new Set<number>([...loop.keys()])\n\n  const locationStatus = new Map<number, boolean>()\n\n  connections.keys().forEach((key) => {\n    if (!loop.has(key) && !locationStatus.has(key)) {\n      const { positions, enclosed } = findGroundStatus(\n        connections,\n        loopKeys,\n        key,\n        input\n      )\n\n      positions.forEach((position) => {\n        if (connections.has(position) && !loopKeys.has(position))\n          locationStatus.set(position, enclosed)\n        else locationStatus.set(position, false)\n      })\n    }\n  })\n  return locationStatus\n    .values()\n    .reduce((total, current) => (current ? total + 1 : total), 0)\n}\n\nfunction findGroundStatus(\n  connections: Map<number, number[]>,\n  loop: Set<number>,\n  position: number,\n  input: string[]\n): { positions: Set<number>; enclosed: boolean } {\n  const positions = new Set<number>([position])\n  const toExplore = [numberToCoord(position)]\n  let enclosed = true\n  let haveSeenLoop = false\n\n  while (toExplore.length > 0) {\n    const currentCoord = toExplore.shift()!\n    const current = coordToNumber(currentCoord)\n\n    if (connections.has(current)) {\n      if (loop.has(current)) haveSeenLoop = true\n      if (\n        currentCoord.x == input[0].length - 1 ||\n        currentCoord.y == input.length - 1\n      )\n        enclosed = false\n\n      findNextAccessibleTiles(connections, current).forEach((next) => {\n        const nextNumber = coordToNumber(next)\n        if (!positions.has(nextNumber)) {\n          toExplore.push(next)\n          positions.add(nextNumber)\n        }\n      })\n    } else enclosed = false\n  }\n\n  return { positions, enclosed: haveSeenLoop && enclosed }\n}\n\nfunction findNextAccessibleTiles(\n  connections: Map<number, number[]>,\n  position: number\n): Coord[] {\n  const { x, y } = numberToCoord(position)\n  const next: Coord[] = []\n  let current = connections.get(position)\n\n  if (current) {\n    if (!current.includes(coordToNumber({ x: x + 1, y })))\n      next.push({ x, y: y - 1 })\n    if (!current.includes(coordToNumber({ x, y: y + 1 })))\n      next.push({ x: x - 1, y })\n  }\n\n  current = connections.get(coordToNumber({ x, y: y + 1 }))\n  if (current && !current.includes(coordToNumber({ x: x + 1, y: y + 1 })))\n    next.push({ x, y: y + 1 })\n\n  current = connections.get(coordToNumber({ x: x + 1, y }))\n  if (current && !current.includes(coordToNumber({ x: x + 1, y: y + 1 })))\n    next.push({ x: x + 1, y })\n\n  return next\n}\n")),r.createElement(e.pre,null,r.createElement(e.code,{className:"language-csharp"},"public override object PartTwo()\n{\n    var (start, pipes) = Parse();\n    var loop = ExploreLoop(pipes, start).Keys.ToHashSet();\n\n\n    Dictionary<(int x, int y), bool> locationStatus = [];\n    foreach (var groundTile in pipes.Keys)\n    {\n        if (!loop.Contains(groundTile) && !locationStatus.ContainsKey(groundTile))\n        {\n            var (positions, enclosed) = FindGroundStatus(pipes, loop, groundTile);\n            foreach (var g in positions)\n            {\n                if (pipes.ContainsKey(g) && !loop.Contains(g))\n                    locationStatus.Add(g, enclosed);\n                else\n                    locationStatus.Add(g, false);\n            }\n        }\n    }\n    return locationStatus.Count(x => x.Value == true);\n}\n\nprivate (HashSet<(int x, int y)> positions, bool enclosed) FindGroundStatus(Dictionary<(int x, int y), List<(int x, int y)>> pipes, HashSet<(int x, int y)> loop, (int x, int y) position)\n{\n    HashSet<(int x, int y)> positions = [];\n    Queue<(int x, int y)> toExplore = [];\n    toExplore.Enqueue(position);\n    positions.Add(position);\n    bool enclosed = true;\n    bool haveSeenLoop = false;\n\n    while (toExplore.Count > 0)\n    {\n        var current = toExplore.Dequeue();\n\n        if (!pipes.ContainsKey(current))\n        {\n            enclosed = false;\n            continue;\n        }\n\n        if (loop.Contains(current))\n            haveSeenLoop = true;\n\n        if (current.x == Input[0].Length - 1 || current.y == Input.Length - 1)\n            enclosed = false;\n\n        foreach (var next in FindNextAccessibleTiles(pipes, current))\n        {\n            if (!positions.Contains(next))\n            {\n                toExplore.Enqueue(next);\n                positions.Add(next);\n            }\n        }\n    }\n\n    return (positions, haveSeenLoop && enclosed);\n}\n\nprivate static List<(int x, int y)> FindNextAccessibleTiles(Dictionary<(int x, int y), List<(int x, int y)>> pipes, (int x, int y) position)\n{\n    var (x, y) = position;\n    List<(int x, int y)> next = [];\n\n    if (pipes.TryGetValue((x, y), out var neighbours))\n    {\n        if (!neighbours.Contains((x + 1, y)))\n            next.Add((x, y - 1));\n\n        if (!neighbours.Contains((x, y + 1)))\n            next.Add((x - 1, y));\n    }\n\n    if (pipes.TryGetValue((x, y + 1), out neighbours))\n        if (!neighbours.Contains((x + 1, y + 1)))\n            next.Add((x, y + 1));\n\n    if (pipes.TryGetValue((x + 1, y), out neighbours))\n        if (!neighbours.Contains((x + 1, y + 1)))\n            next.Add((x + 1, y));\n\n    return next;\n}\n"))))}var s=function(n){void 0===n&&(n={});const{wrapper:e}=Object.assign({},(0,o.RP)(),n.components);return e?r.createElement(e,n,r.createElement(i,n)):i(n)};var a=t(2779),c=t(7206),u=t(791),l=t(4813),p=t(572);const d={CodeBox:a.A};function y(n){let{pageContext:e,children:t}=n;return r.createElement(r.Fragment,null,r.createElement(l.A,null),r.createElement("div",{className:"min-h-screen bg-chicPrimary"},r.createElement(u.A,{props:e.list}),r.createElement("div",{className:"adventofcode max-w-[60%] ml-[20%]"},r.createElement("h1",null,r.createElement("a",{href:"https://adventofcode.com/"+e.year+"/day/"+e.puzz},e.year+" Day "+e.puzz+" - "+e.title)),r.createElement(o.xA,{components:d},t),e.puzz&&e.year?r.createElement(c.A,{year:e.year,puzz:e.puzz}):r.createElement(r.Fragment,null))),r.createElement(p.A,null))}function x(n){return r.createElement(y,n,r.createElement(s,n))}const h=()=>r.createElement(r.Fragment,null,r.createElement("title",null,"Joel-Allan-NZ - Advent of Code"),r.createElement("html",{lang:"en"}),r.createElement("link",{rel:"preconnect",href:"https://fonts.googleapis.com"}),r.createElement("link",{rel:"preconnect",href:"https://fonts.gstatic.com"}),r.createElement("link",{href:"https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&family=VT323&display=swap",rel:"stylesheet"}))}}]);
//# sourceMappingURL=component---src-components-layout-tsx-content-file-path-days-2023-10-mdx-a05c1cc51db592a604b8.js.map