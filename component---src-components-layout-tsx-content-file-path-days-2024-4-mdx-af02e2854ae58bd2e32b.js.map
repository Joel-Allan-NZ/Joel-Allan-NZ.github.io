{"version":3,"file":"component---src-components-layout-tsx-content-file-path-days-2024-4-mdx-af02e2854ae58bd2e32b.js","mappings":"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","sources":["webpack://joel-allan-nz.github.io/./days/2024/4.mdx","webpack://joel-allan-nz.github.io/./src/components/Layout.tsx"],"sourcesContent":["/*@jsxRuntime classic @jsx React.createElement @jsxFrag React.Fragment*/\nimport {useMDXComponents as _provideComponents} from \"@mdx-js/react\";\nimport React from \"react\";\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    p: \"p\",\n    em: \"em\",\n    code: \"code\",\n    pre: \"pre\",\n    ul: \"ul\",\n    li: \"li\"\n  }, _provideComponents(), props.components), {CodeBox} = _components;\n  if (!CodeBox) _missingMdxReference(\"CodeBox\", true);\n  return React.createElement(React.Fragment, null, React.createElement(_components.h2, null, \"Part One\"), \"\\n\", React.createElement(_components.p, null, \"Another day revolving around text searching! Luckily it's a wordsearch rather than just more piles of regex.\"), \"\\n\", React.createElement(\"br\"), \"\\n\", React.createElement(_components.p, null, \"I opted not to try to get too clever with this one, instead using basic regexp and\\na single diagonal search (left-to-right, top-to-bottom) to count half of the possible\\n\", React.createElement(_components.em, null, \"XMAS\"), \"/\", React.createElement(_components.em, null, \"SMAX\"), \" matches, then repeating that process on a version of the input that\\nhad been rotated 90 degrees clockwise.\"), \"\\n\", React.createElement(\"br\"), \"\\n\", React.createElement(_components.p, null, \"The C# version uses a slightly different regexp with a positive lookahead to smoosh\\nthe search for \", React.createElement(_components.em, null, \"XMAS/SMAX\"), \" into a single expression, but I opted to keep it as two\\nseperate searches in typescript, favouring the simpler readability.\"), \"\\n\", React.createElement(\"br\"), \"\\n\", React.createElement(_components.p, null, \"I'm certainly not in love with the way prettier has arranged the parentheses within\\n\", React.createElement(_components.code, null, \"countDiagonal()\"), \", but hopefully it's still reasonably legible here.\"), \"\\n\", React.createElement(CodeBox, {\n    names: \"typescript|C#\"\n  }, React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-js\"\n  }, \"export function partOne(input: string[]): number | string {\\n  return [input, rotateStringArray(input)].reduce((total, current) => {\\n    const straight = current.reduce(\\n      (t, c) =>\\n        t + (c.match(/XMAS/g)?.length ?? 0) + (c.match(/SAMX/g)?.length ?? 0),\\n      0\\n    )\\n    return total + straight + countDiagonal(current)\\n  }, 0)\\n}\\n\\nfunction rotateStringArray(input: string[]): string[] {\\n  const rotated: string[] = []\\n  for (let i = 0; i < input[0].length; i++) {\\n    rotated.push(\\n      input\\n        .map((current) => current[i])\\n        .reverse()\\n        .join('')\\n    )\\n  }\\n  return rotated\\n}\\n\\nfunction countDiagonal(input: string[]): number {\\n  return input.reduce((total, current, y) => {\\n    return (\\n      total +\\n      current\\n        .split('')\\n        .reduce(\\n          (t, c, x) =>\\n            IsMatchStartPoint(input, x, y, [0, 1, 2, 3]) ? t + 1 : t,\\n          0\\n        )\\n    )\\n  }, 0)\\n}\\n\")), React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-csharp\"\n  }, \"public override object PartOne()\\n{\\n  var rotated = Enumerable.Range(1, Input[0].Length)\\n                          .Select(i => new string(Input.Select(x => x[^i]).ToArray()))\\n                          .ToArray();\\n\\n  List<string[]> searchSpaces = [Input, rotated];\\n  return searchSpaces.Sum(s => countMatches(s));\\n\\n  static int countMatches(string[] s)\\n  {\\n      var straightLine = s.Sum(line => XmasRegex().Matches(line).Count);\\n      return straightLine + LeftToRightDownDiagonal(s);\\n  }\\n}\\n\\nprivate static int LeftToRightDownDiagonal(string[] input)\\n{\\n  int[] range = [0, 1, 2, 3];\\n  var xmas = \\\"XMAS\\\";\\n  int count = 0;\\n\\n  for (int y = 0; y < input.Length - 3; y++)\\n  {\\n      for (int x = 0; x < input[y].Length - 3; x++)\\n          if (IsMatchStartPoint(x, y))\\n              count++;\\n  }\\n  return count;\\n\\n  bool IsMatchStartPoint(int x, int y)\\n  {\\n      return range.All(offset => input[y + offset][x + offset] == xmas[offset]) ||\\n          range.All(offset => input[y + offset][x + offset] == xmas[^(offset + 1)]);\\n  }\\n}\\n\\n[GeneratedRegex(@\\\"(?=(XMAS|SAMX))\\\")]\\ninternal static partial Regex XmasRegex();\\n\"))), \"\\n\", React.createElement(_components.h2, null, \"Part Two\"), \"\\n\", React.createElement(_components.p, null, \"A rarity where the second part is less fiddly than the first!\"), \"\\n\", React.createElement(_components.p, null, React.createElement(\"br\"), \"I approached the problem by acknowledging that a valid MAS X must have:\"), \"\\n\", React.createElement(_components.ul, null, \"\\n\", React.createElement(_components.li, null, \"A central 'A'\"), \"\\n\", React.createElement(_components.li, null, \"Two 'M's, and two 'S's in the corners (ie on diagonals to the central 'A')\"), \"\\n\", React.createElement(_components.li, null, \"The 'M' and 'S' must be on opposite sides of the central 'A'; 'MAM' or 'SAS' are no good. If our other conditions are already true, we only need to check one 'SAM'/'MAS'\"), \"\\n\"), \"\\n\", React.createElement(\"br\"), \"\\n\", React.createElement(_components.p, null, \"From there it's simply a matter of checking 'A' values in valid locations, and confirming\\nthey have the correct corners around them.\"), \"\\n\", React.createElement(\"br\"), \"\\n\", React.createElement(_components.p, null, \"Once again prettier is not terribly helpful at making nested \", React.createElement(_components.code, null, \"Array.prototype.reduce()\"), \"\\nlegible outside of the editor itself, but hopefully this is readable enough!\"), \"\\n\", React.createElement(CodeBox, {\n    names: \"typescript|C#\"\n  }, React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-js\"\n  }, \"export function partTwo(input: string[]): number | string {\\n  return input.reduce((total, current, y) => {\\n    return (\\n      total +\\n      current\\n        .split('')\\n        .reduce(\\n          (t, c, x) =>\\n            input[y][x] == 'A' && isACross(input, y, x) ? t + 1 : t,\\n          0\\n        )\\n    )\\n  }, 0)\\n}\\n\\nfunction isACross(input: string[], y: number, x: number): boolean {\\n  if (x == 0 || y == 0 || y > input.length - 2 || x > input[y].length - 2)\\n    return false\\n\\n  const corners = [\\n    input[y - 1][x - 1],\\n    input[y + 1][x - 1],\\n    input[y - 1][x + 1],\\n    input[y + 1][x + 1],\\n  ]\\n  const count = { M: 0, S: 0, X: 0, A: 0 }\\n  corners.forEach((x) => count[x as keyof typeof count]++)\\n\\n  return count.M == 2 && count.S == 2 && corners[0] != corners[3]\\n}\\n\")), React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-csharp\"\n  }, \"public override object PartTwo()\\n{\\n  int count = 0;\\n  for (int y = 1; y < Input.Length - 1; y++)\\n  {\\n      for (int x = 1; x < Input[y].Length - 1; x++)\\n      {\\n          if (Input[y][x] == 'A' && IsACross(y, x))\\n              count++;\\n      }\\n  }\\n  return count;\\n}\\nprivate bool IsACross(int x, int y)\\n{\\n  List<char> corners =\\n  [\\n      Input[x - 1][y - 1],\\n      Input[x + 1][y - 1],\\n      Input[x - 1][y + 1],\\n      Input[x + 1][y + 1]\\n  ];\\n  return corners[0] != corners[3]\\n      && corners.Count(x => x == 'M') == 2\\n      && corners.Count(x => x == 'S') == 2;\\n}\\n\"))));\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? React.createElement(MDXLayout, props, React.createElement(_createMdxContent, props)) : _createMdxContent(props);\n}\nexport default MDXContent;\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","import GATSBY_COMPILED_MDX from \"/home/joel/personal/advent-of-code/joel-allan-nz.github.io/days/2024/4.mdx\";\nimport React from 'react';\nimport {MDXProvider} from '@mdx-js/react';\nimport CodeBox from './CodeBox';\nimport TryYourself from './TryYourself';\nimport AdventSideNav from './AdventSideNav';\nimport Header from './Header';\nimport Footer from './Footer';\nconst shortcodes = {\n  CodeBox\n};\nfunction Layout(_ref) {\n  let {pageContext, children} = _ref;\n  return React.createElement(React.Fragment, null, React.createElement(Header, null), React.createElement(\"div\", {\n    className: \"min-h-screen bg-chicPrimary\"\n  }, React.createElement(AdventSideNav, {\n    props: pageContext.list\n  }), React.createElement(\"div\", {\n    className: \"adventofcode max-w-[60%] ml-[20%]\"\n  }, React.createElement(\"h1\", null, React.createElement(\"a\", {\n    href: \"https://adventofcode.com/\" + pageContext.year + \"/day/\" + pageContext.puzz\n  }, pageContext.year + \" Day \" + pageContext.puzz + \" - \" + pageContext.title)), React.createElement(MDXProvider, {\n    components: shortcodes\n  }, children), pageContext.puzz && pageContext.year ? React.createElement(TryYourself, {\n    year: pageContext.year,\n    puzz: pageContext.puzz\n  }) : React.createElement(React.Fragment, null))), React.createElement(Footer, null));\n}\nexport default function GatsbyMDXWrapper(props) {\n  return React.createElement(Layout, props, React.createElement(GATSBY_COMPILED_MDX, props));\n}\nexport const Head = () => React.createElement(React.Fragment, null, React.createElement(\"title\", null, \"Joel-Allan-NZ - Advent of Code\"), React.createElement(\"html\", {\n  lang: \"en\"\n}), React.createElement(\"link\", {\n  rel: \"preconnect\",\n  href: \"https://fonts.googleapis.com\"\n}), React.createElement(\"link\", {\n  rel: \"preconnect\",\n  href: \"https://fonts.gstatic.com\"\n}), React.createElement(\"link\", {\n  href: \"https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&family=VT323&display=swap\",\n  rel: \"stylesheet\"\n}));\n"],"names":["_createMdxContent","props","_components","Object","assign","h2","p","em","code","pre","ul","li","_provideComponents","components","CodeBox","id","component","Error","_missingMdxReference","React","names","className","wrapper","MDXLayout","shortcodes","Layout","_ref","pageContext","children","Header","AdventSideNav","list","href","year","puzz","title","MDXProvider","TryYourself","Footer","GatsbyMDXWrapper","GATSBY_COMPILED_MDX","Head","lang","rel"],"sourceRoot":""}