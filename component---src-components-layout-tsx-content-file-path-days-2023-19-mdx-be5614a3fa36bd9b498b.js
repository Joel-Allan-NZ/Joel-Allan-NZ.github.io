"use strict";(self.webpackChunkjoel_allan_nz_github_io=self.webpackChunkjoel_allan_nz_github_io||[]).push([[8579],{2733:function(n,e,t){t.r(e),t.d(e,{Head:function(){return f},default:function(){return h}});var r=t(8453),a=t(6540);function l(n){const e=Object.assign({h2:"h2",p:"p",pre:"pre",code:"code"},(0,r.RP)(),n.components),{CodeBox:t}=e;return t||function(n,e){throw new Error("Expected "+(e?"component":"object")+" `"+n+"` to be defined: you likely forgot to import, pass, or provide it.")}("CodeBox",!0),a.createElement(a.Fragment,null,a.createElement(e.h2,null,"Part One"),"\n",a.createElement(e.p,null,"Pick your poison on how to parse the workflows and check their conditions. No real trick or classic algorithm here, just modelling a system."),"\n",a.createElement(t,{names:"typescript|C#"},a.createElement(e.pre,null,a.createElement(e.code,{className:"language-ts"},"export function partOne(input: string[]): number | string {\n  const { flows, parts } = parse(input)\n  const accepted: number[][] = []\n\n  parts.forEach((part) => {\n    let result = 'in'\n    while (true) {\n      result = flows.get(result)!.find((x) => x.application(part))!.next\n      if (result == 'R') break\n      if (result == 'A') {\n        accepted.push(part)\n        break\n      }\n    }\n  })\n  return accepted.reduce(\n    (total, part) => total + part[0] + part[1] + part[2] + part[3],\n    0\n  )\n}\n\nclass Rule {\n  next: string\n  equality: string\n  target: number\n  xmas: number\n  application: (part: number[]) => boolean\n\n  constructor(rule: string) {\n    const split = rule.split(':')\n    this.next = split.length > 1 ? split[1] : split[0]\n    this.xmas = this.xmasToNumber(rule[0])\n    this.target = split.length == 1 ? -1 : parseInt(split[0].slice(2))\n    this.equality = rule.length > 1 ? rule[1] : rule[0]\n\n    if (this.target == -1) this.application = (r) => true\n    else\n      this.application =\n        this.equality == '<'\n          ? (r) => r[this.xmas] < this.target\n          : (r) => r[this.xmas] > this.target\n  }\n\n  xmasToNumber(xmas: string) {\n    switch (xmas) {\n      case 'x':\n        return 0\n      case 'm':\n        return 1\n      case 'a':\n        return 2\n      default:\n        return 3\n    }\n  }\n}\n\nfunction parse(input: string[]): {\n  flows: Map<string, Rule[]>\n  parts: number[][]\n} {\n  const flows = new Map<string, Rule[]>()\n  const parts: number[][] = []\n  let readingWorkFlows = true\n\n  input.forEach((line) => {\n    if (!line || line.length == 0) {\n      readingWorkFlows = false\n    } else {\n      const split = line.slice(0, -1).split(/[\\{\\,]/g)\n      if (readingWorkFlows)\n        flows.set(\n          split[0],\n          split.slice(1).map((x) => new Rule(x))\n        )\n      else parts.push(split.slice(1, 5).map((i) => parseInt(i.slice(2))))\n    }\n  })\n  return { flows, parts }\n}\n")),a.createElement(e.pre,null,a.createElement(e.code,{className:"language-csharp"},"public override object PartOne()\n{\n    var (flows, parts) = Parse(Input);\n    List<Part> accepted = [];\n    foreach (var part in parts)\n    {\n        var result = \"in\";\n        while (true)\n        {\n            result = flows[result].First(x => x.Application(part))!.Next;\n            if (result == \"R\")\n                break;\n            if (result == \"A\")\n            {\n                accepted.Add(part);\n                break;\n            }\n        }\n    }\n    return accepted.Sum(acc => acc.X + acc.M + acc.A + acc.S);\n}\n\nprivate static (Dictionary<string, Rule[]> flows, List<Part> parts) Parse(string[] input)\n{\n    Dictionary<string, Rule[]> flows = [];\n    List<Part> parts = [];\n\n    bool readingWorkFlows = true;\n    foreach (var line in input)\n    {\n        if (string.IsNullOrEmpty(line))\n        {\n            readingWorkFlows = false;\n            continue;\n        }\n        var split = line.Split(['{', '}', ','], StringSplitOptions.RemoveEmptyEntries);\n\n        if (readingWorkFlows)\n            flows.Add(split[0], split[1..].Select(x => new Rule(x)).ToArray());\n        else\n            parts.Add(new(int.Parse(split[0][2..]), int.Parse(split[1][2..]), int.Parse(split[2][2..]), int.Parse(split[3][2..])));\n    }\n    return (flows, parts);\n}\n\ninternal class Rule\n{\n    internal char Equality;\n    internal Func<Part, bool> Application;\n    internal string Next;\n    internal int Target;\n    internal char XMAS;\n\n    public Rule(string rule)\n    {\n        var split = rule.Split(':');\n        Next = split.Length > 1 ? split[1] : split[0];\n        XMAS = rule[0];\n        Target = split.Length == 1 ? -1 : int.Parse(split[0][2..]);\n        Equality = rule.Length > 1 ? rule[1] : rule[0];\n        Application = ParseRule();\n    }\n\n\n    internal Func<Part, bool> ParseRule()\n    {\n        if (Target == -1)\n            return (r => true);\n        else if (Equality == '<')\n            return (r => r.GetXMASValue(XMAS) < Target);\n        else\n            return (r => r.GetXMASValue(XMAS) > Target);\n    }\n}\n\ninternal class Part(int x, int m, int a, int s)\n{\n    internal int X = x;\n    internal int M = m;\n    internal int A = a;\n    internal int S = s;\n\n    internal int GetXMASValue(char s) => s switch\n    {\n        'x' => X,\n        'm' => M,\n        'a' => A,\n        _ => S\n    };\n}\n"))),"\n",a.createElement(e.h2,null,"Part Two"),"\n",a.createElement(e.p,null,"Instead of modelling the system for the parts list, you now have to find all valid parts. Rather than trying to enumerate the possible part values (4000^4 is big!), I opted to treat it as ranges of valid values. When a range encounters a rule that wouldn't pass for the entire range, the range is split into 2 ranges. Again, nothing complex, just execution."),"\n",a.createElement(t,{names:"typescript|C#"},a.createElement(e.pre,null,a.createElement(e.code,{className:"language-ts"},"export function partTwo(input: string[]): number | string {\n  const { flows, parts } = parse(input)\n  const queue: { ranges: number[][][]; rules: Rule[] }[] = [\n    {\n      ranges: [\n        [\n          [1, 4000],\n          [1, 4000],\n          [1, 4000],\n          [1, 4000],\n        ],\n      ],\n      rules: flows.get('in')!,\n    },\n  ]\n  let valid: number[][][] = []\n\n  while (queue.length > 0) {\n    const { ranges, rules } = queue.shift()!\n    const result = applyRulesToRange(rules, ranges)\n    result.entries().forEach((kvp) => {\n      if (kvp[0] != 'R') {\n        if (kvp[0] == 'A') valid = [...valid, ...kvp[1]]\n        else queue.push({ ranges: kvp[1], rules: flows.get(kvp[0])! })\n      }\n    })\n  }\n\n  return valid.reduce(\n    (total, range) => total + range.reduce((t, r) => t * (r[1] - r[0] + 1), 1),\n    0\n  )\n}\n\nfunction split(\n  current: number[][],\n  xmas: number,\n  min: number,\n  max: number\n): number[][] {\n  const other: number[][] = [\n    [...current[0]],\n    [...current[1]],\n    [...current[2]],\n    [...current[3]],\n  ]\n  other[xmas][1] = Math.min(max, current[xmas][1])\n  other[xmas][0] = Math.max(min, current[xmas][0])\n\n  if (other[xmas][0] > current[xmas][0] && other[xmas][0] < current[xmas][1])\n    current[xmas][1] = other[xmas][0] - 1\n  else if (\n    current[xmas][1] > other[xmas][1] &&\n    other[xmas][1] > current[xmas][0]\n  )\n    current[xmas][0] = other[xmas][1] + 1\n  else {\n    current[xmas][0] = -1\n    current[xmas][1] = -1\n  }\n  return other\n}\n\nfunction applyRulesToRange(\n  rules: Rule[],\n  parts: number[][][]\n): Map<string, number[][][]> {\n  const continuing = new Map<string, number[][][]>()\n\n  for (let part of parts) {\n    for (let rule of rules) {\n      if (!continuing.has(rule.next)) continuing.set(rule.next, [])\n      if (rule.target == -1) {\n        continuing.get(rule.next)!.push(part)\n        break\n      }\n      let range = part[rule.xmas]\n\n      if (range[0] <= rule.target && range[1] >= rule.target) {\n        if (rule.equality == '>')\n          continuing\n            .get(rule.next)!\n            .push(split(part, rule.xmas, rule.target + 1, Infinity))\n        else\n          continuing\n            .get(rule.next)!\n            .push(split(part, rule.xmas, -1, rule.target - 1))\n      }\n    }\n  }\n\n  return continuing\n}\n")),a.createElement(e.pre,null,a.createElement(e.code,{className:"language-csharp"},"public override object PartTwo()\n{\n    var (flows, parts) = Parse(Input);\n    Queue<(List<PartRange> ranges, Rule[] flow)> toProcess = [];\n    PartRange maxRange = new([1, 4000], [1, 4000], [1, 4000], [1, 4000]);\n    toProcess.Enqueue(([maxRange], flows[\"in\"]));\n    List<PartRange> valid = [];\n\n    while (toProcess.Count > 0)\n    {\n        var (ranges, flow) = toProcess.Dequeue();\n        var result = ApplyWorkFlowRange(flow, ranges);\n        foreach (var kvp in result)\n        {\n            if (kvp.Key == \"R\")\n                continue;\n            if (kvp.Key == \"A\")\n            {\n                valid.AddRange(kvp.Value);\n                continue;\n            }\n            toProcess.Enqueue((kvp.Value, flows[kvp.Key]));\n        }\n    }\n\n    return valid.Sum(v => (long)(v.X[1] - v.X[0] + 1) * (v.A[1] - v.A[0] + 1) * (v.M[1] - v.M[0] + 1) * (v.S[1] - v.S[0] + 1));\n\n}\n\ninternal class PartRange(int[] x, int[] m, int[] a, int[] s)\n{\n    internal int[] X = x;\n    internal int[] M = m;\n    internal int[] A = a;\n    internal int[] S = s;\n\n    internal int[] GetXMAS(char xmas) => xmas switch\n    {\n        'x' => X,\n        'm' => M,\n        'a' => A,\n        _ => S,\n    };\n\n    internal PartRange Split(char xmas, int min, int max)\n    {\n        var range = GetXMAS(xmas);\n        PartRange other = new([X[0], X[1]], [M[0], M[1]], [A[0], A[1]], [S[0], S[1]]);\n        var otherRange = other.GetXMAS(xmas);\n\n        otherRange[1] = Math.Min(max, range[1]);\n        otherRange[0] = Math.Max(min, range[0]);\n\n        if (otherRange[0] > range[0] && otherRange[0] < range[1])\n            range[1] = otherRange[0] - 1;\n        else if (range[1] > otherRange[1] && otherRange[1] > range[0])\n            range[0] = otherRange[1] + 1;\n        else\n        {\n            range[0] = -1;\n            range[1] = -1;\n        }\n        return other;\n    }\n}\n\nprivate static Dictionary<string, List<PartRange>> ApplyWorkFlowRange(Rule[] rules, List<PartRange> parts)\n{\n    Dictionary<string, List<PartRange>> continuing = [];\n\n    foreach (var part in parts)\n    {\n        foreach (var rule in rules)\n        {\n            if (!continuing.ContainsKey(rule.Next))\n                continuing[rule.Next] = [];\n            if (rule.Target == -1)\n            {\n                continuing[rule.Next].Add(part);\n                break;\n            }\n            var range = part.GetXMAS(rule.XMAS);\n\n            if (range[0] <= rule.Target && range[1] >= rule.Target)\n            {\n                if (rule.Equality == '>')\n                    continuing[rule.Next].Add(part.Split(rule.XMAS, rule.Target + 1, int.MaxValue));\n                else\n                    continuing[rule.Next].Add(part.Split(rule.XMAS, -1, rule.Target - 1));\n            }\n        }\n    }\n    return continuing;\n}\n"))))}var i=function(n){void 0===n&&(n={});const{wrapper:e}=Object.assign({},(0,r.RP)(),n.components);return e?a.createElement(e,n,a.createElement(l,n)):l(n)};var s=t(2779),u=t(7206),o=t(791),c=t(4813),p=t(572);const g={CodeBox:s.A};function m(n){let{pageContext:e,children:t}=n;return a.createElement(a.Fragment,null,a.createElement(c.A,null),a.createElement("div",{className:"min-h-screen bg-chicPrimary"},a.createElement(o.A,{props:e.list}),a.createElement("div",{className:"adventofcode max-w-[60%] ml-[20%]"},a.createElement("h1",null,a.createElement("a",{href:"https://adventofcode.com/"+e.year+"/day/"+e.puzz},e.year+" Day "+e.puzz+" - "+e.title)),a.createElement(r.xA,{components:g},t),e.puzz&&e.year?a.createElement(u.A,{year:e.year,puzz:e.puzz}):a.createElement(a.Fragment,null))),a.createElement(p.A,null))}function h(n){return a.createElement(m,n,a.createElement(i,n))}const f=()=>a.createElement(a.Fragment,null,a.createElement("title",null,"Joel-Allan-NZ - Advent of Code"),a.createElement("html",{lang:"en"}),a.createElement("link",{rel:"preconnect",href:"https://fonts.googleapis.com"}),a.createElement("link",{rel:"preconnect",href:"https://fonts.gstatic.com"}),a.createElement("link",{href:"https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&family=VT323&display=swap",rel:"stylesheet"}))}}]);
//# sourceMappingURL=component---src-components-layout-tsx-content-file-path-days-2023-19-mdx-be5614a3fa36bd9b498b.js.map