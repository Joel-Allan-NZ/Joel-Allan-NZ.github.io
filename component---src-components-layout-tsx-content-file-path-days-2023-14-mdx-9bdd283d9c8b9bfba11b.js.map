{"version":3,"file":"component---src-components-layout-tsx-content-file-path-days-2023-14-mdx-9bdd283d9c8b9bfba11b.js","mappings":"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","sources":["webpack://joel-allan-nz.github.io/./days/2023/14.mdx","webpack://joel-allan-nz.github.io/./src/components/Layout.tsx"],"sourcesContent":["/*@jsxRuntime classic @jsx React.createElement @jsxFrag React.Fragment*/\nimport {useMDXComponents as _provideComponents} from \"@mdx-js/react\";\nimport React from \"react\";\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    p: \"p\",\n    pre: \"pre\",\n    code: \"code\"\n  }, _provideComponents(), props.components), {CodeBox} = _components;\n  if (!CodeBox) _missingMdxReference(\"CodeBox\", true);\n  return React.createElement(React.Fragment, null, React.createElement(_components.h2, null, \"Part One\"), \"\\n\", React.createElement(_components.p, null, \"Nice and easy; purely reading the input and proving we can generate a value from it. Usually I refactor the first part when it could share code with part two, but with no need to actually manipulate the input here I opted not to.\"), \"\\n\", React.createElement(CodeBox, {\n    names: \"typescript|C#\"\n  }, React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-ts\"\n  }, \"export function partOne(input: string[]): number | string {\\n  let total = 0\\n  for (let x = 0; x < input[0].length; x++) {\\n    let end = 0\\n    for (let y = 0; y < input.length; y++) {\\n      if (input[y][x] == 'O') {\\n        total += input.length - end\\n        end++\\n      } else if (input[y][x] == '#') end = y + 1\\n    }\\n  }\\n  return total\\n}\\n\")), React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-csharp\"\n  }, \"public override object PartOne()\\n{\\n    int total = 0;\\n    for (int x = 0; x < Input[0].Length; x++)\\n    {\\n        int end = 0;\\n        for (int y = 0; y < Input.Length; y++)\\n        {\\n            if (Input[y][x] == 'O')\\n            {\\n                total += Input.Length - end;\\n                end++;\\n            }\\n            else if (Input[y][x] == '#')\\n            {\\n                end = y + 1;\\n            }\\n        }\\n    }\\n    return total;\\n}\\n\"))), \"\\n\", React.createElement(_components.h2, null, \"Part Two\"), \"\\n\", React.createElement(_components.p, null, \"Phew, 1 billion spins is a lot.\"), \"\\n\", React.createElement(\"br\"), \"\\n\", React.createElement(_components.p, null, \"But, such a large number of repetitions is a big hint that we're looking for a cycle. Unsurprisingly there are repeated positions quite early in to the billion spins. Once that cycle is discovered we can trivially determine the position after the billionth spin and calculate the load on the north support beams.\"), \"\\n\", React.createElement(CodeBox, {\n    names: \"typescript|C#\"\n  }, React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-ts\"\n  }, \"export function partTwo(input: string[]): number | string {\\n  const seen = new Map<string, number>()\\n  let stones: string[][] = []\\n  let cycles = 0\\n  input.forEach((y) => stones.push(y.split('')))\\n  const targetCycles = 1000000000\\n  while (cycles < targetCycles) {\\n    const stoneString = stones\\n      .reduce((a, b) => a + ';' + b.join(''), '')\\n      .slice(1)\\n    const last = seen.get(stoneString)\\n    seen.set(stoneString, cycles)\\n\\n    if (last) {\\n      const index = ((targetCycles - last) % (cycles - last)) + last\\n      stones = seen\\n        .entries()\\n        .find((x) => x[1] == index)![0]!\\n        .split(';')\\n        .map((x) => x.split(''))\\n\\n      break\\n    }\\n    vertical(stones, 1)\\n    horizontal(stones, 1)\\n    vertical(stones, -1)\\n    horizontal(stones, -1)\\n    cycles++\\n  }\\n\\n  let total = 0\\n  for (let x = 0; x < stones[0].length; x++)\\n    for (let y = 0; y < stones.length; y++)\\n      if (stones[y][x] == 'O') total += stones.length - y\\n\\n  return total\\n}\\n\\nfunction vertical(stones: string[][], direction: number): void {\\n  for (let x = 0; x < stones[0].length; x++) {\\n    let end = direction == -1 ? stones.length - 1 : 0\\n    let rowEnd = direction == -1 ? -1 : stones.length\\n\\n    for (let y = end; y != rowEnd; y += direction) {\\n      if (stones[y][x] == 'O') {\\n        if (end != y) {\\n          stones[end][x] = 'O'\\n          stones[y][x] = '.'\\n        }\\n        end += direction\\n      } else if (stones[y][x] == '#') end = y + direction\\n    }\\n  }\\n}\\n\\nfunction horizontal(stones: string[][], direction: number): void {\\n  for (let y = 0; y < stones.length; y++) {\\n    let end = direction == -1 ? stones.length - 1 : 0\\n    let rowEnd = direction == -1 ? -1 : stones.length\\n\\n    for (let x = end; x != rowEnd; x += direction) {\\n      if (stones[y][x] == 'O') {\\n        if (end != x) {\\n          stones[y][end] = 'O'\\n          stones[y][x] = '.'\\n        }\\n        end += direction\\n      } else if (stones[y][x] == '#') end = x + direction\\n    }\\n  }\\n}\\n\")), React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-csharp\"\n  }, \"public override object PartTwo()\\n{\\n    Dictionary<string, int> seen = [];\\n    char[][] stones = new char[Input.Length][];\\n    int cycles = 0;\\n\\n    for (int y = 0; y < Input.Length; y++)\\n        stones[y] = Input[y].ToCharArray();\\n\\n    while (cycles < 1_000_000_000)\\n    {\\n        var stoneString = stones.Aggregate(\\\"\\\", (x, y) => x + \\\";\\\" + new string(y))[1..];\\n        if (seen.TryGetValue(stoneString, out var val))\\n        {\\n            var index = (1_000_000_000 - val) % (cycles - val) + val;\\n            stones = seen.First(x => x.Value == index).Key\\n                         .Split(';')\\n                         .Select(x => x.ToCharArray())\\n                         .ToArray();\\n            break;\\n        }\\n        else\\n            seen.Add(stoneString, cycles);\\n\\n        Vertical(stones, 1);\\n        Horizontal(stones, 1);\\n        Vertical(stones, -1);\\n        Horizontal(stones, -1);\\n        cycles++;\\n    }\\n\\n    int total = 0;\\n\\n    for (int x = 0; x < stones[0].Length; x++)\\n    {\\n        for (int y = 0; y < stones.Length; y++)\\n        {\\n            if (stones[y][x] == 'O')\\n                total += stones.Length - y;\\n        }\\n\\n    }\\n    return total;\\n}\\n\\nprivate static void Vertical(char[][] stones, int direction)\\n{\\n    for (int x = 0; x < stones[0].Length; x++)\\n    {\\n        int end = direction == -1 ? stones.Length - 1 : 0;\\n        int RowEnd = direction == -1 ? -1 : stones.Length;\\n\\n        for (int y = end; y != RowEnd; y += direction)\\n        {\\n            if (stones[y][x] == 'O')\\n            {\\n                if (end != y)\\n                {\\n                    stones[end][x] = 'O';\\n                    stones[y][x] = '.';\\n                }\\n                end += direction;\\n\\n            }\\n            else if (stones[y][x] == '#')\\n                end = y + direction;\\n        }\\n    }\\n}\\n\\nprivate static void Horizontal(char[][] stones, int direction)\\n{\\n    for (int y = 0; y < stones.Length; y++)\\n    {\\n        int end = direction == -1 ? stones[y].Length - 1 : 0;\\n        int RowEnd = direction == -1 ? -1 : stones[y].Length;\\n\\n        for (int x = end; x != RowEnd; x += direction)\\n        {\\n            if (stones[y][x] == 'O')\\n            {\\n                if (end != x)\\n                {\\n                    stones[y][end] = 'O';\\n                    stones[y][x] = '.';\\n                }\\n                end += direction;\\n            }\\n            else if (stones[y][x] == '#')\\n                end = x + direction;\\n        }\\n    }\\n}\\n\"))));\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? React.createElement(MDXLayout, props, React.createElement(_createMdxContent, props)) : _createMdxContent(props);\n}\nexport default MDXContent;\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","import GATSBY_COMPILED_MDX from \"/home/joel/personal/advent-of-code/joel-allan-nz.github.io/days/2023/14.mdx\";\nimport React from 'react';\nimport {MDXProvider} from '@mdx-js/react';\nimport CodeBox from './CodeBox';\nimport TryYourself from './TryYourself';\nimport AdventSideNav from './AdventSideNav';\nimport Header from './Header';\nimport Footer from './Footer';\nconst shortcodes = {\n  CodeBox\n};\nfunction Layout(_ref) {\n  let {pageContext, children} = _ref;\n  return React.createElement(React.Fragment, null, React.createElement(Header, null), React.createElement(\"div\", {\n    className: \"min-h-screen bg-chicPrimary\"\n  }, React.createElement(AdventSideNav, {\n    props: pageContext.list\n  }), React.createElement(\"div\", {\n    className: \"adventofcode max-w-[60%] ml-[20%]\"\n  }, React.createElement(\"h1\", null, React.createElement(\"a\", {\n    href: \"https://adventofcode.com/\" + pageContext.year + \"/day/\" + pageContext.puzz\n  }, pageContext.year + \" Day \" + pageContext.puzz + \" - \" + pageContext.title)), React.createElement(MDXProvider, {\n    components: shortcodes\n  }, children), pageContext.puzz && pageContext.year ? React.createElement(TryYourself, {\n    year: pageContext.year,\n    puzz: pageContext.puzz\n  }) : React.createElement(React.Fragment, null))), React.createElement(Footer, null));\n}\nexport default function GatsbyMDXWrapper(props) {\n  return React.createElement(Layout, props, React.createElement(GATSBY_COMPILED_MDX, props));\n}\nexport const Head = () => React.createElement(React.Fragment, null, React.createElement(\"title\", null, \"Joel-Allan-NZ - Advent of Code\"), React.createElement(\"html\", {\n  lang: \"en\"\n}), React.createElement(\"link\", {\n  rel: \"preconnect\",\n  href: \"https://fonts.googleapis.com\"\n}), React.createElement(\"link\", {\n  rel: \"preconnect\",\n  href: \"https://fonts.gstatic.com\"\n}), React.createElement(\"link\", {\n  href: \"https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&family=VT323&display=swap\",\n  rel: \"stylesheet\"\n}));\n"],"names":["_createMdxContent","props","_components","Object","assign","h2","p","pre","code","_provideComponents","components","CodeBox","id","component","Error","_missingMdxReference","React","names","className","wrapper","MDXLayout","shortcodes","Layout","_ref","pageContext","children","Header","AdventSideNav","list","href","year","puzz","title","MDXProvider","TryYourself","Footer","GatsbyMDXWrapper","GATSBY_COMPILED_MDX","Head","lang","rel"],"sourceRoot":""}