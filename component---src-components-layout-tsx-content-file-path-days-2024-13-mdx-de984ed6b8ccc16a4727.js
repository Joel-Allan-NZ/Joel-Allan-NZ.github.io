"use strict";(self.webpackChunkjoel_allan_nz_github_io=self.webpackChunkjoel_allan_nz_github_io||[]).push([[6860],{7271:function(e,n,t){t.r(n),t.d(n,{Head:function(){return h},default:function(){return m}});var r=t(8453),o=t(6540);function i(e){const n=Object.assign({h2:"h2",p:"p",em:"em",pre:"pre",code:"code"},(0,r.RP)(),e.components),{CodeBox:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("CodeBox",!0),o.createElement(o.Fragment,null,o.createElement(n.h2,null,"Part One"),"\n",o.createElement(n.p,null,"Quick and dirty! The plan is simply to use cross multiplication to look for the intersections between the lines represented by the lines B and Prize, then see if there's an intercept for A and (Prize total - B)"),"\n",o.createElement("br"),"\n",o.createElement(n.p,null,"There is an edgecase this solution doesn't cover - the possibility of lines A + B\nbeing ",o.createElement(n.em,null,"the same line")," as prize. In that case you'd want need to optimize with B vs\n3A, and minimizing the cost of presses required. That shouldn't be terribly difficult\nto implement, but I'm betting Topaz has carefully curated the inputs such that it\ndoesn't come up."),"\n",o.createElement(t,{boxname:"one",names:"typescript|C#"},o.createElement(n.pre,null,o.createElement(n.code,{className:"language-js"},"export function partOne(input: string[]): number | string {\n  var regions = parse(input)\n  return regions\n    .values()\n    .reduce(\n      (total, current) =>\n        total +\n        current.length * current.reduce((t, c) => t + 4 - c.Edges.length, 0),\n      0\n    )\n}\n\ninterface Node {\n  X: number\n  Y: number\n  C: string\n  Region: number\n  Edges: Node[]\n}\n\nfunction parse(input: string[]): Map<number, Node[]> {\n  const nodes: Node[] = []\n  let lastRow: Node[] = []\n  input.forEach((line, y) => {\n    const currentRow: Node[] = []\n    line.split('').forEach((c, x) => {\n      currentRow.push({ X: x, Y: y, C: c, Region: 0, Edges: [] })\n      nodes.push(currentRow[x])\n      if (x > 0 && currentRow[x - 1].C == c) {\n        currentRow[x - 1].Edges.push(currentRow[x])\n        currentRow[x].Edges.push(currentRow[x - 1])\n      }\n      if (y > 0 && lastRow[x].C == c) {\n        currentRow[x].Edges.push(lastRow[x])\n        lastRow[x].Edges.push(currentRow[x])\n      }\n    })\n    lastRow = currentRow\n  })\n\n  let region = 1\n  nodes.forEach((node) => {\n    if (node.Region == 0) {\n      node.Region = region\n      region++\n      findRegion(node)\n    }\n  })\n  return Map.groupBy(nodes, (node) => node.Region)\n}\n\nfunction findRegion(node: Node) {\n  node.Edges.forEach((neighbour) => {\n    if (neighbour.Region == 0) {\n      neighbour.Region = node.Region\n      findRegion(neighbour)\n    }\n  })\n}\n")),o.createElement(n.pre,null,o.createElement(n.code,{className:"language-csharp"},"public override object PartOne()\n{\n    var regions = Parse();\n\n    return regions.Values.Sum(region => region.Count * region.Sum(FindTotalPerimeter()));\n\n    static Func<NodeData, int> FindTotalPerimeter() => y => 4 - y.Edges.Count;\n}\n\ninternal class NodeData(int x, int y, char c, int region)\n{\n    internal int X = x;\n    internal int Y = y;\n    internal char C = c;\n    internal int Region = region;\n    internal List<NodeData> Edges = [];\n}\n\nprivate Dictionary<int, List<NodeData>> Parse()\n{\n    Dictionary<(int x, int y), NodeData> graph = [];\n    for (int y = 0; y < Input.Length; y++)\n    {\n        for (int x = 0; x < Input.Length; x++)\n        {\n            NodeData n = new(x, y, Input[y][x], 0);\n            if (graph.TryGetValue((x - 1, y), out var left) && left.C == n.C)\n            {\n                left.Edges.Add(n);\n                n.Edges.Add(left);\n            }\n            if (graph.TryGetValue((x, y - 1), out var up) && up.C == n.C)\n            {\n                up.Edges.Add(n);\n                n.Edges.Add(up);\n            }\n            graph.Add((x, y), n);\n        }\n    }\n\n    int region = 1;\n    foreach (var node in graph.Values)\n    {\n        if (node.Region == 0)\n        {\n            node.Region = region;\n            region++;\n            FindRegion(node);\n        }\n    }\n    return graph.Values.GroupBy(x => x.Region).ToDictionary(key => key.Key, value => value.ToList());\n}\n\nprivate static void FindRegion(NodeData node)\n{\n    foreach (var neighbour in node.Edges)\n    {\n        if (neighbour.Region == 0)\n        {\n            neighbour.Region = node.Region;\n            FindRegion(neighbour);\n        }\n    }\n}\n"))),"\n",o.createElement(n.h2,null,"Part Two"),"\n",o.createElement(n.p,null,"The exaaaact same, but with much bigger Prize values."),"\n",o.createElement("br"),"\n",o.createElement(n.p,null,"If not for this much larger prize size you could simply simulate pressing A or B\nan arbitrary number of times (the puzzle itself suggests part 1 games shouldn't require\nmore than 100 button presses each). Cross multiplying to find the intercepts is still\na much more efficient approach!"),"\n",o.createElement("br"),"\n",o.createElement(t,{boxname:"two",names:"typescript|C#"},o.createElement(n.pre,null,o.createElement(n.code,{className:"language-js"},"export function partTwo(input: string[]): number | string {\n  var regions = parse(input)\n\n  return regions.values().reduce((total, region) => {\n    return (\n      total +\n      region.reduce((t, node) => t + region.length * countNodeVertices(node), 0)\n    )\n  }, 0)\n}\n\nfunction countNodeVertices(node: Node): number {\n  if (node.Edges.length == 0) return 4\n  if (node.Edges.length == 1) return 2\n\n  const edgeCombinations = node.Edges.slice(0, -1).flatMap((edge, index) => {\n    return node.Edges.slice(index + 1).map((e) => [edge, e])\n  })\n\n  let outsideCorner = true\n  const pairSum = edgeCombinations.reduce((total, pair) => {\n    if (\n      (pair[0].X == pair[1].X && pair[1].X == node.X) ||\n      (pair[0].Y == pair[1].Y && pair[1].Y == node.Y)\n    )\n      outsideCorner = false\n    else {\n      let insideCorner =\n        pair[0].Edges.filter((e) => pair[1].Edges.includes(e)).length == 1\n      if (insideCorner) return total + 1\n    }\n    return total\n  }, 0)\n  return outsideCorner ? pairSum + 1 : pairSum\n}\n")),o.createElement(n.pre,null,o.createElement(n.code,{className:"language-csharp"},"public override object PartTwo()\n{\n    var regions = Parse();\n\n    return regions.Values.Sum(region => FindRegionCost(region));\n\n    static int FindRegionCost(List<NodeData> region)\n    {\n        return region.Sum(node => CountNodeVertices(node)) * region.Count;\n    }\n}\n\nprivate static int CountNodeVertices(NodeData node)\n{\n    if (node.Edges.Count == 0)\n        return 4;\n\n    if (node.Edges.Count == 1)\n        return 2;\n\n    var pairCombinations = node.Edges.UniquePairs();\n    // if the node is within a straight section of nodes, then it can't be an outside corner.\n    bool outsideCorner = true;\n    var pairSum = pairCombinations.Sum(pair =>\n    {\n        if (IsStraightLine(node, pair))\n            outsideCorner = false;\n        else\n        {\n            bool insideCorner = pair[0].Edges.Intersect(pair[1].Edges).Count() == 1;\n            if (insideCorner)\n                return 1;\n        }\n        return 0;\n\n        static bool IsStraightLine(NodeData node, NodeData[] pair)\n        {\n            return (pair[0].X == pair[1].X && pair[0].X == node.X) ||\n            (pair[0].Y == pair[1].Y && pair[0].Y == node.Y);\n        }\n    });\n\n    return outsideCorner ? pairSum + 1 : pairSum;\n}\n"))))}var a=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,r.RP)(),e.components);return n?o.createElement(n,e,o.createElement(i,e)):i(e)};var s=t(2779),l=t(7206),u=t(791),c=t(4813),d=t(572);const g={CodeBox:s.A};function p(e){let{pageContext:n,children:t}=e;return o.createElement(o.Fragment,null,o.createElement(c.A,null),o.createElement("div",{className:"min-h-screen bg-chicPrimary"},o.createElement(u.A,{props:n.list}),o.createElement("div",{className:"adventofcode max-w-[60%] ml-[20%]"},o.createElement("h1",null,o.createElement("a",{href:"https://adventofcode.com/"+n.year+"/day/"+n.puzz},n.year+" Day "+n.puzz+" - "+n.title)),o.createElement(r.xA,{components:g},t),n.puzz&&n.year?o.createElement(l.A,{year:n.year,puzz:n.puzz}):o.createElement(o.Fragment,null))),o.createElement(d.A,null))}function m(e){return o.createElement(p,e,o.createElement(a,e))}const h=()=>o.createElement(o.Fragment,null,o.createElement("title",null,"Joel-Allan-NZ - Advent of Code"),o.createElement("html",{lang:"en"}),o.createElement("link",{rel:"preconnect",href:"https://fonts.googleapis.com"}),o.createElement("link",{rel:"preconnect",href:"https://fonts.gstatic.com"}),o.createElement("link",{href:"https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&family=VT323&display=swap",rel:"stylesheet"}))}}]);
//# sourceMappingURL=component---src-components-layout-tsx-content-file-path-days-2024-13-mdx-de984ed6b8ccc16a4727.js.map