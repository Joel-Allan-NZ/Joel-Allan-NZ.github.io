"use strict";(self.webpackChunkjoel_allan_nz_github_io=self.webpackChunkjoel_allan_nz_github_io||[]).push([[9299],{3477:function(e,n,t){t.r(n),t.d(n,{Head:function(){return m},default:function(){return u}});var r=t(8453),i=t(6540);function a(e){const n=Object.assign({h2:"h2",p:"p",pre:"pre",code:"code",ul:"ul",li:"li",em:"em"},(0,r.RP)(),e.components),{CodeBox:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("CodeBox",!0),i.createElement(i.Fragment,null,i.createElement(n.h2,null,"Part One"),"\n",i.createElement(n.p,null,"Parse the input, build a basic adjacency list, and traverse it according to the given directions until you reach the end point. Alarmingly simple, always a red flag for what you might expect for part 2"),"\n",i.createElement(t,{names:"typescript|C#"},i.createElement(n.pre,null,i.createElement(n.code,{className:"language-js"},"export function partOne(input: string[]): number | string {\n  const { directions, graph } = parse(input)\n  let steps = 0\n  let position = 'AAA'\n  let directionIndex = 0\n\n  while (position != 'ZZZ') {\n    const direction = directions[directionIndex]\n    position =\n      direction == 'L' ? graph.get(position)![0] : graph.get(position)![1]\n    steps++\n    directionIndex =\n      directionIndex == directions.length - 1 ? 0 : directionIndex + 1\n  }\n  return steps\n}\n\nfunction parse(input: string[]): {\n  directions: string\n  graph: Map<string, string[]>\n} {\n  const directions = input[0]\n  const graph = new Map<string, string[]>()\n  input.slice(2).forEach((line) => {\n    const paths = [line.slice(7, 10), line.slice(12, 15)]\n    graph.set(line.slice(0, 3), paths)\n  })\n  return { directions, graph }\n}\n")),i.createElement(n.pre,null,i.createElement(n.code,{className:"language-csharp"},'public override object PartOne()\n{\n    var (directions, graph) = Parse();\n    int steps = 0;\n    string position = "AAA";\n\n    while (position != "ZZZ")\n    {\n        foreach (var direction in directions)\n        {\n            position = direction == \'L\' ? graph[position][0] : graph[position][1];\n            steps++;\n            if (position == "ZZZ")\n                break;\n        }\n    }\n    return steps;\n}\n\nprivate (string directions, Dictionary<string, string[]> graph) Parse()\n{\n    string directions = Input[0];\n    Dictionary<string, string[]> graph = [];\n    for (int i = 2; i < Input.Length; i++)\n    {\n        graph[Input[i][0..3]] = [Input[i][7..10], Input[i][12..15]];\n    }\n    return (directions, graph);\n}\n'))),"\n",i.createElement(n.h2,null,"Part Two"),"\n",i.createElement(n.p,null,"Ahhh, here we go."),"\n",i.createElement("br"),"\n",i.createElement(n.p,null,"First things first, I need to outline a couple assumptions (knowing that this isn't\na real world problem) that I've made in my solution in order to keep it simple:"," "),"\n",i.createElement(n.ul,null,"\n",i.createElement(n.li,null,"\n",i.createElement(n.p,null,"Paths only contain one end. This makes sense based on having as many ends as starts, and my input validates the\nassumption... but it is only an assumption. YMMV"),"\n"),"\n",i.createElement(n.li,null,"\n",i.createElement(n.p,null,"Longest path loops share a ",i.createElement(n.em,null,"single"),"\nGCD. This isn't necessarily true, but the result could be veeeeery big if it isn't.\nTrue for my input at least."),"\n"),"\n",i.createElement(n.li,null,"\n",i.createElement(n.p,null,"Loop lengths have only two meaningful factors: the GCD,\nand a prime number. It makes sense, and holds true for my input."),"\n"),"\n"),"\n",i.createElement("br"),"\n",i.createElement(n.p,null,"With that housekeeping done, I can talk a little about my approach. The idea here\nis that each of the A starts will have their own path, looping to a Z point after\na consistent number of steps. So, I find those loop lengths."),"\n",i.createElement("br"),"\n",i.createElement(n.p,null,"Armed with these lengths, all we need to do is find the smallest number that has\neach loop length as a factor. I do this pretty lazily: for the first pair of loops,\nI find the\n",i.createElement("a",{href:"https://en.wikipedia.org/wiki/Greatest_common_divisor"},"GCD")," via the\n",i.createElement("a",{href:"https://en.wikipedia.org/wiki/Euclidean_algorithm"},"Euclidian"),"\nalgorithm. As discussed above, I make the assumption that this single GCD will hold\ntrue for all loop lengths, so I simply take the GCD + the other factor for each loop\nlength. Then I take the product of all of those factors, yielding the\n",i.createElement("a",{href:"https://en.wikipedia.org/wiki/Least_common_multiple"},"LCM"),", our\nanswer."),"\n",i.createElement(t,{names:"typescript|C#"},i.createElement(n.pre,null,i.createElement(n.code,{className:"language-ts"},"export function partTwo(input: string[]): number | string {\n  const { directions, graph } = parse(input)\n  let loops = [...graph.keys().filter((x) => x.endsWith('A'))].map((x) =>\n    findLoop(graph, x, directions)\n  )\n  const factors = new Set<number>()\n  const g = gcd(loops[0], loops[1])\n  factors.add(g)\n  loops.forEach((loopLength) => factors.add(loopLength / g))\n\n  return factors.values().reduce((total, x) => x * total, 1)\n}\n\nfunction findLoop(\n  graph: Map<string, string[]>,\n  position: string,\n  directions: string\n) {\n  const travelled = new Map<string, number[]>([[position, [0]]])\n  let steps = 0\n  let directionIndex = 0\n\n  while (true) {\n    const direction = directions[directionIndex]\n    position =\n      direction == 'L' ? graph.get(position)![0] : graph.get(position)![1]\n    steps++\n    directionIndex =\n      directionIndex == directions.length - 1 ? 0 : directionIndex + 1\n\n    const been = travelled.get(position)\n    if (!been) travelled.set(position, [steps])\n    else travelled.set(position, [...been, steps])\n\n    if (been) {\n      if (\n        been[been.length - 1] % directions.length ==\n        steps % directions.length\n      )\n        return been[been.length - 1]\n    }\n  }\n}\n\nfunction gcd(a: number, b: number): number {\n  while (b != 0) {\n    let t = b\n    b = a % b\n    a = t\n  }\n  return a\n}\n")),i.createElement(n.pre,null,i.createElement(n.code,{className:"language-csharp"},"public override object PartTwo()\n{\n    var (directions, graph) = Parse();\n    var positions = graph.Keys.Where(key => key.EndsWith('A')).ToList();\n    var loops = positions.Select(x => FindLoop(graph, x, directions)).ToList();\n\n    HashSet<long> factors = [];\n    var gcd = GCD(loops[0], loops[1]);\n    factors.Add(gcd);\n    foreach (var loop in loops)\n        factors.Add(loop / gcd);\n\n    return factors.Aggregate((x, y) => x * y);\n}\n\nprivate static long FindLoop(Dictionary<string, string[]> graph, string start, string directions)\n{\n    Dictionary<string, List<long>> appearancesOnSteps = [];\n    appearancesOnSteps[start] = [0];\n    int dIndex = 0;\n    long steps = 0;\n\n    while (true)\n    {\n        steps++;\n        start = directions[dIndex] == 'L' ? graph[start][0] : graph[start][1];\n        dIndex = dIndex == directions.Length - 1 ? 0 : dIndex + 1;\n\n        if (appearancesOnSteps.TryGetValue(start, out var s))\n            s.Add(steps);\n        else\n            appearancesOnSteps[start] = [steps];\n\n        if (appearancesOnSteps[start].Count > 1)\n        {\n            if (appearancesOnSteps[start][^1] % directions.Length == appearancesOnSteps[start][^2] % directions.Length)\n            {\n                return appearancesOnSteps[start][^2];\n            }\n        }\n    }\n}\n\nprivate static long GCD(long a, long b)\n{\n    while (b != 0)\n    {\n        var t = b;\n        b = a % b;\n        a = t;\n    }\n    return a;\n}\n"))))}var o=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,r.RP)(),e.components);return n?i.createElement(n,e,i.createElement(a,e)):a(e)};var s=t(2779),l=t(7206),c=t(791),p=t(4813),d=t(572);const h={CodeBox:s.A};function g(e){let{pageContext:n,children:t}=e;return i.createElement(i.Fragment,null,i.createElement(p.A,null),i.createElement("div",{className:"min-h-screen bg-chicPrimary"},i.createElement(c.A,{props:n.list}),i.createElement("div",{className:"adventofcode max-w-[60%] ml-[20%]"},i.createElement("h1",null,i.createElement("a",{href:"https://adventofcode.com/"+n.year+"/day/"+n.puzz},n.year+" Day "+n.puzz+" - "+n.title)),i.createElement(r.xA,{components:h},t),n.puzz&&n.year?i.createElement(l.A,{year:n.year,puzz:n.puzz}):i.createElement(i.Fragment,null))),i.createElement(d.A,null))}function u(e){return i.createElement(g,e,i.createElement(o,e))}const m=()=>i.createElement(i.Fragment,null,i.createElement("title",null,"Joel-Allan-NZ - Advent of Code"),i.createElement("html",{lang:"en"}),i.createElement("link",{rel:"preconnect",href:"https://fonts.googleapis.com"}),i.createElement("link",{rel:"preconnect",href:"https://fonts.gstatic.com"}),i.createElement("link",{href:"https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&family=VT323&display=swap",rel:"stylesheet"}))}}]);
//# sourceMappingURL=component---src-components-layout-tsx-content-file-path-days-2023-8-mdx-ef09d73d63f461693751.js.map