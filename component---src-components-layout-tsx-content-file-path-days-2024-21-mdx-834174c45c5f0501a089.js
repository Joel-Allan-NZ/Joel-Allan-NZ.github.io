"use strict";(self.webpackChunkjoel_allan_nz_github_io=self.webpackChunkjoel_allan_nz_github_io||[]).push([[1583],{3631:function(n,e,t){t.r(e),t.d(e,{Head:function(){return d},default:function(){return y}});var a=t(8453),r=t(6540);function o(n){const e=Object.assign({h2:"h2",p:"p",pre:"pre",code:"code"},(0,a.RP)(),n.components),{CodeBox:t}=e;return t||function(n,e){throw new Error("Expected "+(e?"component":"object")+" `"+n+"` to be defined: you likely forgot to import, pass, or provide it.")}("CodeBox",!0),r.createElement(r.Fragment,null,r.createElement(e.h2,null,"Part One"),"\n",r.createElement(e.p,null,"Sometimes solutions are nice and clean, concise and elegant, fast and efficient."),"\n",r.createElement("br"),"\n",r.createElement(e.p,null,"This solution is fast, and that's about it. It's complex, not particularly easy to\nfollow, and uses recursion to handle solving subproblems. My policy with these solutions\nis to remove any explanatory comments (and rely on this space to explain anything\nthat might need it), but we're pushing it to the limit with this one. Here goes!"),"\n",r.createElement("br"),"\n",r.createElement(e.p,null,"First, I determine the coordinates of the buttons on each keypad, and use those coords\nalong with an input code to determine the potential movements that the first direction\npad robot must press for the numpad robot to press the values in that input code."),"\n",r.createElement("br"),"\n",r.createElement(e.p,null,"With those potential series of moves in mind, I break them into pairs of keypresses,\nand find the various sets of moves that a robot one step higher up the chain might\npress in order to have that outcome. This is the base of my solution; a repeatable\nsubproblem. At this point hopefully it becomes obvious that this is a ",r.createElement("a",{href:"https://en.wikipedia.org/wiki/Dynamic_programming"},"\ndynamic programming\n")," problem. We have repeatable subproblems, so of course I cache the solution of\neach subproblem for faster processing as we move along. It becomes a matter of continuing\nto find sets of moves that a parent robot might press, and the 'cheapest' option\nwithin each set. Continue with this until we complete the parent problem of x robots."),"\n",r.createElement(t,{boxname:"one",names:"typescript|C#"},r.createElement(e.pre,null,r.createElement(e.code,{className:"language-js"},"export function partOne(input: string[]): number | string {\n  return findComplexity(2, input)\n}\n\ninterface Key {\n  x: number\n  y: number\n  c: string\n}\n\nclass RobotCache {\n  cache: Map<string, Map<string, Map<number, number>>>\n  constructor() {\n    this.cache = new Map<string, Map<string, Map<number, number>>>()\n  }\n\n  setCache(a: string, b: string, robots: number, count: number) {\n    if (!this.cache.has(a))\n      this.cache.set(a, new Map<string, Map<number, number>>())\n    if (!this.cache.get(a)?.has(b))\n      this.cache.get(a)?.set(b, new Map<number, number>())\n\n    this.cache.get(a)?.get(b)?.set(robots, count)\n  }\n\n  tryGetCache(a: string, b: string, robots: number) {\n    return this.cache.get(a)?.get(b)?.get(robots)\n  }\n}\n\nfunction findComplexity(robotCount: number, input: string[]): number {\n  const { numPad, directionalPad } = generateKeyDictionaries()\n  const cache = new RobotCache()\n  let score = 0\n\n  for (let line of input) {\n    const moves = numPadMoves(line, 'A', numPad)\n\n    const minCost = moves.reduce((minimum, current) => {\n      const pairs = current\n        .split('')\n        .map((item, index) => [index == 0 ? 'A' : current[index - 1], item])\n      const pairsCost = pairs.reduce((total, pair) => {\n        return (\n          total + findMinimumStepCost(pair, robotCount, cache, directionalPad)\n        )\n      }, 0)\n      return pairsCost < minimum ? pairsCost : minimum\n    }, Number.POSITIVE_INFINITY)\n\n    score += minCost * parseInt(line.slice(0, line.length - 1))\n  }\n  return score\n}\n\nfunction generateKeyDictionaries(): {\n  numPad: Map<string, Key>\n  directionalPad: Map<string, Key>\n} {\n  const numKeys = ['789', '456', '123', ' 0A']\n  const dirKeys = [' ^A', '<v>']\n  const directionalPad = new Map<string, Key>()\n  const numPad = new Map<string, Key>()\n  dirKeys\n    .flatMap((row, y) => row.split('').map((c, x) => ({ x, y, c })))\n    .forEach((key) => {\n      if (key.c != ' ') directionalPad.set(key.c, key)\n    })\n  numKeys\n    .flatMap((row, y) => row.split('').map((c, x) => ({ x, y, c })))\n    .forEach((key) => {\n      if (key.c != ' ') numPad.set(key.c, key)\n    })\n  return { numPad, directionalPad }\n}\n\nfunction numPadMoves(\n  code: string,\n  start: string,\n  keys: Map<string, Key>\n): string[] {\n  const result: string[] = []\n  const end = code[0]\n  const moves = generateMoves(keys.get(start)!, keys.get(end)!)\n\n  moves.forEach((move) => {\n    if (code.length == 1) moves.forEach((move) => result.push(move + 'A'))\n    else\n      moves\n        .flatMap((move) =>\n          numPadMoves(code.slice(1), end, keys).map(\n            (partialPath) => move + 'A' + partialPath\n          )\n        )\n        .forEach((move) => result.push(move))\n  })\n  return result\n}\n\nfunction generateMoves(start: Key, end: Key): string[] {\n  const result: string[] = []\n  const stack: { x: number; y: number; path: string[] }[] = []\n  stack.push({ x: start.x, y: start.y, path: [] })\n\n  while (stack.length > 0) {\n    const { x, y, path } = stack.shift()!\n    if (x == end.x && y == end.y) {\n      result.push(path.join(''))\n      continue\n    }\n    const potentialNumber = parseInt(end.c)\n    if (x == 0 && y == 3 && !isNaN(potentialNumber)) continue\n    if (x == 0 && y == 0 && isNaN(potentialNumber)) continue\n\n    if (x != end.x)\n      stack.push(\n        x < end.x\n          ? { x: x + 1, y, path: [...path, '>'] }\n          : { x: x - 1, y, path: [...path, '<'] }\n      )\n    if (y != end.y)\n      stack.push(\n        y < end.y\n          ? { x, y: y + 1, path: [...path, 'v'] }\n          : { x, y: y - 1, path: [...path, '^'] }\n      )\n  }\n  return result\n}\n\nfunction findMinimumStepCost(\n  step: string[],\n  robotCount: number,\n  cache: RobotCache,\n  directionalPad: Map<string, Key>\n): number {\n  let cachedValue = cache.tryGetCache(step[0], step[1], robotCount)\n  if (!cachedValue) {\n    const moves = generateMoves(\n      directionalPad.get(step[0])!,\n      directionalPad.get(step[1])!\n    )\n\n    cachedValue = moves.reduce((min, move) => {\n      const paths = (move + 'A')\n        .split('')\n        .map((c, i) => [i == 0 ? 'A' : move[i - 1], c])\n\n      const cost = pathCost(paths, robotCount, cache, directionalPad)\n\n      return cost > min ? min : cost\n    }, Number.POSITIVE_INFINITY)\n\n    cache.setCache(step[0], step[1], robotCount, cachedValue)\n  }\n  return cachedValue\n}\n\nfunction pathCost(\n  paths: string[][],\n  robotCount: number,\n  cache: RobotCache,\n  directionalPad: Map<string, Key>\n): number {\n  return paths.reduce((total, path) => {\n    return robotCount == 1\n      ? total + 1\n      : total + findMinimumStepCost(path, robotCount - 1, cache, directionalPad)\n  }, 0)\n}\n")),r.createElement(e.pre,null,r.createElement(e.code,{className:"language-csharp"},"public override object PartOne()\n{\n    return FindComplexity(2);\n}\n\nprivate long FindComplexity(int robotCount)\n{\n    var (numpad, directionalKeys) = GenerateKeyDictionaries();\n    var cache = new Dictionary<(char a, char b, int robots), long>();\n    var score = 0L;\n\n    foreach (var line in Input)\n    {\n        var moves = NumpadMoves(line, 'A', numpad);\n\n        var min = moves.Min(move =>\n        {\n            var pairs = move.Select((c, i) => (a: i == 0 ? 'A' : move[i - 1], b: c)).ToArray();\n            return pairs.Select(p => FindMinimumCost(p, robotCount, cache, directionalKeys)).Sum();\n        });\n\n        score += min * int.Parse(line[..^1]);\n\n    }\n    return score;\n}\n\nprivate static (Dictionary<char, Key> num, Dictionary<char, Key> dir) GenerateKeyDictionaries()\n{\n    string[] numKeys = [\"789\", \"456\", \"123\", \" 0A\"];\n    string[] dirKeys = [\" ^A\", \"<v>\"];\n    Dictionary<char, Key> directionalKeys = dirKeys.SelectMany((row, y) => row.Select((value, x) => new Key(x, y, value)))\n                                                   .Where(z => z.C != ' ')\n                                                   .ToDictionary(key => key.C);\n\n    Dictionary<char, Key> numpad = numKeys.SelectMany((row, y) => row.Select((value, x) => new Key(x, y, value)))\n                                          .Where(z => z.C != ' ')\n                                          .ToDictionary(key => key.C);\n\n    return (numpad, directionalKeys);\n}\n\nprivate static long FindMinimumCost((char a, char b) step, int robotCount, Dictionary<(char a, char b, int robotCount), long> cache, Dictionary<char, Key> directionalKeys)\n{\n    if (!cache.TryGetValue((step.a, step.b, robotCount), out var minCost))\n    {\n        var moves = GenerateMoves(directionalKeys[step.a], directionalKeys[step.b]);\n\n        sminCost = moves.Min(move =>\n        {\n            var paths = move.Append('A')\n            .Select((c, i) => (a: i == 0 ? 'A' : move[i - 1], b: c))\n            .ToArray();\n\n            return PathCost(paths, robotCount, cache, directionalKeys);\n        });\n        cache[(step.a, step.b, robotCount)] = minCost;\n    }\n    return minCost;\n\n    static long PathCost((char a, char b)[] paths, int robotCount, Dictionary<(char a, char b, int robotCount), long> cache, Dictionary<char, Key> directionalKeys) =>\n    paths.Sum(x => robotCount == 1 ? 1 : FindMinimumCost(x, robotCount - 1, cache, directionalKeys));\n\n}\n\nprivate static IEnumerable<string> NumpadMoves(string code, char startPosition, Dictionary<char, Key> keys)\n{\n    var end = code[0];\n    var moves = GenerateMoves(keys[startPosition], keys[code[0]]);\n\n    foreach (var move in moves)\n    {\n        if (code.Length == 1)\n            return moves.Select(x => x + 'A');\n        else\n            return moves.SelectMany(x => NumpadMoves(code[1..], end, keys).Select(partialpath => x + 'A' + partialpath));\n    }\n    return [];\n}\n\nprivate static IEnumerable<string> GenerateMoves(Key startKey, Key endKey)\n{\n    Stack<(int x, int y, List<char> path)> stack = [];\n    stack.Push((startKey.X, startKey.Y, []));\n    while (stack.Count > 0)\n    {\n        var (x, y, path) = stack.Pop();\n        if (x == endKey.X && y == endKey.Y)\n        {\n            yield return new string([.. path]);\n            continue;\n        }\n\n        if (int.TryParse(endKey.C.ToString(), out var val))\n        {\n            if (x == 0 && y == 3)\n                continue;\n        }\n        else if (x == 0 && y == 0)\n            continue;\n\n        if (x != endKey.X)\n            stack.Push(x < endKey.X ? (x + 1, y, new(path) { '>' }) : (x - 1, y, new(path) { '<' }));\n\n        if (y != endKey.Y)\n            stack.Push(y < endKey.Y ? (x, y + 1, new(path) { 'v' }) : (x, y - 1, new(path) { '^' }));\n    }\n}\ninternal struct Key(int x, int y, char c)\n{\n    internal int X = x;\n    internal int Y = y;\n    internal char C = c;\n}\n"))),"\n",r.createElement(e.h2,null,"Part Two"),"\n",r.createElement(e.p,null,"Same thing but with a considerably bigger number of robots to ensure you're got an efficient solution!"),"\n",r.createElement(t,{boxname:"two",names:"typescript|C#"},r.createElement(e.pre,null,r.createElement(e.code,{className:"language-js"},"export function partTwo(input: string[]): number | string {\n  return findComplexity(25, input)\n}\n")),r.createElement(e.pre,null,r.createElement(e.code,{className:"language-csharp"},"public override object PartTwo()\n{\n    return FindComplexity(25);\n}\n"))))}var i=function(n){void 0===n&&(n={});const{wrapper:e}=Object.assign({},(0,a.RP)(),n.components);return e?r.createElement(e,n,r.createElement(o,n)):o(n)};var s=t(2779),c=t(7206),l=t(791),u=t(4813),m=t(572);const p={CodeBox:s.A};function h(n){let{pageContext:e,children:t}=n;return r.createElement(r.Fragment,null,r.createElement(u.A,null),r.createElement("div",{className:"min-h-screen bg-chicPrimary"},r.createElement(l.A,{props:e.list}),r.createElement("div",{className:"adventofcode max-w-[60%] ml-[20%]"},r.createElement("h1",null,r.createElement("a",{href:"https://adventofcode.com/"+e.year+"/day/"+e.puzz},e.year+" Day "+e.puzz+" - "+e.title)),r.createElement(a.xA,{components:p},t),e.puzz&&e.year?r.createElement(c.A,{year:e.year,puzz:e.puzz}):r.createElement(r.Fragment,null))),r.createElement(m.A,null))}function y(n){return r.createElement(h,n,r.createElement(i,n))}const d=()=>r.createElement(r.Fragment,null,r.createElement("title",null,"Joel-Allan-NZ - Advent of Code"),r.createElement("html",{lang:"en"}),r.createElement("link",{rel:"preconnect",href:"https://fonts.googleapis.com"}),r.createElement("link",{rel:"preconnect",href:"https://fonts.gstatic.com"}),r.createElement("link",{href:"https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&family=VT323&display=swap",rel:"stylesheet"}))}}]);
//# sourceMappingURL=component---src-components-layout-tsx-content-file-path-days-2024-21-mdx-834174c45c5f0501a089.js.map