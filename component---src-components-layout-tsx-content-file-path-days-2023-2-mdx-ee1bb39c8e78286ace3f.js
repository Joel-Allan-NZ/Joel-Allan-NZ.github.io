"use strict";(self.webpackChunkjoel_allan_nz_github_io=self.webpackChunkjoel_allan_nz_github_io||[]).push([[7597],{146:function(e,t,n){n.r(t),n.d(t,{Head:function(){return h},default:function(){return d}});var a=n(8453),r=n(6540);function o(e){const t=Object.assign({h2:"h2",p:"p",pre:"pre",code:"code"},(0,a.RP)(),e.components),{CodeBox:n}=t;return n||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("CodeBox",!0),r.createElement(r.Fragment,null,r.createElement(t.h2,null,"Part One"),"\n",r.createElement(t.p,null,"With a list of key-value pairs to check, a Map makes for an obvious data structure choice."),"\n",r.createElement("br"),"\n",r.createElement(t.p,null,"You could of course instead just check each line as you read it rather than first\ncreating a map as I am, but I (correctly) guessed that it would be relevant and reusable\nfor part 2."," "),"\n",r.createElement(n,{names:"typescript|C#"},r.createElement(t.pre,null,r.createElement(t.code,{className:"language-js"},"export function partOne(input: string[]): number | string {\n  const targets = [\n    { count: 14, colour: 'blue' },\n    { count: 12, colour: 'red' },\n    { count: 13, colour: 'green' },\n  ]\n  const counts = parse(input)\n\n  return counts.reduce((total, count, index) => {\n    if (targets.every((target) => count.get(target.colour)! <= target.count))\n      return total + index + 1\n    return total\n  }, 0)\n}\n\nfunction parse(input: string[]): Map<string, number>[] {\n  const gameCounts: Map<string, number>[] = []\n  input.forEach((line) => {\n    const gameCount = new Map<string, number>()\n    const games = line.split(/[:;,]/).slice(1)\n    games.forEach((game) => {\n      const pair = game.trim().split(' ')\n      const existing = gameCount.get(pair[1]) ?? 0\n      gameCount.set(pair[1], Math.max(parseInt(pair[0]), existing))\n    })\n    gameCounts.push(gameCount)\n  })\n  return gameCounts\n}\n")),r.createElement(t.pre,null,r.createElement(t.code,{className:"language-csharp"},"public override object PartOne()\n{\n    var counts = Parse();\n    List<(int max, string colour)> targets = [(14, \"blue\"), (12, \"red\"), (13, \"green\")];\n    int sum = 0;\n    for (int i = 0; i < counts.Count; i++)\n    {\n        if (targets.All(target => counts[i][target.colour] <= target.max))\n            sum += i + 1;\n    }\n    return sum;\n}\n\nprivate List<Dictionary<string, int>> Parse()\n{\n    List<Dictionary<string, int>> gameCounts = [];\n    foreach (var line in Input)\n    {\n        Dictionary<string, int> gameCount = [];\n        var games = line.Split([':', ';', ','], StringSplitOptions.RemoveEmptyEntries).Skip(1);\n        foreach (var game in games)\n        {\n            var pairValues = game.Split(' ', StringSplitOptions.RemoveEmptyEntries);\n            if (!gameCount.TryGetValue(pairValues[1], out int value))\n                gameCount[pairValues[1]] = int.Parse(pairValues[0]);\n            else\n                gameCount[pairValues[1]] = Math.Max(value, int.Parse(pairValues[0]));\n        }\n        gameCounts.Add(gameCount);\n    }\n    return gameCounts;\n}\n"))),"\n",r.createElement(t.h2,null,"Part Two"),"\n",r.createElement(t.p,null,"Find the smallest value for each key in each line of the input. Still just a warm-up problem, all about getting very fast leaderboard times."),"\n",r.createElement(n,{names:"typescript|C#"},r.createElement(t.pre,null,r.createElement(t.code,{className:"language-ts"},"export function partTwo(input: string[]): number | string {\n  const counts = parse(input)\n  return counts.reduce(\n    (total, count) => total + count.values().reduce((t, value) => t * value, 1),\n    0\n  )\n}\n")),r.createElement(t.pre,null,r.createElement(t.code,{className:"language-csharp"},"public override object PartTwo()\n{\n    var counts = Parse();\n    return counts.Sum(count => count.Values.Aggregate((x, y) => x * y));\n}\n"))))}var l=function(e){void 0===e&&(e={});const{wrapper:t}=Object.assign({},(0,a.RP)(),e.components);return t?r.createElement(t,e,r.createElement(o,e)):o(e)};var c=n(2779),u=n(7206),s=n(791),i=n(4813),m=n(572);const p={CodeBox:c.A};function g(e){let{pageContext:t,children:n}=e;return r.createElement(r.Fragment,null,r.createElement(i.A,null),r.createElement("div",{className:"min-h-screen bg-chicPrimary"},r.createElement(s.A,{props:t.list}),r.createElement("div",{className:"adventofcode max-w-[60%] ml-[20%]"},r.createElement("h1",null,r.createElement("a",{href:"https://adventofcode.com/"+t.year+"/day/"+t.puzz},t.year+" Day "+t.puzz+" - "+t.title)),r.createElement(a.xA,{components:p},n),t.puzz&&t.year?r.createElement(u.A,{year:t.year,puzz:t.puzz}):r.createElement(r.Fragment,null))),r.createElement(m.A,null))}function d(e){return r.createElement(g,e,r.createElement(l,e))}const h=()=>r.createElement(r.Fragment,null,r.createElement("title",null,"Joel-Allan-NZ - Advent of Code"),r.createElement("html",{lang:"en"}),r.createElement("link",{rel:"preconnect",href:"https://fonts.googleapis.com"}),r.createElement("link",{rel:"preconnect",href:"https://fonts.gstatic.com"}),r.createElement("link",{href:"https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&family=VT323&display=swap",rel:"stylesheet"}))}}]);
//# sourceMappingURL=component---src-components-layout-tsx-content-file-path-days-2023-2-mdx-ee1bb39c8e78286ace3f.js.map