{"version":3,"file":"component---src-components-layout-tsx-content-file-path-days-2023-23-mdx-9295ac0029e952f85d32.js","mappings":"uOAGA,SAASA,EAAkBC,GACzB,MAAMC,EAAcC,OAAOC,OAAO,CAChCC,GAAI,KACJC,EAAG,IACHC,EAAG,IACHC,IAAK,MACLC,KAAM,SACLC,EAAAA,EAAAA,MAAsBT,EAAMU,aAAa,QAACC,GAAWV,EAExD,OADKU,GA8BP,SAA8BC,EAAIC,GAChC,MAAM,IAAIC,MAAM,aAAeD,EAAY,YAAc,UAAY,KAAOD,EAAK,qEACnF,CAhCgBG,CAAqB,WAAW,GACvCC,EAAAA,cAAoBA,EAAAA,SAAgB,KAAMA,EAAAA,cAAoBf,EAAYG,GAAI,KAAM,YAAa,KAAMY,EAAAA,cAAoBf,EAAYI,EAAG,KAAM,kCAAmCW,EAAAA,cAAoBf,EAAYK,EAAG,CAC3NW,KAAM,wDACL,OAAQ,iDAAkDD,EAAAA,cAAoBf,EAAYK,EAAG,CAC9FW,KAAM,sDACL,OAAQ,+SAAgT,KAAMD,EAAAA,cAAoBL,EAAS,CAC5VO,MAAO,iBACNF,EAAAA,cAAoBf,EAAYM,IAAK,KAAMS,EAAAA,cAAoBf,EAAYO,KAAM,CAClFW,UAAW,eACV,g7DAAi7DH,EAAAA,cAAoBf,EAAYM,IAAK,KAAMS,EAAAA,cAAoBf,EAAYO,KAAM,CACngEW,UAAW,mBACV,0wDAA2wD,KAAMH,EAAAA,cAAoBf,EAAYG,GAAI,KAAM,YAAa,KAAMY,EAAAA,cAAoBf,EAAYI,EAAG,KAAM,mEAAoE,KAAMW,EAAAA,cAAoB,MAAO,KAAMA,EAAAA,cAAoBf,EAAYI,EAAG,KAAM,OAAQW,EAAAA,cAAoBf,EAAYK,EAAG,CACvjEW,KAAM,sDACL,wBAAyB,oBAAqBD,EAAAA,cAAoBf,EAAYK,EAAG,CAClFW,KAAM,6CACL,WAAY,wGAAyGD,EAAAA,cAAoBf,EAAYK,EAAG,CACzJW,KAAM,oDACL,OAAQ,8DAA+D,KAAMD,EAAAA,cAAoB,MAAO,KAAMA,EAAAA,cAAoBf,EAAYI,EAAG,KAAM,wrBAAyrB,KAAMW,EAAAA,cAAoB,MAAO,KAAMA,EAAAA,cAAoBL,EAAS,CACr5BO,MAAO,iBACNF,EAAAA,cAAoBf,EAAYM,IAAK,KAAMS,EAAAA,cAAoBf,EAAYO,KAAM,CAClFW,UAAW,eACV,m7GAAo7GH,EAAAA,cAAoBf,EAAYM,IAAK,KAAMS,EAAAA,cAAoBf,EAAYO,KAAM,CACtgHW,UAAW,mBACV,w/HACL,CAKA,MAJA,SAAoBnB,QAAK,IAALA,IAAAA,EAAQ,CAAC,GAC3B,MAAOoB,QAASC,GAAanB,OAAOC,OAAO,CAAC,GAAGM,EAAAA,EAAAA,MAAsBT,EAAMU,YAC3E,OAAOW,EAAYL,EAAAA,cAAoBK,EAAWrB,EAAOgB,EAAAA,cAAoBjB,EAAmBC,IAAUD,EAAkBC,EAC9H,E,oDC/BA,MAAMsB,EAAa,CACjBX,QAAOA,EAAAA,GAET,SAASY,EAAOC,GACd,IAAI,YAACC,EAAW,SAAEC,GAAYF,EAC9B,OAAOR,EAAAA,cAAoBA,EAAAA,SAAgB,KAAMA,EAAAA,cAAoBW,EAAAA,EAAQ,MAAOX,EAAAA,cAAoB,MAAO,CAC7GG,UAAW,+BACVH,EAAAA,cAAoBY,EAAAA,EAAe,CACpC5B,MAAOyB,EAAYI,OACjBb,EAAAA,cAAoB,MAAO,CAC7BG,UAAW,qCACVH,EAAAA,cAAoB,KAAM,KAAMA,EAAAA,cAAoB,IAAK,CAC1DC,KAAM,4BAA8BQ,EAAYK,KAAO,QAAUL,EAAYM,MAC5EN,EAAYK,KAAO,QAAUL,EAAYM,KAAO,MAAQN,EAAYO,QAAShB,EAAAA,cAAoBiB,EAAAA,GAAa,CAC/GvB,WAAYY,GACXI,GAAWD,EAAYM,MAAQN,EAAYK,KAAOd,EAAAA,cAAoBkB,EAAAA,EAAa,CACpFJ,KAAML,EAAYK,KAClBC,KAAMN,EAAYM,OACff,EAAAA,cAAoBA,EAAAA,SAAgB,QAASA,EAAAA,cAAoBmB,EAAAA,EAAQ,MAChF,CACe,SAASC,EAAiBpC,GACvC,OAAOgB,EAAAA,cAAoBO,EAAQvB,EAAOgB,EAAAA,cAAoBqB,EAAqBrC,GACrF,CACO,MAAMsC,EAAOA,IAAMtB,EAAAA,cAAoBA,EAAAA,SAAgB,KAAMA,EAAAA,cAAoB,QAAS,KAAM,kCAAmCA,EAAAA,cAAoB,OAAQ,CACpKuB,KAAM,OACJvB,EAAAA,cAAoB,OAAQ,CAC9BwB,IAAK,aACLvB,KAAM,iCACJD,EAAAA,cAAoB,OAAQ,CAC9BwB,IAAK,aACLvB,KAAM,8BACJD,EAAAA,cAAoB,OAAQ,CAC9BC,KAAM,mKACNuB,IAAK,e","sources":["webpack://joel-allan-nz.github.io/./days/2023/23.mdx","webpack://joel-allan-nz.github.io/./src/components/Layout.tsx"],"sourcesContent":["/*@jsxRuntime classic @jsx React.createElement @jsxFrag React.Fragment*/\nimport {useMDXComponents as _provideComponents} from \"@mdx-js/react\";\nimport React from \"react\";\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    p: \"p\",\n    a: \"a\",\n    pre: \"pre\",\n    code: \"code\"\n  }, _provideComponents(), props.components), {CodeBox} = _components;\n  if (!CodeBox) _missingMdxReference(\"CodeBox\", true);\n  return React.createElement(React.Fragment, null, React.createElement(_components.h2, null, \"Part One\"), \"\\n\", React.createElement(_components.p, null, \"As the slopes make the input a \", React.createElement(_components.a, {\n    href: \"https://en.wikipedia.org/wiki/Directed_acyclic_graph\"\n  }, \"DAG\"), \", it's possible to find a longest path with a \", React.createElement(_components.a, {\n    href: \"https://en.wikipedia.org/wiki/Breadth-first_search\"\n  }, \"BFS\"), \", with only a touch of logic to handle the slippery slopes. Although I opted not to bother, it would be trivial to treat this as a weighted graph: each point where slopes meet can also be treated as a node; the spaces between them are direct (albeit not 'straight') and allow for no decision making.\"), \"\\n\", React.createElement(CodeBox, {\n    names: \"typescript|C#\"\n  }, React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-ts\"\n  }, \"export function partOne(input: string[]): number | string {\\n  const start = [input[0].indexOf('.'), 0]\\n  const end = [input[input.length - 1].indexOf('.'), input.length - 1]\\n  const queue: number[][] = [start]\\n  const distances = new Map<string, number>()\\n  distances.set(start.join(','), 0)\\n\\n  while (queue.length > 0) {\\n    const current = queue.shift()!\\n    const neighbours = findOrthogonalNeighbours(current, input)\\n    const oldDistance = distances.get(current.join(','))!\\n\\n    neighbours.forEach((neighbour) => {\\n      const distance = distances.get(neighbour.join(','))\\n      if (!distance || distance < oldDistance - 1) {\\n        distances.set(neighbour.join(','), oldDistance + 1)\\n        const next = handleSlopes(input, neighbour)\\n        if (next[0] != current[0] || next[1] != current[1]) {\\n          if (next[0] != neighbour[0] || next[1] != neighbour[1]) {\\n            distances.set(next.join(','), oldDistance + 2)\\n          }\\n          queue.push(next)\\n        }\\n      }\\n    })\\n  }\\n\\n  return distances.get(end.join(','))!\\n}\\n\\nfunction handleSlopes(input: string[], coords: number[]): number[] {\\n  switch (input[coords[1]][coords[0]]) {\\n    case '>':\\n      return [coords[0] + 1, coords[1]]\\n    case '<':\\n      return [coords[0] - 1, coords[1]]\\n    case '^':\\n      return [coords[0], coords[1] - 1]\\n    case 'v':\\n      return [coords[0], coords[1] + 1]\\n    default:\\n      return coords\\n  }\\n}\\n\\nfunction findOrthogonalNeighbours(\\n  coords: number[],\\n  input: string[]\\n): number[][] {\\n  return [\\n    [coords[0] + 1, coords[1]],\\n    [coords[0] - 1, coords[1]],\\n    [coords[0], coords[1] - 1],\\n    [coords[0], coords[1] + 1],\\n  ].filter((step) => inBounds(step, input) && input[step[1]][step[0]] != '#')\\n}\\n\\nfunction inBounds(coords: number[], input: string[]) {\\n  return (\\n    coords[0] > -1 &&\\n    coords[1] > -1 &&\\n    coords[0] < input[0].length &&\\n    coords[1] < input.length\\n  )\\n}\\n\")), React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-csharp\"\n  }, \"public override object PartOne()\\n{\\n    var start = (Input[0].IndexOf('.'), 0);\\n    var end = (Input[^1].IndexOf('.'), Input.Length - 1);\\n    Queue<(int x, int y)> toVisit = new();\\n    Dictionary<(int x, int y), int> distances = [];\\n    toVisit.Enqueue(start);\\n    distances[start] = 0;\\n\\n    while (toVisit.Count > 0)\\n    {\\n        var (x, y) = toVisit.Dequeue();\\n        foreach (var neighbour in FindValidNeighbours([x, y], Input))\\n        {\\n            if (distances.TryGetValue((neighbour[0], neighbour[1]), out var dist) && dist >= distances[(x, y)] - 1)\\n                continue;\\n\\n            distances[(neighbour[0], neighbour[1])] = distances[(x, y)] + 1;\\n            var next = HandleSlopes(Input[neighbour[1]][neighbour[0]], neighbour[0], neighbour[1]);\\n            if (next.x != x || next.y != y)\\n            {\\n                if (next.x != neighbour[0] || next.y != neighbour[1])\\n                {\\n                    distances[next] = distances[(x, y)] + 2;\\n                }\\n                toVisit.Enqueue(next);\\n            }\\n        }\\n    }\\n    return distances[end];\\n}\\n\\nprivate static (int x, int y) HandleSlopes(char slope, int x, int y)\\n{\\n    return slope switch\\n    {\\n        '>' => (x + 1, y),\\n        '<' => (x - 1, y),\\n        '^' => (x, y - 1),\\n        'v' => (x, y + 1),\\n        _ => (x, y)\\n    };\\n}\\n\\nprivate static IEnumerable<int[]> FindValidNeighbours(int[] coord, string[] input)\\n{\\n    int[][] steps = [[coord[0] + 1, coord[1]], [coord[0] - 1, coord[1]], [coord[0], coord[1] + 1], [coord[0], coord[1] - 1]];\\n    return steps.Where(x => InBounds(x[0], x[1], input) && input[x[1]][x[0]] != '#');\\n\\n    static bool InBounds(int x, int y, string[] input) => x > -1 && x < input.Length && y > -1 && y < input[0].Length;\\n}\\n\"))), \"\\n\", React.createElement(_components.h2, null, \"Part Two\"), \"\\n\", React.createElement(_components.p, null, \"This part was a little trickier to get to an appropriate speed!\"), \"\\n\", React.createElement(\"br\"), \"\\n\", React.createElement(_components.p, null, \"The \", React.createElement(_components.a, {\n    href: \"https://en.wikipedia.org/wiki/Longest_path_problem\"\n  }, \"longest path problem\"), \" states\\nthis is \", React.createElement(_components.a, {\n    href: \"https://en.wikipedia.org/wiki/NP-hardness\"\n  }, \"NP-hard\"), \", and to avoid cycles\\nrequires remembering the path taken. It's fairly trivial to bruteforce with a \", React.createElement(_components.a, {\n    href: \"https://en.wikipedia.org/wiki/Depth-first_search\"\n  }, \"DFS\"), \",\\nbut that unsurprisingly has less-than-desirable speeds.\"), \"\\n\", React.createElement(\"br\"), \"\\n\", React.createElement(_components.p, null, \"To simplify the problem, I processed it to the weighted graph I mentioned in part\\n1, and used bitwise operations to efficiently remember nodes travelled on a path\\n(which I usually avoid in these problems, for legibility). The performance was still\\na little slower than my taste, and after trying half a dozen other approaches I resorted\\nto checking for some community ideas. I came across one quite simple time-saver -\\nthe edges between outer vertices of the graph can be treated as directed; only moving\\nfrom the start towards the end. This is a property of the inputs given, rather than\\na generic solution, but it cut the DFS time enough for me to pleased with the finished\\nproduct.\"), \"\\n\", React.createElement(\"br\"), \"\\n\", React.createElement(CodeBox, {\n    names: \"typescript|C#\"\n  }, React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-ts\"\n  }, \"export function partTwo(input: string[]): number | string {\\n  const start = [input[0].indexOf('.'), 0]\\n  const end = [input.length - 1, input[input.length - 1].indexOf('.')]\\n  const adjancencies = findAdjacencies(input, start, end)\\n\\n  return findLongest(adjancencies, 0, 0n, 0)\\n}\\n\\nfunction findLongest(\\n  nodes: Map<number, number>[],\\n  current: number,\\n  bitmask: bigint,\\n  distance: number\\n): number {\\n  let max = distance\\n  nodes[current].entries().forEach((child) => {\\n    const big = 1n << BigInt(child[0])\\n    if ((bitmask & big) == 0n) {\\n      max = Math.max(\\n        max,\\n        findLongest(nodes, child[0], bitmask | big, distance + child[1])\\n      )\\n    }\\n  })\\n  return max\\n}\\n\\nfunction findAdjacencies(\\n  input: string[],\\n  start: number[],\\n  end: number[]\\n): Map<number, number>[] {\\n  const adjacencies: number[][] = [start, end]\\n\\n  input.forEach((line, y) => {\\n    line.split('').forEach((c, x) => {\\n      if (c == '.') {\\n        const neighbours = findOrthogonalNeighbours([x, y], input).filter(\\n          (x) => input[x[1]][x[0]] != '.'\\n        )\\n        if (neighbours.length > 2) adjacencies.push([x, y])\\n      }\\n    })\\n  })\\n\\n  return connectNodes(adjacencies, input)\\n}\\n\\nfunction connectNodes(\\n  nodes: number[][],\\n  input: string[]\\n): Map<number, number>[] {\\n  const queue: number[][] = []\\n  const visited = new Set<string>()\\n  const dicts: Map<number, number>[] = []\\n  nodes.forEach((x) => dicts.push(new Map<number, number>()))\\n\\n  nodes.forEach((node) => {\\n    visited.clear()\\n    queue.push([...node, 0])\\n\\n    while (queue.length > 0) {\\n      const current = queue.shift()!\\n      const neighbours = findOrthogonalNeighbours(current, input)\\n\\n      for (let n of neighbours) {\\n        if (n[0] == node[0] && n[1] == node[1]) continue\\n        const index = nodes.findIndex((x) => x[0] == n[0] && x[1] == n[1])\\n        if (index != -1) {\\n          const existingIndex = nodes.indexOf(node)\\n          let existing = dicts[existingIndex].get(index)\\n          existing = Math.max(current[2] + 1, existing ?? 0)\\n          dicts[existingIndex].set(index, existing)\\n          dicts[index].set(existingIndex, existing)\\n        } else if (!visited.has(n.join(','))) {\\n          visited.add(n.join(','))\\n          queue.push([...n, current[2] + 1])\\n        }\\n      }\\n    }\\n  })\\n\\n  communityOptimization(dicts, nodes)\\n  return dicts\\n}\\n\\nfunction communityOptimization(\\n  dicts: Map<number, number>[],\\n  nodes: number[][]\\n): void {\\n  const originalOrder = [...nodes]\\n\\n  const top = nodes\\n    .sort((x, y) => x[1] - y[1])\\n    .slice(0, 6)\\n    .sort((x, y) => y[0] - x[0])\\n    .map((t) => originalOrder.indexOf(t))\\n\\n  const bottom = nodes\\n    .sort((x, y) => y[1] - x[1])\\n    .slice(0, 6)\\n    .sort((x, y) => y[0] - x[0])\\n    .map((t) => originalOrder.indexOf(t))\\n\\n  const left = nodes\\n    .sort((x, y) => x[0] - y[0])\\n    .slice(0, 6)\\n    .sort((x, y) => y[1] - x[1])\\n    .map((t) => originalOrder.indexOf(t))\\n  const right = nodes\\n    .sort((x, y) => y[0] - x[0])\\n    .slice(0, 6)\\n    .sort((x, y) => y[1] - x[1])\\n    .map((t) => originalOrder.indexOf(t))\\n\\n  for (let i = 0; i < 5; i++) {\\n    top.slice(i + 1).forEach((node) => dicts[top[i]].delete(node))\\n    bottom.slice(i + 1).forEach((node) => dicts[bottom[i]].delete(node))\\n    left.slice(i + 1).forEach((node) => dicts[left[i]].delete(node))\\n    right.slice(i + 1).forEach((node) => dicts[right[i]].delete(node))\\n  }\\n}\\n\")), React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-csharp\"\n  }, \"public override object PartTwo()\\n{\\n    var adjacencies = FindAdjacencies(Input);\\n    var compressed = FindAdjacentDecisionsPoints(adjacencies, Input);\\n\\n    return FindLongest(compressed, 0, 0, 0);\\n}\\n\\nprivate static int FindLongest(Dictionary<int, int>[] nodes, int current, long bitmask, int distance)\\n{\\n    var max = distance;\\n    foreach (var child in nodes[current])\\n    {\\n        if ((bitmask & (1L << child.Key)) == 0)\\n            max = Math.Max(max, FindLongest(nodes, child.Key, (bitmask | (1L << child.Key)), distance + child.Value));\\n    }\\n    return max;\\n}\\n\\nprivate static Dictionary<(int x, int y), Dictionary<(int x, int y), int>> FindAdjacencies(string[] input)\\n{\\n    Dictionary<(int x, int y), Dictionary<(int x, int y), int>> adjacencies = [];\\n    adjacencies.Add((x: input[0].IndexOf('.'), y: 0), []);\\n    adjacencies.Add((x: input[^1].IndexOf('.'), y: input.Length - 1), []);\\n\\n    for (int y = 0; y < input.Length; y++)\\n    {\\n        for (int x = 0; x < input[0].Length; x++)\\n        {\\n            if (input[y][x] == '.' && FindValidNeighbours([x, y], input).Count(x => input[x[1]][x[0]] != '.') > 2)\\n            {\\n                adjacencies.Add((x, y), []);\\n            }\\n        }\\n    }\\n\\n    return adjacencies;\\n}\\n\\nprivate static Dictionary<int, int>[] FindAdjacentDecisionsPoints(Dictionary<(int x, int y), Dictionary<(int x, int y), int>> adjacencies, string[] input)\\n{\\n    Queue<(int x, int y, int distance)> toVisit = new();\\n    HashSet<(int x, int y)> visited = [];\\n    foreach (var adjacency in adjacencies.Keys)\\n    {\\n        visited.Clear();\\n        toVisit.Enqueue((adjacency.x, adjacency.y, 0));\\n        while (toVisit.Count > 0)\\n        {\\n            var (x, y, distance) = toVisit.Dequeue();\\n            foreach (var neighbour in FindValidNeighbours([x, y], input))\\n            {\\n                var tuple = (neighbour[0], neighbour[1]);\\n                if (adjacency.x == neighbour[0] && adjacency.y == neighbour[1] || visited.Contains(tuple))\\n                    continue;\\n\\n                if (adjacencies.ContainsKey(tuple))\\n                {\\n                    if (!adjacencies[adjacency].TryGetValue(tuple, out int value) || value < distance + 1)\\n                        adjacencies[adjacency][tuple] = distance + 1;\\n                }\\n                else if (!visited.Contains(tuple))\\n                {\\n                    toVisit.Enqueue((neighbour[0], neighbour[1], distance + 1));\\n                }\\n\\n                visited.Add(tuple);\\n            }\\n        }\\n    }\\n\\n    CommunityOptimization(adjacencies);\\n    return Simplify(adjacencies);\\n}\\n\\nprivate static Dictionary<int, int>[] Simplify(Dictionary<(int x, int y), Dictionary<(int x, int y), int>> adjacencies)\\n{\\n    List<(int x, int y)> keys = [.. adjacencies.Keys];\\n    Dictionary<int, int>[] adj = new Dictionary<int, int>[keys.Count];\\n\\n    foreach (var kvp in adjacencies)\\n    {\\n        var index = keys.IndexOf(kvp.Key);\\n        adj[index] = [];\\n\\n        foreach (var kvp2 in kvp.Value)\\n        {\\n            var i = keys.IndexOf(kvp2.Key);\\n            adj[index].Add(i, kvp2.Value);\\n        }\\n    }\\n    return adj;\\n}\\n\\nprivate static void CommunityOptimization(Dictionary<(int x, int y), Dictionary<(int x, int y), int>> adjacencies)\\n{\\n    var top = adjacencies.OrderBy(x => x.Key.y).Take(6).OrderByDescending(y => y.Key.x).ToList();\\n    var bottom = adjacencies.OrderByDescending(x => x.Key.y).Take(6).OrderByDescending(y => y.Key.x).ToList();\\n    var left = adjacencies.OrderBy(x => x.Key.x).Take(6).OrderByDescending(y => y.Key.y).ToList();\\n    var right = adjacencies.OrderByDescending(x => x.Key.x).Take(6).OrderByDescending(y => y.Key.y).ToList();\\n\\n    for (int i = 0; i < 5; i++)\\n    {\\n        top[(i + 1)..].ForEach(x => top[i].Value.Remove(x.Key));\\n        bottom[(i + 1)..].ForEach(x => bottom[i].Value.Remove(x.Key));\\n        left[(i + 1)..].ForEach(x => left[i].Value.Remove(x.Key));\\n        right[(i + 1)..].ForEach(x => right[i].Value.Remove(x.Key));\\n    }\\n}\\n\"))));\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? React.createElement(MDXLayout, props, React.createElement(_createMdxContent, props)) : _createMdxContent(props);\n}\nexport default MDXContent;\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","import GATSBY_COMPILED_MDX from \"/home/joel/personal/advent-of-code/joel-allan-nz.github.io/days/2023/23.mdx\";\nimport React from 'react';\nimport {MDXProvider} from '@mdx-js/react';\nimport CodeBox from './CodeBox';\nimport TryYourself from './TryYourself';\nimport AdventSideNav from './AdventSideNav';\nimport Header from './Header';\nimport Footer from './Footer';\nconst shortcodes = {\n  CodeBox\n};\nfunction Layout(_ref) {\n  let {pageContext, children} = _ref;\n  return React.createElement(React.Fragment, null, React.createElement(Header, null), React.createElement(\"div\", {\n    className: \"min-h-screen bg-chicPrimary\"\n  }, React.createElement(AdventSideNav, {\n    props: pageContext.list\n  }), React.createElement(\"div\", {\n    className: \"adventofcode max-w-[60%] ml-[20%]\"\n  }, React.createElement(\"h1\", null, React.createElement(\"a\", {\n    href: \"https://adventofcode.com/\" + pageContext.year + \"/day/\" + pageContext.puzz\n  }, pageContext.year + \" Day \" + pageContext.puzz + \" - \" + pageContext.title)), React.createElement(MDXProvider, {\n    components: shortcodes\n  }, children), pageContext.puzz && pageContext.year ? React.createElement(TryYourself, {\n    year: pageContext.year,\n    puzz: pageContext.puzz\n  }) : React.createElement(React.Fragment, null))), React.createElement(Footer, null));\n}\nexport default function GatsbyMDXWrapper(props) {\n  return React.createElement(Layout, props, React.createElement(GATSBY_COMPILED_MDX, props));\n}\nexport const Head = () => React.createElement(React.Fragment, null, React.createElement(\"title\", null, \"Joel-Allan-NZ - Advent of Code\"), React.createElement(\"html\", {\n  lang: \"en\"\n}), React.createElement(\"link\", {\n  rel: \"preconnect\",\n  href: \"https://fonts.googleapis.com\"\n}), React.createElement(\"link\", {\n  rel: \"preconnect\",\n  href: \"https://fonts.gstatic.com\"\n}), React.createElement(\"link\", {\n  href: \"https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&family=VT323&display=swap\",\n  rel: \"stylesheet\"\n}));\n"],"names":["_createMdxContent","props","_components","Object","assign","h2","p","a","pre","code","_provideComponents","components","CodeBox","id","component","Error","_missingMdxReference","React","href","names","className","wrapper","MDXLayout","shortcodes","Layout","_ref","pageContext","children","Header","AdventSideNav","list","year","puzz","title","MDXProvider","TryYourself","Footer","GatsbyMDXWrapper","GATSBY_COMPILED_MDX","Head","lang","rel"],"sourceRoot":""}