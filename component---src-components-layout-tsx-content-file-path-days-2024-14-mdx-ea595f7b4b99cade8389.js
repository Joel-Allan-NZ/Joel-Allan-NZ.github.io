"use strict";(self.webpackChunkjoel_allan_nz_github_io=self.webpackChunkjoel_allan_nz_github_io||[]).push([[2491],{5693:function(n,e,t){t.r(e),t.d(e,{Head:function(){return d},default:function(){return h}});var o=t(8453),r=t(6540);function i(n){const e=Object.assign({h2:"h2",p:"p",pre:"pre",code:"code"},(0,o.RP)(),n.components),{CodeBox:t}=e;return t||function(n,e){throw new Error("Expected "+(e?"component":"object")+" `"+n+"` to be defined: you likely forgot to import, pass, or provide it.")}("CodeBox",!0),r.createElement(r.Fragment,null,r.createElement(e.h2,null,"Part One"),"\n",r.createElement(e.p,null,"Not too much to discuss here - I parse the values and associate the velocities with their respective current position as a BathroomRobot."),"\n",r.createElement("br"),"\n",r.createElement(e.p,null,"Then it's simply applying 100 steps of movement to each robot, and checking how many\nare in each quadrant. I chose to use multiplication and a modulo to find the final\nposition rather than simulating each step for obvious reasons"),"\n",r.createElement(t,{boxname:"one",names:"typescript|C#"},r.createElement(e.pre,null,r.createElement(e.code,{className:"language-js"},"export function partOne(input: string[]): number | string {\n  const xSize = 101,\n    ySize = 103\n  const xMid = Math.floor(xSize / 2),\n    yMid = Math.floor(ySize / 2)\n  const robots = parse(input)\n  const quadrants = [0, 0, 0, 0]\n\n  robots.forEach((robot) => {\n    updateRobotPosition(robot, 100, xSize, ySize)\n    if (robot.x != xMid && robot.y != yMid) {\n      let quad = robot.x > xMid ? 1 : 0\n      if (robot.y > yMid) quad += 2\n      quadrants[quad]++\n    }\n  })\n\n  return quadrants.reduce((total, current) => total * current, 1)\n}\n\ninterface BathroomRobot {\n  x: number\n  y: number\n  vx: number\n  vy: number\n}\n\nfunction parse(input: string[]): BathroomRobot[] {\n  return input.map((line) => {\n    const values = [...line.matchAll(/[-\\d]+/g)].map((x) => parseInt(x[0]))\n\n    return { x: values[0], y: values[1], vx: values[2], vy: values[3] }\n  })\n}\n\nfunction updateRobotPosition(\n  robot: BathroomRobot,\n  steps: number,\n  xSize: number,\n  ySize: number\n) {\n  const finalX = robot.x + steps * robot.vx\n  const finalY = robot.y + steps * robot.vy\n\n  robot.x = finalX % xSize\n  robot.y = finalY % ySize\n\n  if (robot.x < 0) robot.x += xSize\n  if (robot.y < 0) robot.y += ySize\n}\n")),r.createElement(e.pre,null,r.createElement(e.code,{className:"language-csharp"},'public override object PartOne()\n{\n    int xSize = 101, ySize = 103;\n    int xMid = xSize / 2, yMid = ySize / 2;\n    var robots = Parse();\n    int[] quadrants = [0, 0, 0, 0];\n\n    foreach (var robot in robots)\n    {\n        robot.UpdatePosition(100, xSize, ySize);\n        if (robot.X == xMid || robot.Y == yMid)\n            continue;\n\n        int quadrant = (robot.X > xMid) ? 1 : 0;\n\n        if (robot.Y > yMid)\n            quadrant += 2;\n\n        quadrants[quadrant]++;\n    }\n\n    return quadrants.Aggregate((x, y) => x * y);\n}\n\nprivate List<BathroomRobot> Parse()\n{\n    return Input.Select(line =>\n    {\n        var values = Regex.Matches(line, @"[-\\d]+")\n                          .Select(x => int.Parse(x.Value))\n                          .ToList();\n\n        return new BathroomRobot(values[0], values[1], values[2], values[3]);\n    }).ToList();\n}\n\ninternal class BathroomRobot(int x, int y, int vx, int vy)\n{\n    internal int X = x;\n    internal int Y = y;\n    internal int VX = vx;\n    internal int VY = vy;\n\n    internal void UpdatePosition(int steps, int xSize, int ySize)\n    {\n        int finalX = X + steps * VX;\n        int finalY = Y + steps * VY;\n\n        X = finalX % xSize;\n        Y = finalY % ySize;\n\n        if (X < 0)\n            X += xSize;\n        if (Y < 0)\n            Y += ySize;\n    }\n}\n\n'))),"\n",r.createElement(e.h2,null,"Part Two"),"\n",r.createElement(e.p,null,'As this is a "wait until you see the right thing" sort of puzzle, this might be the first time my solution doesn\'t work for you!'),"\n",r.createElement("br"),"\n",r.createElement(e.p,null,"My approach (without displaying a visualization) is to assume that a christmas tree\nwill require a large number of robots next to each other in at least one row, and\nwith at least one robot neighbour each. 24 is an entirely arbitrary number (my input\nsucceeded with a targetSize as small as 14), but it should help to avoid false positives."),"\n",r.createElement(t,{boxname:"two",names:"typescript|C#"},r.createElement(e.pre,null,r.createElement(e.code,{className:"language-js"},"export function partTwo(input: string[]): number | string {\n  const xSize = 101,\n    ySize = 103\n  const robots = parse(input)\n  let steps = 0\n  while (true) {\n    steps++\n    robots.forEach((robot) => updateRobotPosition(robot, 1, xSize, ySize))\n    if (hasContiguousRowOfSize(robots, 24)) return steps\n  }\n}\n\nfunction hasContiguousRowOfSize(\n  robots: BathroomRobot[],\n  targetSize: number\n): boolean {\n  const positions = new Map<number, Set<number>>()\n\n  robots.forEach((robot) => {\n    if (!positions.has(robot.y))\n      positions.set(robot.y, new Set<number>([robot.x]))\n    else positions.get(robot.y)?.add(robot.x)\n  })\n\n  return positions.values().some((row) => {\n    let contiguous = 0\n    if (row.size >= targetSize) {\n      row.values().forEach((x) => {\n        if (row.has(x + 1)) {\n          contiguous++\n        }\n      })\n    }\n    return contiguous >= targetSize\n  })\n}\n\n")),r.createElement(e.pre,null,r.createElement(e.code,{className:"language-csharp"},"public override object PartTwo()\n{\n    int xSize = 101, ySize = 103;\n    var robots = Parse();\n    int steps = 0;\n\n    while (true)\n    {\n        steps++;\n        foreach (var robot in robots)\n            robot.UpdatePosition(1, xSize, ySize);\n\n        if (HasContigousRowOfSize(robots, 24))\n            return steps;\n    }\n}\n\nprivate static bool HasContigousRowOfSize(List<BathroomRobot> robots, int size)\n{\n    Dictionary<int, HashSet<int>> positions = [];\n\n    foreach (var robot in robots)\n        positions.AddToOrCreateCollection(robot.Y, robot.X);\n\n    foreach (var row in positions.Values)\n    {\n        if (row.Count >= size)\n        {\n            var contiguous = 0;\n            foreach (var x in row)\n            {\n                if (row.Contains(x + 1))\n                    contiguous++;\n            }\n            if (contiguous >= size)\n                return true;\n        }\n    }\n    return false;\n}\n\n"))))}var a=function(n){void 0===n&&(n={});const{wrapper:e}=Object.assign({},(0,o.RP)(),n.components);return e?r.createElement(e,n,r.createElement(i,n)):i(n)};var s=t(2779),l=t(7206),u=t(791),c=t(4813),p=t(572);const m={CodeBox:s.A};function b(n){let{pageContext:e,children:t}=n;return r.createElement(r.Fragment,null,r.createElement(c.A,null),r.createElement("div",{className:"min-h-screen bg-chicPrimary"},r.createElement(u.A,{props:e.list}),r.createElement("div",{className:"adventofcode max-w-[60%] ml-[20%]"},r.createElement("h1",null,r.createElement("a",{href:"https://adventofcode.com/"+e.year+"/day/"+e.puzz},e.year+" Day "+e.puzz+" - "+e.title)),r.createElement(o.xA,{components:m},t),e.puzz&&e.year?r.createElement(l.A,{year:e.year,puzz:e.puzz}):r.createElement(r.Fragment,null))),r.createElement(p.A,null))}function h(n){return r.createElement(b,n,r.createElement(a,n))}const d=()=>r.createElement(r.Fragment,null,r.createElement("title",null,"Joel-Allan-NZ - Advent of Code"),r.createElement("html",{lang:"en"}),r.createElement("link",{rel:"preconnect",href:"https://fonts.googleapis.com"}),r.createElement("link",{rel:"preconnect",href:"https://fonts.gstatic.com"}),r.createElement("link",{href:"https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&family=VT323&display=swap",rel:"stylesheet"}))}}]);
//# sourceMappingURL=component---src-components-layout-tsx-content-file-path-days-2024-14-mdx-ea595f7b4b99cade8389.js.map