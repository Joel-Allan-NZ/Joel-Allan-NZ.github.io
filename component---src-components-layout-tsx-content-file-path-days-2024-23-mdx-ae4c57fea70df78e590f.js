"use strict";(self.webpackChunkjoel_allan_nz_github_io=self.webpackChunkjoel_allan_nz_github_io||[]).push([[6033],{7036:function(e,n,t){t.r(n),t.d(n,{Head:function(){return d},default:function(){return m}});var r=t(8453),i=t(6540);function a(e){const n=Object.assign({h2:"h2",p:"p",code:"code",pre:"pre"},(0,r.RP)(),e.components),{CodeBox:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("CodeBox",!0),i.createElement(i.Fragment,null,i.createElement(n.h2,null,"Part One"),"\n",i.createElement(n.p,null,"All we need to do here is find ",i.createElement("a",{href:"https://en.wikipedia.org/wiki/Clique_(graph_theory)"},"cliques")," of three computers where at least one has a name starting with ",i.createElement(n.code,null,"t"),". Nothing clever here, I just lazily take all computers that meet the naming requirement and find cliques of three computers containing them."),"\n",i.createElement(t,{boxname:"one",names:"typescript|C#"},i.createElement(n.pre,null,i.createElement(n.code,{className:"language-js"},"export function partOne(input: string[]): number | string {\n  const graph = parse(input)\n  const trios = new Set<string>()\n\n  const tKeys = graph.keys().filter((key) => key.startsWith('t'))\n  tKeys.forEach((key) => {\n    const neighbours = graph.get(key)!\n    neighbours.forEach((neighbour) => {\n      const intersect = new Set([...neighbours]).intersection(\n        new Set([...graph.get(neighbour)!])\n      )\n      intersect.forEach((n) => {\n        const v = [key, n, neighbour]\n        trios.add(v.sort().join('|'))\n      })\n    })\n  })\n  return trios.size\n}\n\nfunction parse(input: string[]): Map<string, string[]> {\n  const graph = new Map<string, string[]>()\n  input.forEach((line) => {\n    let split = line.split('-')\n    if (!graph.has(split[0])) graph.set(split[0], [split[1]])\n    else graph.get(split[0])?.push(split[1])\n\n    if (!graph.has(split[1])) graph.set(split[1], [split[0]])\n    else graph.get(split[1])?.push(split[0])\n  })\n  return graph\n}\n")),i.createElement(n.pre,null,i.createElement(n.code,{className:"language-csharp"},"public override object PartOne()\n{\n    HashSet<(string a, string b, string c)> trios = [];\n    Dictionary<string, List<string>> graph = Parse();\n\n    foreach (var kvp in graph.Where(node => node.Key.StartsWith('t')))\n    {\n        foreach (var neighbour in kvp.Value)\n        {\n            var intersect = graph[neighbour].Intersect(kvp.Value);\n            foreach (var n in intersect)\n            {\n                string[] res = [kvp.Key, n, neighbour];\n                string[] ordered = [.. res.Order()];\n                trios.Add((ordered[0], ordered[1], ordered[2]));\n            }\n        }\n    }\n    return trios.Count;\n}\n\nprivate Dictionary<string, List<string>> Parse()\n{\n    Dictionary<string, List<string>> graph = [];\n\n    var splitLine = Input.Select(x => x.Split('-'));\n    foreach (var split in splitLine)\n    {\n        if (!graph.TryGetValue(split[0], out var neighbours))\n            graph[split[0]] = [split[1]];\n        else\n            graph[split[0]].Add(split[1]);\n\n        if (!graph.TryGetValue(split[1], out neighbours))\n            graph[split[1]] = [split[0]];\n        else\n            graph[split[1]].Add(split[0]);\n    }\n    return graph;\n}\n"))),"\n",i.createElement(n.h2,null,"Part Two"),"\n",i.createElement(n.p,null,"Finding a maximal clique is a considerably bigger ",i.createElement("a",{href:"https://en.wikipedia.org/wiki/Clique_problem"},"problem"),' than part 1. It screamed "hey, this is probably ',i.createElement("a",{href:"https://en.wikipedia.org/wiki/NP-hardness"},"NP-Hard"),'", which in turn means I was unlikely to find a great solution just by thinking extra hard.'),"\n",i.createElement("br"),"\n",i.createElement(n.p,null,"I chose to use the ",i.createElement("a",{href:"https://en.wikipedia.org/wiki/Bron–Kerbosch_algorithm"},"Bron–Kerbosch")," algorithm , and specifically the second variant that includes a pivot node;\nthis graph of computers is dense, and the pivot approach is effective for that type\nof problem."),"\n",i.createElement(n.p,null,i.createElement("br"),"I won't flail around explaining a well-known and thoroughly understood\nalgorithm like Bron-Kerbosch, I'll just say that it's pretty straight-forward to\nimplement, and nice and quick for this problem."),"\n",i.createElement(t,{boxname:"two",names:"typescript|C#"},i.createElement(n.pre,null,i.createElement(n.code,{className:"language-js"},"export function partTwo(input: string[]): number | string {\n  const graph = parse(input)\n  const cliques: string[] = []\n\n  bronKerbosch(\n    new Set<string>(),\n    new Set([...graph.keys()]),\n    new Set<string>(),\n    graph,\n    cliques\n  )\n  return cliques.reduce((longest, current) =>\n    current.length > longest.length ? current : longest\n  )\n}\n\nfunction bronKerbosch(\n  r: Set<string>,\n  p: Set<string>,\n  x: Set<string>,\n  graph: Map<string, string[]>,\n  cliques: string[]\n) {\n  if (p.size == 0 && x.size == 0) {\n    cliques.push([...r].sort().join(','))\n    return\n  }\n  const pivot = [...p.union(x)].reduce(\n    (max, current) =>\n      graph.get(current)!.length > (graph.get(max)?.length ?? 0)\n        ? current\n        : max,\n    ''\n  )\n  const pc: Set<string> = new Set(\n    [...p].filter((x) => !graph.get(pivot)!.includes(x))\n  )\n\n  pc.forEach((node) => {\n    const neighbourSet = new Set(graph.get(node)!)\n    bronKerbosch(\n      new Set([...r, node]),\n      p.intersection(neighbourSet),\n      x.intersection(neighbourSet),\n      graph,\n      cliques\n    )\n    p.delete(node)\n    x.add(node)\n  })\n}\n")),i.createElement(n.pre,null,i.createElement(n.code,{className:"language-csharp"},'public override object PartTwo()\n{\n    Dictionary<string, List<string>> graph = Parse();\n    List<string> cliques = [];\n\n    BronKerbosch2([], [.. graph.Keys], [], graph, cliques);\n\n    return cliques.MaxBy(x => x.Length) ?? "";\n}\n\nstatic void BronKerbosch2(HashSet<string> R, HashSet<string> P, HashSet<string> X, Dictionary<string, List<string>> G, List<string> O)\n{\n    if (P.Count == 0 && X.Count == 0)\n    {\n        O.Add(string.Join(",", R.Order()));\n        return;\n    }\n    var pivot = P.Union(X).MaxBy(c => G[c].Count)!;\n    HashSet<string> PC = [.. P.Except(G[pivot])];\n\n    foreach (var node in PC)\n    {\n        BronKerbosch2([.. R.Union([node])], [.. P.Intersect(G[node])], [.. X.Intersect(G[node])], G, O);\n        P.Remove(node);\n        X.Add(node);\n    }\n}\n\n'))))}var s=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,r.RP)(),e.components);return n?i.createElement(n,e,i.createElement(a,e)):a(e)};var o=t(2779),l=t(7206),c=t(791),p=t(4813),h=t(572);const g={CodeBox:o.A};function u(e){let{pageContext:n,children:t}=e;return i.createElement(i.Fragment,null,i.createElement(p.A,null),i.createElement("div",{className:"min-h-screen bg-chicPrimary"},i.createElement(c.A,{props:n.list}),i.createElement("div",{className:"adventofcode max-w-[60%] ml-[20%]"},i.createElement("h1",null,i.createElement("a",{href:"https://adventofcode.com/"+n.year+"/day/"+n.puzz},n.year+" Day "+n.puzz+" - "+n.title)),i.createElement(r.xA,{components:g},t),n.puzz&&n.year?i.createElement(l.A,{year:n.year,puzz:n.puzz}):i.createElement(i.Fragment,null))),i.createElement(h.A,null))}function m(e){return i.createElement(u,e,i.createElement(s,e))}const d=()=>i.createElement(i.Fragment,null,i.createElement("title",null,"Joel-Allan-NZ - Advent of Code"),i.createElement("html",{lang:"en"}),i.createElement("link",{rel:"preconnect",href:"https://fonts.googleapis.com"}),i.createElement("link",{rel:"preconnect",href:"https://fonts.gstatic.com"}),i.createElement("link",{href:"https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&family=VT323&display=swap",rel:"stylesheet"}))}}]);
//# sourceMappingURL=component---src-components-layout-tsx-content-file-path-days-2024-23-mdx-ae4c57fea70df78e590f.js.map