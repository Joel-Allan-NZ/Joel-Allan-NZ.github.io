"use strict";(self.webpackChunkjoel_allan_nz_github_io=self.webpackChunkjoel_allan_nz_github_io||[]).push([[9158],{596:function(e,n,t){t.r(n),t.d(n,{Head:function(){return g},default:function(){return m}});var s=t(8453),a=t(6540);function r(e){const n=Object.assign({h2:"h2",p:"p",a:"a",pre:"pre",code:"code",em:"em"},(0,s.RP)(),e.components),{CodeBox:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("CodeBox",!0),a.createElement(a.Fragment,null,a.createElement(n.h2,null,"Part One"),"\n",a.createElement(n.p,null,"A nice and easy part one; traverse points in the grid within the range of a step target (64) and then count how many you could end on. For an even number of steps you can finish on any even distance. Nothing fancy, just a simple ",a.createElement(n.a,{href:"https://en.wikipedia.org/wiki/Breadth-first_search"},"bfs.")),"\n",a.createElement(t,{names:"typescript|C#"},a.createElement(n.pre,null,a.createElement(n.code,{className:"language-ts"},"export function partOne(input: string[]): number | string {\n  const distances = findAccessiblePlots(\n    Math.floor(input[0].length / 2),\n    Math.floor(input.length / 2),\n    input,\n    64\n  )\n  return distances\n    .values()\n    .filter((x) => x % 2 == 0)\n    .toArray().length\n}\n\nfunction findAccessiblePlots(\n  startX: number,\n  startY: number,\n  input: string[],\n  stepTarget: number\n): Map<string, number> {\n  const distances = new Map<string, number>()\n  distances.set(startX + ',' + startY, 0)\n  const positions = [[startX, startY]]\n  const steps = [\n    [0, 1],\n    [0, -1],\n    [1, 0],\n    [-1, 0],\n  ]\n\n  let pos = 0\n  while (positions.length > 0) {\n    let current = positions.shift()!\n    pos++\n    console.log(pos)\n    const currentDistance = distances.get(current.join(','))!\n    if (currentDistance >= stepTarget) continue\n\n    for (let step of steps) {\n      const next = [current[0] + step[0], current[1] + step[1]]\n      if (next.some((x) => x < 0 || x >= input.length)) continue\n\n      if (input[next[1]][next[0]] != '#') {\n        const nextString = next.join(',')\n        const existing = distances.get(nextString)\n        if (!existing || existing > currentDistance + 1) {\n          distances.set(nextString, currentDistance + 1)\n          positions.push(next)\n        }\n      }\n    }\n  }\n\n  return distances\n}\n")),a.createElement(n.pre,null,a.createElement(n.code,{className:"language-csharp"},'public override object PartOne()\n{\n    var distances = FindAccessiblePlots(Input[0].Length / 2, Input.Length / 2, Input, 64);\n    return distances.Values.Count(x => x % 2 == 0);\n}\n\nprivate static Dictionary<string, int> FindAccessiblePlots(int startX, int startY, string[] input, long stepTarget)\n{\n    Dictionary<string, int> distances = [];\n    distances[startX + "," + startY] = 0;\n    Queue<(int x, int y)> positions = [];\n    positions.Enqueue((startX, startY));\n    int[][] steps = [[0, 1], [0, -1], [1, 0], [-1, 0]];\n\n    while (positions.Count > 0)\n    {\n        var (x, y) = positions.Dequeue();\n        var currentDistance = distances[x + "," + y];\n        if (currentDistance > stepTarget - 1)\n            continue;\n\n        foreach (var step in steps)\n        {\n            var next = (x: x + step[0], y: y + step[1]);\n            if (next.x < 0 || next.y < 0 || next.x >= input[0].Length || next.y >= input.Length)\n                continue;\n\n            if (input[next.y][next.x] != \'#\')\n            {\n                var nextString = next.x + "," + next.y;\n                if (!distances.TryGetValue(nextString, out var existing) || existing > currentDistance + 1)\n                {\n                    distances[nextString] = currentDistance + 1;\n                    positions.Enqueue(next);\n                }\n            }\n        }\n    }\n    return distances;\n}\n'))),"\n",a.createElement(n.h2,null,"Part Two"),"\n",a.createElement(n.p,null,"I feel like 21 is consistently one of the hardest puzzle days of the year, and this is no exception."),"\n",a.createElement("br"),"\n",a.createElement(n.p,null,"My first thought was simply to naively check the number of accessible points in the\nsame manner as part 1, albeit with judicious use of the ",a.createElement(n.code,null,"%")," operator to have coords\ncheck the correct areas, without having to actually manually tesselate the input\nspace. Unsurprisingly, this was faaaar too slow to be useful, so I was forced to\nlook for other approaches."),"\n",a.createElement("br"),"\n",a.createElement(n.p,null,"My next idea was to check the distances of all points in the input, and extrapolate\nout how many times each of those points (and their tesselated equivalents) could\nbe reached within the maximum step size. This required a lot of tedious number crunching\nbased on distances from the start and edge... until I actually looked at the input."),"\n",a.createElement("br"),"\n",a.createElement(n.p,null,"The input has three very distinct features. Firstly, the start location is precisely\nin the center. Secondly, there is a distinct diamond shape that correlates very evenly\nwith half of the size of the input (ie the points in the diamond shape are equivalent\n",a.createElement(n.a,{href:"https://en.wikipedia.org/wiki/Taxicab_geometry"},"manhattan distances")," from the start),\nand thirdly, there are perfect straight lines of empty space above, below, and to\neither side of the start. These three features allow for some shortcuts: we know\nthe maximum distance we can travel in any direction is exactly equivalent to the\ntarget step count, and therefore the tesselations in any given direction will be\nexactly eqiuvalent to ",a.createElement(n.code,null,"(stepTarget - 0.5*input.Length)/input.Length"),". We also know\nthat the diagonal sections represent the same manhattan distance from the start as\nthe directly vertical/horizontal edges, so the furthest points we can ever travel\nto will be within that diagonal distance - the total area we can travel within is\nalso shaped like a diamond! Finally, the size of the input space is odd, which, along\nwith our centered start location, means the odd-distance points in one input-sized\nspace have even-distances in adjacent tesselations."),"\n",a.createElement("br"),"\n",a.createElement(n.p,null,"With all of that in mind, we can calculate the accessible points geometrically -\nthe first input size can be treated as 'odd', the tesselations at cardinal directions\nfrom that are 'even', then 'odd'... and so on. As our number of tesselations in any\ncardinal direction are even, the outer most tesselation in those directions will\nbe odd. Therefore we need to cut off the outside corners of every odd external-edge\ntesselation, and also ",a.createElement(n.em,null,"add")," an internal corner from every even external-edge tesselation.\nFinally, we can do the actual calculations:"),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-js"},"let total =\n  (tesselations + 1) ** 2 * oddAccessible +\n  tesselations ** 2 * evenAccessible -\n  (tesselations + 1) * oddCorners +\n  tesselations * evenCorners\n")),"\n",a.createElement("br"),"\n",a.createElement(n.p,null,"Find that hard to follow? I don't blame you!"),"\n",a.createElement(t,{names:"typescript|C#"},a.createElement(n.pre,null,a.createElement(n.code,{className:"language-ts"},"export function partTwo(input: string[]): number | string {\n  const distances = findAccessiblePlots(\n    Math.floor(input[0].length / 2),\n    Math.floor(input.length / 2),\n    input,\n    input.length\n  )\n  return calculateAccessible(input, distances, 26501365)\n}\n\nfunction calculateAccessible(\n  input: string[],\n  distances: Map<string, number>,\n  steps: number\n): number {\n  const oddCorners = distances\n    .values()\n    .reduce(\n      (total, current) =>\n        current % 2 == 1 && current > 65 ? total + 1 : total,\n      0\n    )\n  const evenCorners = distances\n    .values()\n    .reduce(\n      (total, current) =>\n        current % 2 == 0 && current > 65 ? total + 1 : total,\n      0\n    )\n\n  const even = distances\n    .values()\n    .reduce((total, current) => (current % 2 == 0 ? total + 1 : total), 0)\n  const odd = distances\n    .values()\n    .reduce((total, current) => (current % 2 == 1 ? total + 1 : total), 0)\n\n  const tesselations = (steps - Math.floor(input.length / 2)) / input.length\n\n  const totalTiles =\n    (tesselations + 1) ** 2 * odd +\n    tesselations ** 2 * even -\n    (tesselations + 1) * oddCorners +\n    tesselations * evenCorners\n\n  return totalTiles\n}\n")),a.createElement(n.pre,null,a.createElement(n.code,{className:"language-csharp"},"public override object PartTwo()\n{\n    var distances = FindAccessiblePlots(Input[0].Length / 2, Input.Length / 2, Input, Input.Length);\n    return CalculateAccessible(Input, distances, 26501365);\n}\n\nprivate static double CalculateAccessible(string[] input, Dictionary<string, int> distances, int steps)\n{\n    var oddCorners = distances.Values.Count(x => x % 2 == 1 && x > 65);\n    var evenCorners = distances.Values.Count(x => x % 2 == 0 && x > 65);\n\n    var odd = distances.Values.Count(x => x % 2 == 1);\n    var even = distances.Values.Count(x => x % 2 == 0);\n\n    var tesselations = (steps - (input.Length / 2)) / input.Length;\n\n    var totalTiles = (Math.Pow(tesselations + 1, 2) * odd) + (Math.Pow(tesselations, 2) * even) - ((tesselations + 1) * oddCorners) + (tesselations * evenCorners);\n    return totalTiles;\n}\n"))))}var i=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,s.RP)(),e.components);return n?a.createElement(n,e,a.createElement(r,e)):r(e)};var o=t(2779),l=t(7206),c=t(791),u=t(4813),d=t(572);const p={CodeBox:o.A};function h(e){let{pageContext:n,children:t}=e;return a.createElement(a.Fragment,null,a.createElement(u.A,null),a.createElement("div",{className:"min-h-screen bg-chicPrimary"},a.createElement(c.A,{props:n.list}),a.createElement("div",{className:"adventofcode max-w-[60%] ml-[20%]"},a.createElement("h1",null,a.createElement("a",{href:"https://adventofcode.com/"+n.year+"/day/"+n.puzz},n.year+" Day "+n.puzz+" - "+n.title)),a.createElement(s.xA,{components:p},t),n.puzz&&n.year?a.createElement(l.A,{year:n.year,puzz:n.puzz}):a.createElement(a.Fragment,null))),a.createElement(d.A,null))}function m(e){return a.createElement(h,e,a.createElement(i,e))}const g=()=>a.createElement(a.Fragment,null,a.createElement("title",null,"Joel-Allan-NZ - Advent of Code"),a.createElement("html",{lang:"en"}),a.createElement("link",{rel:"preconnect",href:"https://fonts.googleapis.com"}),a.createElement("link",{rel:"preconnect",href:"https://fonts.gstatic.com"}),a.createElement("link",{href:"https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&family=VT323&display=swap",rel:"stylesheet"}))}}]);
//# sourceMappingURL=component---src-components-layout-tsx-content-file-path-days-2023-21-mdx-505d6a787cdefb5d83eb.js.map