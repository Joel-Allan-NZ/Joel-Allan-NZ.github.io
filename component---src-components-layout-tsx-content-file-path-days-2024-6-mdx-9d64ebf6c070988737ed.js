"use strict";(self.webpackChunkjoel_allan_nz_github_io=self.webpackChunkjoel_allan_nz_github_io||[]).push([[9006],{2180:function(e,n,t){t.r(n),t.d(n,{Head:function(){return h},default:function(){return g}});var r=t(8453),i=t(6540);function a(e){const n=Object.assign({h2:"h2",p:"p",ul:"ul",li:"li",em:"em",pre:"pre",code:"code",ol:"ol"},(0,r.RP)(),e.components),{CodeBox:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("CodeBox",!0),i.createElement(i.Fragment,null,i.createElement(n.h2,null,"Part One"),"\n",i.createElement(n.p,null,"Quite straightforward, but relatively messy to model. My approach is simple: record the positions of all obstacles in the input, then at each step:"),"\n",i.createElement(n.ul,null,"\n",i.createElement(n.li,null,"Try to find the next obstacle in the direction the guard is facing"),"\n",i.createElement(n.li,null,"If it exists, then handle that obstacle by recording the coordinates of all points between the current location and that obstacle, moving the guard to just before that obstacle, and rotating the guard's facing."),"\n",i.createElement(n.li,null,"If the obstacle doesn't exist, then uniquely record the coordinates of all points between the current location and that obstacle"),"\n",i.createElement(n.li,null,"Update your position to just before that obstacle, and rotate your facing."),"\n",i.createElement(n.li,null,"If that obstacle ",i.createElement(n.em,null,"doesn't")," exist, then the guard is leaving the mapped area. To record the coordinates involved, I treat the edge of the map as the last obstacle, and record as normal."),"\n",i.createElement(n.li,null,"Finally, the number of unique recorded coordinates is equivalent to the number of spaces the guard will travel in his routine."),"\n"),"\n",i.createElement("br"),"\n",i.createElement(n.p,null,"Sooner or later I'll get around to improving the typescript solution/making it more\nidiomatic... currently it's a translation of the C# solution, but without any of\nthe C# niceties. It performs well, but it could certainly be easier to read."),"\n",i.createElement(t,{names:"typescript|C#"},i.createElement(n.pre,null,i.createElement(n.code,{className:"language-js"},"interface Position {\n  x: number\n  y: number\n  facing: string\n}\n\nexport function partOne(input: string[]): number | string {\n  const { graph, reverse, guard } = parseInput(input)\n  const positions = simulateGuard(\n    graph,\n    reverse,\n    guard,\n    input[0].length,\n    input.length\n  )\n  return positions.values().reduce((total, current) => total + current.size, 0)\n}\n\nfunction simulateGuard(\n  graph: Map<number, Set<number>>,\n  reverse: Map<number, Set<number>>,\n  position: Position,\n  xMax: number,\n  yMax: number\n): Map<number, Set<number>> {\n  const visited = new Map<number, Set<number>>()\n  let next = nextObstacle(graph, reverse, position)\n  while (next) {\n    addVisitedRange(visited, position, next)\n    position = next\n    next = nextObstacle(graph, reverse, position)\n  }\n  addVisitedRange(visited, position, nextEdge(position, xMax, yMax)!)\n  return visited\n}\n\nfunction nextEdge(pos: Position, x: number, y: number): Position | undefined {\n  switch (pos.facing) {\n    case 'UP':\n      return { x: pos.x, y: 0, facing: 'UP' }\n    case 'RIGHT':\n      return { x: x - 1, y: pos.y, facing: 'UP' }\n    case 'DOWN':\n      return { x: pos.x, y: y - 1, facing: 'UP' }\n    case 'LEFT':\n      return { x: 0, y: pos.y, facing: 'UP' }\n  }\n}\n\nfunction addVisitedRange(\n  visited: Map<number, Set<number>>,\n  start: Position,\n  next: Position\n) {\n  if (start.facing == 'UP') {\n    const range = new Set<number>(rangeSet(next.y, start.y))\n    const current = visited.get(start.x)\n    visited.set(start.x, current ? current.union(range) : range)\n  } else if (start.facing == 'RIGHT') {\n    rangeSet(start.x, next.x).forEach((x) => {\n      if (!visited.has(x)) visited.set(x, new Set<number>([start.y]))\n      else visited.get(x)!.add(start.y)\n    })\n  } else if (start.facing == 'DOWN') {\n    const range = new Set<number>(rangeSet(start.y, next.y))\n    const current = visited.get(start.x)\n    visited.set(start.x, current ? current.union(range) : range)\n  } else {\n    rangeSet(next.x, start.x).forEach((x) => {\n      if (!visited.has(x)) visited.set(x, new Set<number>([start.y]))\n      else visited.get(x)!.add(start.y)\n    })\n  }\n}\n\nfunction rangeSet(lower: number, higher: number) {\n  return Array(higher - lower + 1)\n    .keys()\n    .map((x) => x + lower)\n}\n\nfunction nextObstacle(\n  graph: Map<number, Set<number>>,\n  reverse: Map<number, Set<number>>,\n  position: Position\n): Position | undefined {\n  let nextCoord = nextObstacleCoord(graph, reverse, position)!\n  if ([2 ** 31, -1].includes(nextCoord)) return undefined\n\n  switch (position.facing) {\n    case 'UP':\n      return { x: position.x, y: nextCoord + 1, facing: 'RIGHT' }\n    case 'RIGHT':\n      return { x: nextCoord - 1, y: position.y, facing: 'DOWN' }\n    case 'DOWN':\n      return { x: position.x, y: nextCoord - 1, facing: 'LEFT' }\n    case 'LEFT':\n      return { x: nextCoord + 1, y: position.y, facing: 'UP' }\n  }\n}\n\nfunction nextObstacleCoord(\n  graph: Map<number, Set<number>>,\n  reverse: Map<number, Set<number>>,\n  position: Position\n): number | undefined {\n  switch (position.facing) {\n    case 'UP':\n      return maxLessThan(reverse.get(position.x)!, position.y)\n    case 'RIGHT':\n      return minGreaterThan(graph.get(position.y)!, position.x)\n    case 'DOWN':\n      return minGreaterThan(reverse.get(position.x)!, position.y)\n    case 'LEFT':\n      return maxLessThan(graph.get(position.y)!, position.x)\n  }\n}\n\nfunction minGreaterThan(vals: Set<number>, greaterThan: number): number {\n  let min = 2 ** 31\n  vals.forEach((value) => {\n    if (value > greaterThan) min = min > value ? value : min\n  })\n  return min\n}\n\nfunction maxLessThan(vals: Set<number>, lesserThan: number): number {\n  let max = -1\n  vals.forEach((value) => {\n    if (value < lesserThan) max = max < value ? value : max\n  })\n  return max\n}\n\nfunction parseInput(input: string[]): {\n  graph: Map<number, Set<number>>\n  reverse: Map<number, Set<number>>\n  guard: Position\n} {\n  const graph = new Map<number, Set<number>>()\n  const reverse = new Map<number, Set<number>>()\n  const guard = { x: 0, y: 0, facing: 'UP' }\n\n  input.forEach((line, y) => {\n    const row = new Set<number>()\n    graph.set(y, row)\n\n    line.split('').forEach((c, x) => {\n      if (!reverse.has(x)) {\n        reverse.set(x, new Set<number>())\n      }\n      if (c == '#') {\n        row.add(x)\n        reverse.get(x)!.add(y)\n      } else if (c == '^') {\n        guard.x = x\n        guard.y = y\n      }\n    })\n  })\n  return { graph, reverse, guard }\n}\n")),i.createElement(n.pre,null,i.createElement(n.code,{className:"language-csharp"},"public override object PartOne()\n{\n    var (obstacles, reverseLookup, guardX, guardY) = ParseObstacles();\n\n    return SimulateGuardMovement(obstacles, reverseLookup, (guardX, guardY, 0), Input[0].Length, Input.Length).Count;\n}\n\nprivate static HashSet<(int, int)> SimulateGuardMovement(Dictionary<int, HashSet<int>> obstacles, Dictionary<int, HashSet<int>> reverse, (int x, int y, int facing) position, int xSize, int ySize)\n{\n    HashSet<(int, int)> visited = [];\n\n    while (TryGetNextObstacle(obstacles, reverse, position, out var next))\n    {\n        foreach (var pos in EnumerateTilesBetweenObstacles(position, next))\n            visited.Add(pos);\n        position = next;\n    }\n    var last = position.facing switch\n    {\n        0 => (position.x, 0, 0),\n        1 => (xSize - 1, position.y, 1),\n        2 => (position.x, ySize - 1, 2),\n        3 => (0, position.y, 3),\n        _ => throw new NotImplementedException()\n    };\n    foreach (var pos in EnumerateTilesBetweenObstacles(position, last))\n        visited.Add(pos);\n\n    return visited;\n}\n\nprivate static IEnumerable<(int, int)> EnumerateTilesBetweenObstacles((int x, int y, int facing) current, (int x, int y, int facing) next) => current.facing switch\n{\n    0 => Enumerable.Range(next.y, current.y - next.y + 1).Select(y => (current.x, y)),\n    1 => Enumerable.Range(current.x, next.x - current.x + 1).Select(x => (x, current.y)),\n    2 => Enumerable.Range(current.y, next.y - current.y + 1).Select(y => (current.x, y)),\n    3 => Enumerable.Range(next.x, current.x - next.x + 1).Select(x => (x, current.y)),\n    _ => throw new NotImplementedException()\n};\n\nprivate (Dictionary<int, HashSet<int>> obstacles, Dictionary<int, HashSet<int>> reverseLookup, int x, int y) ParseObstacles()\n{\n    Dictionary<int, HashSet<int>> obstacles = [];\n    Dictionary<int, HashSet<int>> reverseLookup = [];\n\n    var (guardX, guardY) = (0, 0);\n\n    for (int y = 0; y < Input.Length; y++)\n    {\n        HashSet<int> row = [];\n        obstacles[y] = row;\n        for (int x = 0; x < Input[y].Length; x++)\n        {\n            if (!reverseLookup.TryGetValue(x, out var col))\n            {\n                col = [];\n                reverseLookup[x] = col;\n            }\n            if (Input[y][x] == '#')\n            {\n                col.Add(y);\n                row.Add(x);\n            }\n            else if (Input[y][x] == '^')\n                (guardX, guardY) = (x, y);\n        }\n    }\n    return (obstacles, reverseLookup, guardX, guardY);\n}\n"))),"\n",i.createElement(n.h2,null,"Part Two"),"\n",i.createElement(n.p,null,"A clear (and welcome) difficulty increase from day 5, but there's a long way to go before we hit hard problems."),"\n",i.createElement("br"),"\n",i.createElement(n.p,null,"This problem is trivially brute-forceable by testing the addition of an obstacle\nat each point in the map, but I made two small optimizations:"),"\n",i.createElement(n.ol,null,"\n",i.createElement(n.li,null,"We only consider adding obstacles to the points in the guard's path from part one - recalculating the path is much cheaper than testing every position."),"\n",i.createElement(n.li,null,"We use a reverse lookup table to efficiently find the next obstacle"),"\n"),"\n",i.createElement(n.p,null,"The original bruteforce solution took a few seconds to run, before applying those basic optimizations. I considered reworking the solution to a model based on edges rather than coordinates (ie each obstacle has a node on each of its four sides that are in the valid area, and those nodes each have a single outgoing edge to the next obstacle the guard would reach), but further optimization seemed unnecessary; it's already effectively instant on my machine."),"\n",i.createElement(t,{names:"typescript|C#"},i.createElement(n.pre,null,i.createElement(n.code,{className:"language-js"},"export function partTwo(input: string[]): number | string {\n  const { graph, reverse, guard } = parseInput(input)\n  const positions = simulateGuard(\n    graph,\n    reverse,\n    guard,\n    input[0].length,\n    input.length\n  )\n  positions.get(guard.x)!.delete(guard.y)\n\n  return positions.keys().reduce((total, current) => {\n    return (\n      total +\n      positions\n        .get(current)!\n        .values()\n        .reduce((subtotal, c) => {\n          graph.get(c)?.add(current)\n          reverse.get(current)?.add(c)\n          let result = isLoop(graph, reverse, guard)\n          reverse.get(current)?.delete(c)\n          graph.get(c)?.delete(current)\n\n          return result ? subtotal + 1 : subtotal\n        }, 0)\n    )\n  }, 0)\n}\n\nfunction isLoop(\n  graph: Map<number, Set<number>>,\n  reverse: Map<number, Set<number>>,\n  position: Position\n): boolean {\n  const visited = new Map<number, Map<number, string[]>>()\n\n  let next = nextObstacle(graph, reverse, position)\n  while (next) {\n    if (visited.get(position.x)?.get(position.y)?.includes(position.facing)) {\n      return true\n    }\n    if (!visited.has(position.x))\n      visited.set(position.x, new Map<number, string[]>())\n    else if (!visited.get(position.x)?.has(position.y))\n      visited.get(position.x)!.set(position.y, [])\n\n    visited.get(position.x)?.get(position.y)?.push(position.facing)\n    position = next\n    next = nextObstacle(graph, reverse, position)\n  }\n  return false\n}\n")),i.createElement(n.pre,null,i.createElement(n.code,{className:"language-csharp"},"public override object PartTwo()\n{\n    var (obstacles, reverseLookup, guardX, guardY) = ParseObstacles();\n\n    var positions = SimulateGuardMovement(obstacles, reverseLookup, (guardX, guardY, 0), Input[0].Length, Input.Length);\n    positions.Remove((guardX, guardY));\n\n    return positions.Count(position =>\n    {\n        obstacles[position.Item2].Add(position.Item1);\n        reverseLookup[position.Item1].Add(position.Item2);\n\n        var result = CheckIfLoopCreated(obstacles, reverseLookup, (guardX, guardY, 0));\n\n        obstacles[position.Item2].Remove(position.Item1);\n        reverseLookup[position.Item1].Remove(position.Item2);\n\n        return result;\n    });\n}\n\n\nprivate static bool CheckIfLoopCreated(Dictionary<int, HashSet<int>> obstacles, Dictionary<int, HashSet<int>> reverse, (int x, int y, int facing) position)\n{\n    HashSet<(int, int, int)> visited = [];\n    while (TryGetNextObstacle(obstacles, reverse, position, out var next))\n    {\n        if (visited.Contains(position))\n            return true;\n        visited.Add(position);\n        position = next;\n    }\n    return false;\n}\n\nprivate static bool TryGetNextObstacle(Dictionary<int, HashSet<int>> obstacles, Dictionary<int, HashSet<int>> reverse, (int x, int y, int facing) obstacle, out (int x, int y, int facing) result)\n{\n    result = (-1, -1, -1);\n    var nextCoordinate = obstacle.facing switch\n    {\n        0 => reverse[obstacle.x].Max(y => y < obstacle.y ? y : int.MinValue),\n        1 => obstacles[obstacle.y].Min(x => x > obstacle.x ? x : int.MaxValue),\n        2 => reverse[obstacle.x].Min(y => y > obstacle.y ? y : int.MaxValue),\n        3 => obstacles[obstacle.y].Max(x => x < obstacle.x ? x : int.MinValue),\n        _ => int.MinValue\n    };\n\n    if (nextCoordinate == int.MinValue || nextCoordinate == int.MaxValue)\n        return false;\n\n    result = obstacle.facing switch\n    {\n        0 => (obstacle.x, nextCoordinate + 1, 1),\n        1 => (nextCoordinate - 1, obstacle.y, 2),\n        2 => (obstacle.x, nextCoordinate - 1, 3),\n        3 => (nextCoordinate + 1, obstacle.y, 0),\n        _ => (-1, -1, -1)\n    };\n\n    return true;\n}\n"))))}var o=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,r.RP)(),e.components);return n?i.createElement(n,e,i.createElement(a,e)):a(e)};var s=t(2779),l=t(7206),u=t(791),c=t(4813),p=t(572);const d={CodeBox:s.A};function m(e){let{pageContext:n,children:t}=e;return i.createElement(i.Fragment,null,i.createElement(c.A,null),i.createElement("div",{className:"min-h-screen bg-chicPrimary"},i.createElement(u.A,{props:n.list}),i.createElement("div",{className:"adventofcode max-w-[60%] ml-[20%]"},i.createElement("h1",null,i.createElement("a",{href:"https://adventofcode.com/"+n.year+"/day/"+n.puzz},n.year+" Day "+n.puzz+" - "+n.title)),i.createElement(r.xA,{components:d},t),n.puzz&&n.year?i.createElement(l.A,{year:n.year,puzz:n.puzz}):i.createElement(i.Fragment,null))),i.createElement(p.A,null))}function g(e){return i.createElement(m,e,i.createElement(o,e))}const h=()=>i.createElement(i.Fragment,null,i.createElement("title",null,"Joel-Allan-NZ - Advent of Code"),i.createElement("html",{lang:"en"}),i.createElement("link",{rel:"preconnect",href:"https://fonts.googleapis.com"}),i.createElement("link",{rel:"preconnect",href:"https://fonts.gstatic.com"}),i.createElement("link",{href:"https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&family=VT323&display=swap",rel:"stylesheet"}))}}]);
//# sourceMappingURL=component---src-components-layout-tsx-content-file-path-days-2024-6-mdx-9d64ebf6c070988737ed.js.map