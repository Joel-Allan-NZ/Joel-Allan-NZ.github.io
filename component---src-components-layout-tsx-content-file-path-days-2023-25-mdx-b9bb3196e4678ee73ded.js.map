{"version":3,"file":"component---src-components-layout-tsx-content-file-path-days-2023-25-mdx-b9bb3196e4678ee73ded.js","mappings":"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","sources":["webpack://joel-allan-nz.github.io/./days/2023/25.mdx","webpack://joel-allan-nz.github.io/./src/components/Layout.tsx"],"sourcesContent":["/*@jsxRuntime classic @jsx React.createElement @jsxFrag React.Fragment*/\nimport {useMDXComponents as _provideComponents} from \"@mdx-js/react\";\nimport React from \"react\";\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    p: \"p\",\n    a: \"a\",\n    em: \"em\",\n    pre: \"pre\",\n    code: \"code\"\n  }, _provideComponents(), props.components), {CodeBox} = _components;\n  if (!CodeBox) _missingMdxReference(\"CodeBox\", true);\n  return React.createElement(React.Fragment, null, React.createElement(_components.h2, null, \"Part One\"), \"\\n\", React.createElement(_components.p, null, \"The idea here is that we need to find a \", React.createElement(_components.a, {\n    href: \"https://en.wikipedia.org/wiki/Minimum_cut\"\n  }, \"min cut\"), \" of the input, such that with exactly 3 cuts we have two disjoint sets.\"), \"\\n\", React.createElement(\"br\"), \"\\n\", React.createElement(_components.p, null, \"Purely for the novelty of it, I opted to use \", React.createElement(_components.a, {\n    href: \"https://en.wikipedia.org/wiki/Karger%27s_algorithm\"\n  }, \"Karger's algorithm\"), \",\\nwhich is non-deterministic! The implemented solution will run infinitely until a\\nvalid cut is found, and depending on your luck this could be instant or take several\\nseconds.\"), \"\\n\", React.createElement(\"br\"), \"\\n\", React.createElement(_components.p, null, \"It breaks my general rule of fast and reliable solutions, but I can't remember the\\nlast time I had a chance to acutally \", React.createElement(_components.em, null, \"use\"), \" a non-deterministic algorithm. It's day\\n25, I'm going to live a little.\"), \"\\n\", React.createElement(CodeBox, {\n    names: \"typescript|C#\"\n  }, React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-ts\"\n  }, \"export function partOne(input: string[]): number | string {\\n  const graph = new Map<string, Map<string, number>>()\\n  for (let line of input) {\\n    const split = line.split(' ')\\n    const a = split[0].slice(0, 3)\\n\\n    if (!graph.has(a)) graph.set(a, new Map<string, number>())\\n\\n    for (let add of split.slice(1)) {\\n      if (!graph.has(add)) graph.set(add, new Map<string, number>())\\n\\n      graph.get(a)!.set(add, 1)\\n      graph.get(add)!.set(a, 1)\\n    }\\n  }\\n\\n  while (true) {\\n    const copy = new Map<string, Map<string, number>>()\\n    graph.keys().forEach((key) => {\\n      copy.set(key, new Map<string, number>())\\n      graph\\n        .get(key)!\\n        .entries()\\n        .forEach((v) => copy.get(key)!.set(v[0], v[1]))\\n    })\\n    const count = karger(copy)\\n    const entries = copy.entries().toArray()\\n\\n    if (entries[0][1].get(entries[1][0]) == 3) {\\n      return count.get(entries[0][0])! * count.get(entries[1][0])!\\n    }\\n  }\\n}\\n\\nfunction karger(graph: Map<string, Map<string, number>>): Map<string, number> {\\n  const count = new Map<string, number>()\\n  graph.keys().forEach((key) => count.set(key, 1))\\n\\n  while (graph.size > 2) {\\n    const edge = getRandomEdge(graph)\\n    merge(graph, edge)\\n    const newCount = count.get(edge[0])! + count.get(edge[1])!\\n    count.set(edge[0], newCount)\\n  }\\n  return count\\n}\\n\\nfunction getRandomEdge(graph: Map<string, Map<string, number>>): string[] {\\n  const u = graph.keys().toArray()[Math.floor(Math.random() * graph.size)]\\n  const vSize = graph.get(u)!.size\\n  const v = graph.get(u)!.keys().toArray()[Math.floor(Math.random() * vSize)]\\n\\n  return [u, v]\\n}\\n\\nfunction merge(graph: Map<string, Map<string, number>>, edge: string[]): void {\\n  const vEdges = graph.get(edge[1])!.entries().toArray()\\n\\n  for (let e of vEdges) {\\n    if (e[0] != edge[0]) {\\n      let uDistance = graph.get(edge[0])?.get(e[0])\\n      uDistance ??= 0\\n      graph.get(edge[0])?.set(e[0], e[1] + uDistance)\\n\\n      graph.get(e[0])?.set(edge[0], graph.get(edge[0])!.get(e[0])!)\\n    }\\n    graph.get(e[0])?.delete(edge[1])\\n  }\\n\\n  graph.get(edge[0])?.delete(edge[1])\\n  graph.delete(edge[1])\\n}\\n\")), React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-csharp\"\n  }, \"public override object PartOne()\\n{\\n    Dictionary<string, Dictionary<string, int>> adjacent = [];\\n\\n    foreach (var line in Input)\\n    {\\n        var split = line.Split(\\\" \\\");\\n        if (!adjacent.ContainsKey(split[0][0..3]))\\n            adjacent[split[0][0..3]] = [];\\n\\n        foreach (var add in split[1..])\\n        {\\n            if (!adjacent.ContainsKey(add))\\n                adjacent[add] = [];\\n\\n            adjacent[split[0][0..3]].Add(add, 1);\\n            adjacent[add].Add(split[0][0..3], 1);\\n        }\\n    }\\n\\n    return KargerMinCut(adjacent);\\n}\\n\\nprivate static int KargerMinCut(Dictionary<string, Dictionary<string, int>> graph)\\n{\\n    Random rand = new();\\n\\n    while (true)\\n    {\\n        var copyGraph = graph.ToDictionary(entry => entry.Key, value => value.Value.ToDictionary(x => x.Key, y => y.Value));\\n        var count = Karger(copyGraph, rand);\\n        if (copyGraph.First().Value[copyGraph.Last().Key] == 3)\\n            return count[copyGraph.First().Key] * count[copyGraph.Last().Key];\\n    }\\n}\\n\\nprivate static Dictionary<string, int> Karger(Dictionary<string, Dictionary<string, int>> graph, Random rand)\\n{\\n    Dictionary<string, int> count = [];\\n    foreach (var key in graph.Keys)\\n    {\\n        count[key] = 1;\\n    }\\n\\n    while (graph.Count > 2)\\n    {\\n        var (u, v) = GetRandomEdge(graph, rand);\\n        Merge(graph, u, v);\\n        count[u] += count[v];\\n    }\\n    return count;\\n\\n}\\n\\nprivate static (string, string) GetRandomEdge(Dictionary<string, Dictionary<string, int>> graph, Random rand)\\n{\\n    var u = graph.Keys.ElementAt(rand.Next(graph.Count));\\n    var v = graph[u].ElementAt(rand.Next(graph[u].Count));\\n    return (u, v.Key);\\n}\\n\\nprivate static void Merge(Dictionary<string, Dictionary<string, int>> graph, string edge, string v)\\n{\\n    foreach (var e in graph[v].ToList())\\n    {\\n        if (e.Key != edge)\\n        {\\n            if (graph[edge].ContainsKey(e.Key))\\n                graph[edge][e.Key] += e.Value;\\n            else\\n                graph[edge][e.Key] = e.Value;\\n\\n            graph[e.Key][edge] = graph[edge][e.Key];\\n\\n        }\\n        graph[e.Key].Remove(v);\\n    }\\n    graph[edge].Remove(v);\\n    graph.Remove(v);\\n}\\n\"))), \"\\n\", React.createElement(_components.h2, null, \"Part Two\"), \"\\n\", React.createElement(_components.p, null, \"Part two of Christmas Day is always a free star â­\"), \"\\n\", React.createElement(\"br\"));\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? React.createElement(MDXLayout, props, React.createElement(_createMdxContent, props)) : _createMdxContent(props);\n}\nexport default MDXContent;\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","import GATSBY_COMPILED_MDX from \"/home/joel/personal/advent-of-code/joel-allan-nz.github.io/days/2023/25.mdx\";\nimport React from 'react';\nimport {MDXProvider} from '@mdx-js/react';\nimport CodeBox from './CodeBox';\nimport TryYourself from './TryYourself';\nimport AdventSideNav from './AdventSideNav';\nimport Header from './Header';\nimport Footer from './Footer';\nconst shortcodes = {\n  CodeBox\n};\nfunction Layout(_ref) {\n  let {pageContext, children} = _ref;\n  return React.createElement(React.Fragment, null, React.createElement(Header, null), React.createElement(\"div\", {\n    className: \"min-h-screen bg-chicPrimary\"\n  }, React.createElement(AdventSideNav, {\n    props: pageContext.list\n  }), React.createElement(\"div\", {\n    className: \"adventofcode max-w-[60%] ml-[20%]\"\n  }, React.createElement(\"h1\", null, React.createElement(\"a\", {\n    href: \"https://adventofcode.com/\" + pageContext.year + \"/day/\" + pageContext.puzz\n  }, pageContext.year + \" Day \" + pageContext.puzz + \" - \" + pageContext.title)), React.createElement(MDXProvider, {\n    components: shortcodes\n  }, children), pageContext.puzz && pageContext.year ? React.createElement(TryYourself, {\n    year: pageContext.year,\n    puzz: pageContext.puzz\n  }) : React.createElement(React.Fragment, null))), React.createElement(Footer, null));\n}\nexport default function GatsbyMDXWrapper(props) {\n  return React.createElement(Layout, props, React.createElement(GATSBY_COMPILED_MDX, props));\n}\nexport const Head = () => React.createElement(React.Fragment, null, React.createElement(\"title\", null, \"Joel-Allan-NZ - Advent of Code\"), React.createElement(\"html\", {\n  lang: \"en\"\n}), React.createElement(\"link\", {\n  rel: \"preconnect\",\n  href: \"https://fonts.googleapis.com\"\n}), React.createElement(\"link\", {\n  rel: \"preconnect\",\n  href: \"https://fonts.gstatic.com\"\n}), React.createElement(\"link\", {\n  href: \"https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&family=VT323&display=swap\",\n  rel: \"stylesheet\"\n}));\n"],"names":["_createMdxContent","props","_components","Object","assign","h2","p","a","em","pre","code","_provideComponents","components","CodeBox","id","component","Error","_missingMdxReference","React","href","names","className","wrapper","MDXLayout","shortcodes","Layout","_ref","pageContext","children","Header","AdventSideNav","list","year","puzz","title","MDXProvider","TryYourself","Footer","GatsbyMDXWrapper","GATSBY_COMPILED_MDX","Head","lang","rel"],"sourceRoot":""}