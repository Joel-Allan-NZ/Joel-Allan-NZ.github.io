"use strict";(self.webpackChunkjoel_allan_nz_github_io=self.webpackChunkjoel_allan_nz_github_io||[]).push([[9152],{4144:function(n,t,e){e.r(t),e.d(t,{Head:function(){return y},default:function(){return g}});var a=e(8453),r=e(6540);function l(n){const t=Object.assign({h2:"h2",p:"p",pre:"pre",code:"code"},(0,a.RP)(),n.components),{CodeBox:e}=t;return e||function(n,t){throw new Error("Expected "+(t?"component":"object")+" `"+n+"` to be defined: you likely forgot to import, pass, or provide it.")}("CodeBox",!0),r.createElement(r.Fragment,null,r.createElement(t.h2,null,"Part One"),"\n",r.createElement(t.p,null,"The solution here is a victim of being reworked to suit part 2, but the core idea is to walk down each line of the input, finding each number in turn and immediately checking the area around them for a symbol. No real algorithmic thinking here, just dotting Is and crossing Ts"),"\n",r.createElement(e,{names:"typescript|C#"},r.createElement(t.pre,null,r.createElement(t.code,{className:"language-js"},"export function partOne(input: string[]): number | string {\n  let sum = 0\n  input.forEach((line, y) => {\n    for (let x = 0; x < line.length; x++) {\n      let partialResult = isPartialNumber(input, x, y)\n      if (partialResult) {\n        sum += partialResult.value\n        x += partialResult.length\n      }\n    }\n  })\n  return sum\n}\n\ninterface PartialNumber {\n  length: number\n  value: number\n  adjacentSymbols: { coords: number[]; value: string }[]\n}\n\nfunction isPartialNumber(\n  input: string[],\n  x: number,\n  y: number\n): PartialNumber | undefined {\n  let partialString = ''\n\n  while (x < input[y].length && !isNaN(parseInt(input[y][x]))) {\n    partialString += input[y][x]\n    x++\n  }\n\n  if (partialString.length > 0) {\n    const adjacentSymbols = findAdjacentSymbols(\n      input,\n      x - partialString.length,\n      x - 1,\n      y\n    )\n    if (adjacentSymbols.length > 0)\n      return {\n        length: partialString.length - 1,\n        value: parseInt(partialString),\n        adjacentSymbols,\n      }\n  }\n  return undefined\n}\n\nfunction findAdjacentSymbols(\n  input: string[],\n  xStart: number,\n  xEnd: number,\n  y: number\n): { coords: number[]; value: string }[] {\n  const symbols: { coords: number[]; value: string }[] = []\n\n  for (let v = y - 1; v < y + 2; v++) {\n    for (let x = xStart - 1; x < xEnd + 2; x++) {\n      if (v < 0 || x < 0 || v >= input.length || x >= input[v].length) continue\n      if (input[v][x] != '.' && isNaN(parseInt(input[v][x])))\n        symbols.push({ coords: [x, v], value: input[v][x] })\n    }\n  }\n  return symbols\n}\n")),r.createElement(t.pre,null,r.createElement(t.code,{className:"language-csharp"},"public override object PartOne()\n{\n    var sum = 0;\n    for (int y = 0; y < Input.Length; y++)\n    {\n        for (int x = 0; x < Input[y].Length; x++)\n        {\n            if (IsPartialNumber(Input, x, y, out var partial, out int length, out _))\n                sum += partial;\n            x += length;\n        }\n    }\n    return sum;\n}\n\nprivate static bool IsPartialNumber(string[] input, int x, int y, out int partial, out int length, out List<(int x, int y, char c)> adjacentSymbols)\n{\n    bool valid = false;\n    partial = 0;\n    var partialString = \"\";\n    adjacentSymbols = [];\n\n    while (x < input[y].Length && int.TryParse(input[y][x].ToString(), out var res))\n    {\n        partialString += res;\n        x++;\n    }\n\n    if (partialString.Length > 0)\n    {\n        adjacentSymbols = FindAdjacentSymbols(input, x - partialString.Length, x - 1, y);\n        if (adjacentSymbols.Count > 0)\n        {\n            valid = true;\n            partial = int.Parse(partialString);\n        }\n    }\n    length = partialString.Length > 0 ? partialString.Length - 1 : 0;\n    return valid;\n}\n\nprivate static List<(int x, int y, char c)> FindAdjacentSymbols(string[] input, int xStart, int xEnd, int y)\n{\n    List<(int x, int y, char c)> symbols = [];\n    for (int v = y - 1; v < y + 2; v++)\n    {\n        for (int x = xStart - 1; x < xEnd + 2; x++)\n        {\n            if (v < 0 || x < 0 || v >= input.Length || x >= input[v].Length)\n                continue;\n\n            if (input[v][x] != '.' && !int.TryParse(input[v][x].ToString(), out _))\n                symbols.Add((x, v, input[v][x]));\n        }\n    }\n    return symbols;\n}\n"))),"\n",r.createElement(t.h2,null,"Part Two"),"\n",r.createElement(t.p,null,"Same deal as part one, but additionally group the partial numbers by adjacent symbols. For each * symbol, if there are two adjacent numbers then add the product of those two."),"\n",r.createElement(e,{names:"typescript|C#"},r.createElement(t.pre,null,r.createElement(t.code,{className:"language-ts"},"export function partTwo(input: string[]): number | string {\n  const partialsByGear = new Map<number, number[]>()\n\n  input.forEach((line, y) => {\n    for (let x = 0; x < line.length; x++) {\n      const partial = isPartialNumber(input, x, y)\n      if (partial) {\n        partial.adjacentSymbols.forEach((adjacent) => {\n          if (adjacent.value == '*') {\n            let coord = adjacent.coords[0] * 100000 + adjacent.coords[1]\n            if (!partialsByGear.has(coord))\n              partialsByGear.set(coord, [partial.value])\n            else partialsByGear.get(coord)?.push(partial.value)\n          }\n        })\n        x += partial.length\n      }\n    }\n  })\n\n  return partialsByGear\n    .values()\n    .reduce(\n      (total, current) =>\n        current.length == 2 ? total + current[0] * current[1] : total,\n      0\n    )\n}\n")),r.createElement(t.pre,null,r.createElement(t.code,{className:"language-csharp"},"public override object PartTwo()\n{\n    Dictionary<(int x, int y), List<int>> partialsByGear = [];\n\n    for (int y = 0; y < Input.Length; y++)\n    {\n        for (int x = 0; x < Input[y].Length; x++)\n        {\n            if (IsPartialNumber(Input, x, y, out var partial, out int length, out var adjacent))\n            {\n                foreach (var adj in adjacent)\n                {\n                    if (adj.c == '*')\n                    {\n                        if (partialsByGear.TryGetValue((adj.x, adj.y), out var partials))\n                            partials.Add(partial);\n                        else\n                            partialsByGear[(adj.x, adj.y)] = [partial];\n                    }\n                }\n\n            }\n            x += length;\n        }\n    }\n    return partialsByGear.Sum(x => x.Value.Count != 2 ? 0 : x.Value[0] * x.Value[1]);\n}\n"))))}var i=function(n){void 0===n&&(n={});const{wrapper:t}=Object.assign({},(0,a.RP)(),n.components);return t?r.createElement(t,n,r.createElement(l,n)):l(n)};var o=e(2779),u=e(7206),s=e(791),c=e(4813),p=e(572);const m={CodeBox:o.A};function d(n){let{pageContext:t,children:e}=n;return r.createElement(r.Fragment,null,r.createElement(c.A,null),r.createElement("div",{className:"min-h-screen bg-chicPrimary"},r.createElement(s.A,{props:t.list}),r.createElement("div",{className:"adventofcode max-w-[60%] ml-[20%]"},r.createElement("h1",null,r.createElement("a",{href:"https://adventofcode.com/"+t.year+"/day/"+t.puzz},t.year+" Day "+t.puzz+" - "+t.title)),r.createElement(a.xA,{components:m},e),t.puzz&&t.year?r.createElement(u.A,{year:t.year,puzz:t.puzz}):r.createElement(r.Fragment,null))),r.createElement(p.A,null))}function g(n){return r.createElement(d,n,r.createElement(i,n))}const y=()=>r.createElement(r.Fragment,null,r.createElement("title",null,"Joel-Allan-NZ - Advent of Code"),r.createElement("html",{lang:"en"}),r.createElement("link",{rel:"preconnect",href:"https://fonts.googleapis.com"}),r.createElement("link",{rel:"preconnect",href:"https://fonts.gstatic.com"}),r.createElement("link",{href:"https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&family=VT323&display=swap",rel:"stylesheet"}))}}]);
//# sourceMappingURL=component---src-components-layout-tsx-content-file-path-days-2023-3-mdx-8f45d3353a462444bbd0.js.map