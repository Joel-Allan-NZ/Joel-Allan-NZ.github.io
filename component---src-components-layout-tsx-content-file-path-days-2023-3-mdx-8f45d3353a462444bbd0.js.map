{"version":3,"file":"component---src-components-layout-tsx-content-file-path-days-2023-3-mdx-8f45d3353a462444bbd0.js","mappings":"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","sources":["webpack://joel-allan-nz.github.io/./days/2023/3.mdx","webpack://joel-allan-nz.github.io/./src/components/Layout.tsx"],"sourcesContent":["/*@jsxRuntime classic @jsx React.createElement @jsxFrag React.Fragment*/\nimport {useMDXComponents as _provideComponents} from \"@mdx-js/react\";\nimport React from \"react\";\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    p: \"p\",\n    pre: \"pre\",\n    code: \"code\"\n  }, _provideComponents(), props.components), {CodeBox} = _components;\n  if (!CodeBox) _missingMdxReference(\"CodeBox\", true);\n  return React.createElement(React.Fragment, null, React.createElement(_components.h2, null, \"Part One\"), \"\\n\", React.createElement(_components.p, null, \"The solution here is a victim of being reworked to suit part 2, but the core idea is to walk down each line of the input, finding each number in turn and immediately checking the area around them for a symbol. No real algorithmic thinking here, just dotting Is and crossing Ts\"), \"\\n\", React.createElement(CodeBox, {\n    names: \"typescript|C#\"\n  }, React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-js\"\n  }, \"export function partOne(input: string[]): number | string {\\n  let sum = 0\\n  input.forEach((line, y) => {\\n    for (let x = 0; x < line.length; x++) {\\n      let partialResult = isPartialNumber(input, x, y)\\n      if (partialResult) {\\n        sum += partialResult.value\\n        x += partialResult.length\\n      }\\n    }\\n  })\\n  return sum\\n}\\n\\ninterface PartialNumber {\\n  length: number\\n  value: number\\n  adjacentSymbols: { coords: number[]; value: string }[]\\n}\\n\\nfunction isPartialNumber(\\n  input: string[],\\n  x: number,\\n  y: number\\n): PartialNumber | undefined {\\n  let partialString = ''\\n\\n  while (x < input[y].length && !isNaN(parseInt(input[y][x]))) {\\n    partialString += input[y][x]\\n    x++\\n  }\\n\\n  if (partialString.length > 0) {\\n    const adjacentSymbols = findAdjacentSymbols(\\n      input,\\n      x - partialString.length,\\n      x - 1,\\n      y\\n    )\\n    if (adjacentSymbols.length > 0)\\n      return {\\n        length: partialString.length - 1,\\n        value: parseInt(partialString),\\n        adjacentSymbols,\\n      }\\n  }\\n  return undefined\\n}\\n\\nfunction findAdjacentSymbols(\\n  input: string[],\\n  xStart: number,\\n  xEnd: number,\\n  y: number\\n): { coords: number[]; value: string }[] {\\n  const symbols: { coords: number[]; value: string }[] = []\\n\\n  for (let v = y - 1; v < y + 2; v++) {\\n    for (let x = xStart - 1; x < xEnd + 2; x++) {\\n      if (v < 0 || x < 0 || v >= input.length || x >= input[v].length) continue\\n      if (input[v][x] != '.' && isNaN(parseInt(input[v][x])))\\n        symbols.push({ coords: [x, v], value: input[v][x] })\\n    }\\n  }\\n  return symbols\\n}\\n\")), React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-csharp\"\n  }, \"public override object PartOne()\\n{\\n    var sum = 0;\\n    for (int y = 0; y < Input.Length; y++)\\n    {\\n        for (int x = 0; x < Input[y].Length; x++)\\n        {\\n            if (IsPartialNumber(Input, x, y, out var partial, out int length, out _))\\n                sum += partial;\\n            x += length;\\n        }\\n    }\\n    return sum;\\n}\\n\\nprivate static bool IsPartialNumber(string[] input, int x, int y, out int partial, out int length, out List<(int x, int y, char c)> adjacentSymbols)\\n{\\n    bool valid = false;\\n    partial = 0;\\n    var partialString = \\\"\\\";\\n    adjacentSymbols = [];\\n\\n    while (x < input[y].Length && int.TryParse(input[y][x].ToString(), out var res))\\n    {\\n        partialString += res;\\n        x++;\\n    }\\n\\n    if (partialString.Length > 0)\\n    {\\n        adjacentSymbols = FindAdjacentSymbols(input, x - partialString.Length, x - 1, y);\\n        if (adjacentSymbols.Count > 0)\\n        {\\n            valid = true;\\n            partial = int.Parse(partialString);\\n        }\\n    }\\n    length = partialString.Length > 0 ? partialString.Length - 1 : 0;\\n    return valid;\\n}\\n\\nprivate static List<(int x, int y, char c)> FindAdjacentSymbols(string[] input, int xStart, int xEnd, int y)\\n{\\n    List<(int x, int y, char c)> symbols = [];\\n    for (int v = y - 1; v < y + 2; v++)\\n    {\\n        for (int x = xStart - 1; x < xEnd + 2; x++)\\n        {\\n            if (v < 0 || x < 0 || v >= input.Length || x >= input[v].Length)\\n                continue;\\n\\n            if (input[v][x] != '.' && !int.TryParse(input[v][x].ToString(), out _))\\n                symbols.Add((x, v, input[v][x]));\\n        }\\n    }\\n    return symbols;\\n}\\n\"))), \"\\n\", React.createElement(_components.h2, null, \"Part Two\"), \"\\n\", React.createElement(_components.p, null, \"Same deal as part one, but additionally group the partial numbers by adjacent symbols. For each * symbol, if there are two adjacent numbers then add the product of those two.\"), \"\\n\", React.createElement(CodeBox, {\n    names: \"typescript|C#\"\n  }, React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-ts\"\n  }, \"export function partTwo(input: string[]): number | string {\\n  const partialsByGear = new Map<number, number[]>()\\n\\n  input.forEach((line, y) => {\\n    for (let x = 0; x < line.length; x++) {\\n      const partial = isPartialNumber(input, x, y)\\n      if (partial) {\\n        partial.adjacentSymbols.forEach((adjacent) => {\\n          if (adjacent.value == '*') {\\n            let coord = adjacent.coords[0] * 100000 + adjacent.coords[1]\\n            if (!partialsByGear.has(coord))\\n              partialsByGear.set(coord, [partial.value])\\n            else partialsByGear.get(coord)?.push(partial.value)\\n          }\\n        })\\n        x += partial.length\\n      }\\n    }\\n  })\\n\\n  return partialsByGear\\n    .values()\\n    .reduce(\\n      (total, current) =>\\n        current.length == 2 ? total + current[0] * current[1] : total,\\n      0\\n    )\\n}\\n\")), React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-csharp\"\n  }, \"public override object PartTwo()\\n{\\n    Dictionary<(int x, int y), List<int>> partialsByGear = [];\\n\\n    for (int y = 0; y < Input.Length; y++)\\n    {\\n        for (int x = 0; x < Input[y].Length; x++)\\n        {\\n            if (IsPartialNumber(Input, x, y, out var partial, out int length, out var adjacent))\\n            {\\n                foreach (var adj in adjacent)\\n                {\\n                    if (adj.c == '*')\\n                    {\\n                        if (partialsByGear.TryGetValue((adj.x, adj.y), out var partials))\\n                            partials.Add(partial);\\n                        else\\n                            partialsByGear[(adj.x, adj.y)] = [partial];\\n                    }\\n                }\\n\\n            }\\n            x += length;\\n        }\\n    }\\n    return partialsByGear.Sum(x => x.Value.Count != 2 ? 0 : x.Value[0] * x.Value[1]);\\n}\\n\"))));\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? React.createElement(MDXLayout, props, React.createElement(_createMdxContent, props)) : _createMdxContent(props);\n}\nexport default MDXContent;\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","import GATSBY_COMPILED_MDX from \"/home/joel/personal/advent-of-code/joel-allan-nz.github.io/days/2023/3.mdx\";\nimport React from 'react';\nimport {MDXProvider} from '@mdx-js/react';\nimport CodeBox from './CodeBox';\nimport TryYourself from './TryYourself';\nimport AdventSideNav from './AdventSideNav';\nimport Header from './Header';\nimport Footer from './Footer';\nconst shortcodes = {\n  CodeBox\n};\nfunction Layout(_ref) {\n  let {pageContext, children} = _ref;\n  return React.createElement(React.Fragment, null, React.createElement(Header, null), React.createElement(\"div\", {\n    className: \"min-h-screen bg-chicPrimary\"\n  }, React.createElement(AdventSideNav, {\n    props: pageContext.list\n  }), React.createElement(\"div\", {\n    className: \"adventofcode max-w-[60%] ml-[20%]\"\n  }, React.createElement(\"h1\", null, React.createElement(\"a\", {\n    href: \"https://adventofcode.com/\" + pageContext.year + \"/day/\" + pageContext.puzz\n  }, pageContext.year + \" Day \" + pageContext.puzz + \" - \" + pageContext.title)), React.createElement(MDXProvider, {\n    components: shortcodes\n  }, children), pageContext.puzz && pageContext.year ? React.createElement(TryYourself, {\n    year: pageContext.year,\n    puzz: pageContext.puzz\n  }) : React.createElement(React.Fragment, null))), React.createElement(Footer, null));\n}\nexport default function GatsbyMDXWrapper(props) {\n  return React.createElement(Layout, props, React.createElement(GATSBY_COMPILED_MDX, props));\n}\nexport const Head = () => React.createElement(React.Fragment, null, React.createElement(\"title\", null, \"Joel-Allan-NZ - Advent of Code\"), React.createElement(\"html\", {\n  lang: \"en\"\n}), React.createElement(\"link\", {\n  rel: \"preconnect\",\n  href: \"https://fonts.googleapis.com\"\n}), React.createElement(\"link\", {\n  rel: \"preconnect\",\n  href: \"https://fonts.gstatic.com\"\n}), React.createElement(\"link\", {\n  href: \"https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&family=VT323&display=swap\",\n  rel: \"stylesheet\"\n}));\n"],"names":["_createMdxContent","props","_components","Object","assign","h2","p","pre","code","_provideComponents","components","CodeBox","id","component","Error","_missingMdxReference","React","names","className","wrapper","MDXLayout","shortcodes","Layout","_ref","pageContext","children","Header","AdventSideNav","list","href","year","puzz","title","MDXProvider","TryYourself","Footer","GatsbyMDXWrapper","GATSBY_COMPILED_MDX","Head","lang","rel"],"sourceRoot":""}