{"version":3,"file":"component---src-components-layout-tsx-content-file-path-days-2024-20-mdx-b05f0fc99baf5fa34184.js","mappings":"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","sources":["webpack://joel-allan-nz.github.io/./days/2024/20.mdx","webpack://joel-allan-nz.github.io/./src/components/Layout.tsx"],"sourcesContent":["/*@jsxRuntime classic @jsx React.createElement @jsxFrag React.Fragment*/\nimport {useMDXComponents as _provideComponents} from \"@mdx-js/react\";\nimport React from \"react\";\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    p: \"p\",\n    pre: \"pre\",\n    code: \"code\",\n    em: \"em\"\n  }, _provideComponents(), props.components), {CodeBox} = _components;\n  if (!CodeBox) _missingMdxReference(\"CodeBox\", true);\n  return React.createElement(React.Fragment, null, React.createElement(_components.h2, null, \"Part One\"), \"\\n\", React.createElement(_components.p, null, \"This feels like the 40th \", React.createElement(\"a\", {\n    href: \"https://en.wikipedia.org/wiki/Breadth-first_search\"\n  }, \"BFS\"), \" / budget \", React.createElement(\"a\", {\n    href: \"https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm\"\n  }, \"djikstra\"), \" in only 20 days.\"), \"\\n\", React.createElement(\"br\"), \"\\n\", React.createElement(_components.p, null, \"My approach here is simple: find the shortest path distance to every node in the\\ngraph, then look for nodes at most two nodes apart (ie with at most one wall tile\\nbetween them) with a distance between their shortest paths greater than or equal\\nto our 100 target. Each of those pairs represents a valid cheat pair, so just count\\n'em up.\"), \"\\n\", React.createElement(CodeBox, {\n    boxname: \"one\",\n    names: \"typescript|C#\"\n  }, React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-js\"\n  }, \"export function partOne(input: string[]): number | string {\\n  const { graph, start } = parse(input)\\n  findMinimumDistances(graph, start)\\n  const distance = 2,\\n    target = 100\\n  let count = 0\\n\\n  for (let y = 0; y < graph.length; y++) {\\n    for (let x = 0; x < graph[y].length; x++) {\\n      if (graph[y][x].value != '#')\\n        count += neighboursWithinManhattanDistance(\\n          graph,\\n          graph[y][x],\\n          distance,\\n          target\\n        )\\n    }\\n  }\\n  return count\\n}\\n\\ninterface DistanceAwareNode {\\n  value: string\\n  distance: number\\n  x: number\\n  y: number\\n}\\n\\nfunction parse(input: string[]): {\\n  graph: DistanceAwareNode[][]\\n  start: DistanceAwareNode\\n} {\\n  const graph: DistanceAwareNode[][] = []\\n  let start: DistanceAwareNode | undefined = undefined\\n\\n  for (let y = 0; y < input.length; y++) {\\n    graph.push([])\\n    for (let x = 0; x < input[y].length; x++) {\\n      const node = {\\n        value: input[y][x],\\n        distance: input[y][x] == '#' ? 0 : 2 ** 31,\\n        x,\\n        y,\\n      }\\n      graph[y].push(node)\\n      if (input[y][x] == 'S') start = node\\n    }\\n  }\\n  return { graph, start: start! }\\n}\\n\\nfunction findMinimumDistances(\\n  graph: DistanceAwareNode[][],\\n  start: DistanceAwareNode\\n): void {\\n  const toExplore: DistanceAwareNode[] = [start]\\n  start.distance = 0\\n\\n  while (toExplore.length > 0) {\\n    const current = toExplore.shift()!\\n    const neighbours = getNeighbours(graph, current)\\n    neighbours.forEach((neighbour) => {\\n      if (neighbour.value != '#' && neighbour.distance > current.distance + 1) {\\n        toExplore.push(neighbour)\\n        neighbour.distance = current.distance + 1\\n      }\\n    })\\n  }\\n}\\n\\nfunction getNeighbours(graph: DistanceAwareNode[][], node: DistanceAwareNode) {\\n  const res: DistanceAwareNode[] = []\\n\\n  if (node.x < graph[0].length - 1) res.push(graph[node.y][node.x + 1])\\n  if (node.x > 0) res.push(graph[node.y][node.x - 1])\\n  if (node.y < graph.length - 1) res.push(graph[node.y + 1][node.x])\\n  if (node.y > 0) res.push(graph[node.y - 1][node.x])\\n\\n  return res\\n}\\n\\nfunction neighboursWithinManhattanDistance(\\n  graph: DistanceAwareNode[][],\\n  node: DistanceAwareNode,\\n  cheatDistance: number,\\n  cheatTimeGain: number\\n): number {\\n  let count = 0\\n  const yMin = Math.max(0, node.y - cheatDistance)\\n  const yMax = Math.min(graph.length - 1, node.y + cheatDistance)\\n\\n  for (let y = yMin; y <= yMax; y++) {\\n    const remainingManhattanDistance = cheatDistance - Math.abs(node.y - y)\\n    const xMin = Math.max(0, node.x - remainingManhattanDistance)\\n    const xMax = Math.min(\\n      graph[y].length - 1,\\n      node.x + remainingManhattanDistance\\n    )\\n\\n    for (let x = xMin; x <= xMax; x++) {\\n      const neighbour = graph[y][x]\\n      const manhattanDistance = Math.abs(node.x - x) + Math.abs(node.y - y)\\n\\n      if (\\n        neighbour.distance - manhattanDistance - cheatTimeGain >=\\n        node.distance\\n      )\\n        count++\\n    }\\n  }\\n  return count\\n}\\n\")), React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-csharp\"\n  }, \"public override object PartOne()\\n{\\n    var (grid, start) = Parse();\\n    FindMinimumDistances(grid, start);\\n    int distance = 2, target = 100;\\n    int count = 0;\\n\\n    for (int y = 0; y < grid.GetLength(0); y++)\\n    {\\n        for (int x = 0; x < grid.GetLength(1); x++)\\n        {\\n            if (grid[y, x].Value != '#')\\n                count += NeighboursWithinManhattanDistance(grid, grid[y, x], distance, target);\\n        }\\n    }\\n    return count;\\n}\\nprivate static int NeighboursWithinManhattanDistance(DistanceAwareNode[,] graph, DistanceAwareNode node, int cheatDistance, int targetSpeedGain)\\n{\\n    int count = 0;\\n    int yMin = Math.Max(0, node.Y - cheatDistance);\\n    int yMax = Math.Min(graph.GetLength(0) - 1, node.Y + cheatDistance);\\n\\n    for (int y = yMin; y <= yMax; y++)\\n    {\\n        var remainingDistance = cheatDistance - Math.Abs(node.Y - y);\\n        int xMin = Math.Max(0, node.X - remainingDistance);\\n        int xMax = Math.Min(graph.GetLength(1) - 1, node.X + remainingDistance);\\n\\n        for (int x = xMin; x <= xMax; x++)\\n        {\\n            var neighbour = graph[y, x];\\n            var manhattanDistance = Math.Abs(node.X - x) + Math.Abs(node.Y - y);\\n            if (neighbour.Distance - targetSpeedGain - manhattanDistance >= node.Distance)\\n                count++;\\n        }\\n    }\\n    return count;\\n}\\n\\nprivate static IEnumerable<DistanceAwareNode> GetNeighbours(DistanceAwareNode[,] graph, DistanceAwareNode node)\\n{\\n    if (node.X < graph.GetLength(1) - 1)\\n        yield return graph[node.Y, node.X + 1];\\n    if (node.X > 0)\\n        yield return graph[node.Y, node.X - 1];\\n    if (node.Y > 0)\\n        yield return graph[node.Y - 1, node.X];\\n    if (node.Y < graph.GetLength(0) - 1)\\n        yield return graph[node.Y + 1, node.X];\\n}\\n\\nprivate static void FindMinimumDistances(DistanceAwareNode[,] graph, DistanceAwareNode start)\\n{\\n    Queue<DistanceAwareNode> toExplore = [];\\n    start.Distance = 0;\\n    toExplore.Enqueue(start);\\n\\n    while (toExplore.Count > 0)\\n    {\\n        var current = toExplore.Dequeue();\\n        foreach (var neighbour in GetNeighbours(graph, current))\\n        {\\n            if (neighbour.Value == '#' || neighbour.Distance <= current.Distance + 1)\\n                continue;\\n\\n            toExplore.Enqueue(neighbour);\\n            neighbour.Distance = current.Distance + 1;\\n        }\\n    }\\n}\\n\\nprivate (DistanceAwareNode[,] graph, DistanceAwareNode start) Parse()\\n{\\n    DistanceAwareNode[,] graph = new DistanceAwareNode[Input.Length, Input[0].Length];\\n    DistanceAwareNode? start = null;\\n\\n    for (int y = 0; y < Input.Length; y++)\\n    {\\n        for (int x = 0; x < Input[y].Length; x++)\\n        {\\n            DistanceAwareNode node = new(Input[y][x], x, y);\\n            graph[y, x] = node;\\n            if (Input[y][x] == 'S')\\n                start = node;\\n        }\\n    }\\n    return (graph, start!);\\n}\\n\\ninternal class DistanceAwareNode(char c, int x, int y)\\n{\\n    internal char Value = c;\\n    internal int Distance = c == '#' ? 0 : int.MaxValue;\\n    internal int X = x;\\n    internal int Y = y;\\n}\\n\"))), \"\\n\", React.createElement(_components.h2, null, \"Part Two\"), \"\\n\", React.createElement(_components.p, null, \"I wasted a bit of time here with some confusion (I'm dumb) over the wording!\"), \"\\n\", React.createElement(\"br\"), \"\\n\", React.createElement(_components.p, null, \"The twenty picoseconds of no collision time is contiguous, and continues whether\\nor not the 'car' is still within a 'wall', and \", React.createElement(_components.em, null, \"doesn't end\"), \" when you leave a wall.\\nI mistakenly read it as the cheat terminating as soon as the car left a wall... some\\ntime wasted there for sure.\"), \"\\n\", React.createElement(\"br\"), \"\\n\", React.createElement(_components.p, null, \"My apparently terrible reading comprehension aside, this is the exact same problem\\njust on a bigger scope. As I was reusing functions for both part 1 and part 2 it's\\nhard to show what I refactored to gain some speed, but the short version is that\\nI'm using a two-dimensional array rather than my typically lazy \\\"manhattan distance\\ngraph is a dictionary\\\" approach.\"), \"\\n\", React.createElement(\"br\"), \"\\n\", React.createElement(_components.p, null, \"There's zero reason to use a repeated neighbour finding function like I'm doing,\\nyou'd be better off just storing neighbours as edges within each node... I just felt\\nlike sacrificing a tiny amount of speed for a little memory saving.\", ' '), \"\\n\", React.createElement(CodeBox, {\n    boxname: \"two\",\n    names: \"typescript|C#\"\n  }, React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-js\"\n  }, \"export function partTwo(input: string[]): number | string {\\n  const { graph, start } = parse(input)\\n  findMinimumDistances(graph, start)\\n  const distance = 20,\\n    target = 100\\n  let count = 0\\n\\n  for (let y = 0; y < graph.length; y++) {\\n    for (let x = 0; x < graph[y].length; x++) {\\n      if (graph[y][x].value != '#')\\n        count += neighboursWithinManhattanDistance(\\n          graph,\\n          graph[y][x],\\n          distance,\\n          target\\n        )\\n    }\\n  }\\n  return count\\n}\\n\")), React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-csharp\"\n  }, \"public override object PartTwo()\\n{\\n    var (grid, start) = Parse();\\n    FindMinimumDistances(grid, start);\\n    int distance = 20, target = 100;\\n    int count = 0;\\n\\n    for (int y = 0; y < grid.GetLength(0); y++)\\n    {\\n        for (int x = 0; x < grid.GetLength(1); x++)\\n        {\\n            if (grid[y, x].Value != '#')\\n                count += NeighboursWithinManhattanDistance(grid, grid[y, x], distance, target);\\n        }\\n    }\\n    return count;\\n}\\n\"))));\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? React.createElement(MDXLayout, props, React.createElement(_createMdxContent, props)) : _createMdxContent(props);\n}\nexport default MDXContent;\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","import GATSBY_COMPILED_MDX from \"/home/joel/personal/advent-of-code/joel-allan-nz.github.io/days/2024/20.mdx\";\nimport React from 'react';\nimport {MDXProvider} from '@mdx-js/react';\nimport CodeBox from './CodeBox';\nimport TryYourself from './TryYourself';\nimport AdventSideNav from './AdventSideNav';\nimport Header from './Header';\nimport Footer from './Footer';\nconst shortcodes = {\n  CodeBox\n};\nfunction Layout(_ref) {\n  let {pageContext, children} = _ref;\n  return React.createElement(React.Fragment, null, React.createElement(Header, null), React.createElement(\"div\", {\n    className: \"min-h-screen bg-chicPrimary\"\n  }, React.createElement(AdventSideNav, {\n    props: pageContext.list\n  }), React.createElement(\"div\", {\n    className: \"adventofcode max-w-[60%] ml-[20%]\"\n  }, React.createElement(\"h1\", null, React.createElement(\"a\", {\n    href: \"https://adventofcode.com/\" + pageContext.year + \"/day/\" + pageContext.puzz\n  }, pageContext.year + \" Day \" + pageContext.puzz + \" - \" + pageContext.title)), React.createElement(MDXProvider, {\n    components: shortcodes\n  }, children), pageContext.puzz && pageContext.year ? React.createElement(TryYourself, {\n    year: pageContext.year,\n    puzz: pageContext.puzz\n  }) : React.createElement(React.Fragment, null))), React.createElement(Footer, null));\n}\nexport default function GatsbyMDXWrapper(props) {\n  return React.createElement(Layout, props, React.createElement(GATSBY_COMPILED_MDX, props));\n}\nexport const Head = () => React.createElement(React.Fragment, null, React.createElement(\"title\", null, \"Joel-Allan-NZ - Advent of Code\"), React.createElement(\"html\", {\n  lang: \"en\"\n}), React.createElement(\"link\", {\n  rel: \"preconnect\",\n  href: \"https://fonts.googleapis.com\"\n}), React.createElement(\"link\", {\n  rel: \"preconnect\",\n  href: \"https://fonts.gstatic.com\"\n}), React.createElement(\"link\", {\n  href: \"https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&family=VT323&display=swap\",\n  rel: \"stylesheet\"\n}));\n"],"names":["_createMdxContent","props","_components","Object","assign","h2","p","pre","code","em","_provideComponents","components","CodeBox","id","component","Error","_missingMdxReference","React","href","boxname","names","className","wrapper","MDXLayout","shortcodes","Layout","_ref","pageContext","children","Header","AdventSideNav","list","year","puzz","title","MDXProvider","TryYourself","Footer","GatsbyMDXWrapper","GATSBY_COMPILED_MDX","Head","lang","rel"],"sourceRoot":""}