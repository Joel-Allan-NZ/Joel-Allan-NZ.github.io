{"version":3,"file":"component---src-components-layout-tsx-content-file-path-days-2024-16-mdx-f5e147e484e33d01458a.js","mappings":"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","sources":["webpack://joel-allan-nz.github.io/./days/2024/16.mdx","webpack://joel-allan-nz.github.io/./src/components/Layout.tsx"],"sourcesContent":["/*@jsxRuntime classic @jsx React.createElement @jsxFrag React.Fragment*/\nimport {useMDXComponents as _provideComponents} from \"@mdx-js/react\";\nimport React from \"react\";\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    p: \"p\",\n    pre: \"pre\",\n    code: \"code\"\n  }, _provideComponents(), props.components), {CodeBox} = _components;\n  if (!CodeBox) _missingMdxReference(\"CodeBox\", true);\n  return React.createElement(React.Fragment, null, React.createElement(_components.h2, null, \"Part One\"), \"\\n\", React.createElement(_components.p, null, \"Finding a shortest path, but with a little twist of having the direction of edges be important.\"), \"\\n\", React.createElement(\"br\"), \"\\n\", React.createElement(_components.p, null, \"I feel like there are two pretty straightforward approaches to this - model the graph\\nwith 4x the nodes (one for each facing), and have edge costs that represent the cost\\nof both rotation and movement, OR the approach I opted for: \\\"directional\\\" edge allocation,\\nwhere each vertex has 4 potentially null edges; 1 for each cardinal direction. I\\nsuspect the more node/edge version would be more concise and legible, but I'm deeply\\nconditioned to avoid making graphs more complex than they need to be - a Djikstra-like\\nalgorithm's time complexity increases relative to the square of the number of vertices\\n(if you aren't using a priority queue at least).\"), \"\\n\", React.createElement(\"br\"), \"\\n\", React.createElement(_components.p, null, \"The non-expanded graph seemed small enough to avoid needing to implement a priority\\nqueue, and even with somewhat bloated code it resolves at effectively instant speeds\\n(< 30 ms) on my machine.\"), \"\\n\", React.createElement(\"br\"), \"\\n\", React.createElement(CodeBox, {\n    boxname: \"one\",\n    names: \"typescript|C#\"\n  }, React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-js\"\n  }, \"export function partOne(input: string[]): number | string {\\n  const { graph, start, end } = parse(input)\\n  findShortestPaths(graph, start)\\n  return end.shortestPaths.reduce(\\n    (min, current) => (min < current ? min : current),\\n    2 ** 31\\n  )\\n}\\n\\ninterface FacingNode {\\n  c: string\\n  edges: (FacingNode | null)[]\\n  x: number\\n  y: number\\n  shortestPaths: number[]\\n}\\n\\nfunction parse(input: string[]): {\\n  graph: Map<number, Map<number, FacingNode>>\\n  start: FacingNode\\n  end: FacingNode\\n} {\\n  const graph = new Map<number, Map<number, FacingNode>>()\\n  let pathMax = 2 ** 31\\n  let end: FacingNode = {\\n    c: 'a',\\n    edges: [],\\n    x: 1,\\n    y: 1,\\n    shortestPaths: [pathMax, pathMax, pathMax, pathMax],\\n  }\\n  let start: FacingNode = {\\n    c: 'a',\\n    edges: [],\\n    x: 1,\\n    y: 1,\\n    shortestPaths: [1000, 0, 1000, 2000],\\n  }\\n\\n  input.forEach((line, y) => {\\n    line.split('').forEach((c, x) => {\\n      if (c != '#') {\\n        let node: FacingNode = {\\n          c,\\n          edges: [null, null, null, null],\\n          x,\\n          y,\\n          shortestPaths: [pathMax, pathMax, pathMax, pathMax],\\n        }\\n        if (c == 'E') end = node\\n        else if (c == 'S') {\\n          node = start\\n          start.x = x\\n          start.y = y\\n        }\\n        if (!graph.has(y)) graph.set(y, new Map<number, FacingNode>())\\n        graph.get(y)?.set(x, node)\\n        let left = graph.get(y)?.get(x - 1)\\n        if (left) {\\n          left.edges[1] = node\\n          node.edges[3] = left\\n        }\\n        let top = graph.get(y - 1)?.get(x)\\n        if (top) {\\n          node.edges[0] = top\\n          top.edges[2] = node\\n        }\\n      }\\n    })\\n  })\\n  return { graph, start, end }\\n}\\n\\nfunction findShortestPaths(\\n  graph: Map<number, Map<number, FacingNode>>,\\n  start: FacingNode\\n): void {\\n  const positions: FacingNode[] = [start]\\n  while (positions.length > 0) {\\n    let current = positions.shift()!\\n    for (let i = 0; i < 4; i++) {\\n      let neighbour = current.edges[i]\\n      if (!neighbour) continue\\n      let smaller = false\\n      const minimums = getSmallestNextValues(\\n        current?.shortestPaths,\\n        neighbour.shortestPaths,\\n        i\\n      )\\n      for (let j = 0; j < 4; j++) {\\n        if (neighbour.shortestPaths[j] > minimums[j]) {\\n          neighbour.shortestPaths[j] = minimums[j]\\n          smaller = true\\n        }\\n      }\\n      if (smaller) positions.push(neighbour)\\n    }\\n  }\\n}\\n\\nfunction getSmallestNextValues(\\n  costs: number[],\\n  nextCosts: number[],\\n  direction: number\\n) {\\n  const minimums = [2 ** 31, 2 ** 31, 2 ** 31, 2 ** 31]\\n  const directionalCosts: number[][] = [\\n    [direction, 0],\\n    [(direction + 5) % 4, 1000],\\n    [(direction + 6) % 4, 2000],\\n    [(direction + 7) % 4, 1000],\\n  ]\\n\\n  let minCost = directionalCosts.reduce((min, current) => {\\n    let currentValue = costs[current[0]] + 1 + current[1]\\n    return min < currentValue ? min : currentValue\\n  }, 2 ** 31)\\n\\n  if (minCost < nextCosts[direction]) {\\n    minimums[direction] = minCost\\n    directionalCosts.forEach((facing, cost) =>\\n      minimums[facing[0]] > minimums[direction] + facing[1]\\n        ? (minimums[facing[0]] = minimums[direction] + facing[1])\\n        : null\\n    )\\n    return minimums\\n  }\\n  return nextCosts\\n}\\n\")), React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-csharp\"\n  }, \"public override object PartOne()\\n{\\n    var graph = Parse();\\n    var shortestPaths = FindShortestPaths(graph);\\n\\n    var end = graph.Values.First(x => x.Value == 'E');\\n    return shortestPaths[end].Min();\\n}\\n\\nprivate Dictionary<(int x, int y), FacingNode> Parse()\\n{\\n    Dictionary<(int x, int y), FacingNode> dict = [];\\n\\n    for (int y = 0; y < Input.Length; y++)\\n    {\\n        for (int x = 0; x < Input[y].Length; x++)\\n        {\\n            if (Input[y][x] != '#')\\n            {\\n                var node = new FacingNode(Input[y][x], x, y);\\n                dict.Add((x, y), node);\\n                if (x > 0 && dict.TryGetValue((x - 1, y), out var left))\\n                {\\n                    left.Edges[1] = node;\\n                    node.Edges[3] = (left);\\n\\n                }\\n                if (y > 0 && dict.TryGetValue((x, y - 1), out var top))\\n                {\\n                    node.Edges[0] = top;\\n                    top.Edges[2] = node;\\n                }\\n            }\\n        }\\n    }\\n    return dict;\\n}\\n\\nprivate static Dictionary<FacingNode, int[]> FindShortestPaths(Dictionary<(int x, int y), FacingNode> graph)\\n{\\n    Queue<FacingNode> positions = [];\\n    var start = graph.Values.First(x => x.Value == 'S');\\n    Dictionary<FacingNode, int[]> shortestPaths = [];\\n    shortestPaths[start] = [1000, 0, 1000, 2000];\\n    positions.Enqueue(start);\\n\\n    while (positions.Count > 0)\\n    {\\n        var current = positions.Dequeue();\\n\\n        for (int i = 0; i < 4; i++)\\n        {\\n            var neighbour = current.Edges[i];\\n            if (neighbour == null)\\n                continue;\\n\\n            if (!shortestPaths.TryGetValue(neighbour, out var edgeCosts))\\n            {\\n                edgeCosts = [int.MaxValue, int.MaxValue, int.MaxValue, int.MaxValue];\\n                shortestPaths[neighbour] = edgeCosts;\\n            }\\n            var minimums = GetSmallestNextValues(shortestPaths[current], edgeCosts, i);\\n            bool smaller = false;\\n\\n            for (int j = 0; j < 4; j++)\\n            {\\n                if (edgeCosts[j] > minimums[j])\\n                {\\n                    edgeCosts[j] = minimums[j];\\n                    smaller = true;\\n                }\\n            }\\n            if (smaller)\\n                positions.Enqueue(neighbour);\\n        }\\n    }\\n    return shortestPaths;\\n}\\n\\nprivate static int[] GetSmallestNextValues(int[] costs, int[] nextCosts, int edgeDirection)\\n{\\n    int[] minimums = new int[4];\\n    (int facing, int rotationCost)[] directionRotationCosts = [\\n        (edgeDirection, 0),\\n        ((edgeDirection+5)%4, 1000),\\n        ((edgeDirection+6)%4, 2000),\\n        ((edgeDirection+7)%4, 1000),\\n        ];\\n\\n    var minCost = directionRotationCosts.Min(x => costs[x.facing] + x.rotationCost + 1);\\n\\n    if (minCost < nextCosts[edgeDirection])\\n    {\\n        minimums[edgeDirection] = minCost;\\n        foreach (var (facing, rotationCost) in directionRotationCosts)\\n        {\\n            minimums[facing] = Math.Min(nextCosts[facing], minimums[edgeDirection] + rotationCost);\\n        }\\n        return minimums;\\n    }\\n    return nextCosts;\\n}\\n\\ninternal class FacingNode(char c, int x, int y)\\n{\\n    internal char Value = c;\\n    internal FacingNode?[] Edges = [null, null, null, null];\\n    internal int X = x;\\n    internal int Y = y;\\n}\\n\"))), \"\\n\", React.createElement(_components.h2, null, \"Part Two\"), \"\\n\", React.createElement(_components.p, null, \"Part Two is a more clear-cut solution: run a shortest path finding algorithm that doesn't terminate on finding the target position, and then back-track along all shortest routes to find all nodes that can be part of a possible shortest path. Quick + easy.\"), \"\\n\", React.createElement(CodeBox, {\n    boxname: \"two\",\n    names: \"typescript|C#\"\n  }, React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-js\"\n  }, \"export function partTwo(input: string[]): number | string {\\n  const { graph, start, end } = parse(input)\\n  findShortestPaths(graph, start)\\n  const allPaths = findAllPaths(end)\\n  return allPaths.size\\n}\\n\\nfunction findAllPaths(end: FacingNode): Set<FacingNode> {\\n  let min = end.shortestPaths.reduce(\\n    (min, current) => (min < current ? min : current),\\n    2 ** 31\\n  )\\n  let minIndex = 0\\n  while (end.shortestPaths[minIndex] != min) minIndex++\\n  const paths = new Set<FacingNode>()\\n  paths.add(end)\\n  const process: { node: FacingNode; facing: number }[] = [\\n    { node: end, facing: minIndex },\\n  ]\\n  while (process.length > 0) {\\n    let current = process.shift()!\\n    const prior = findPriorNeighbours(current.node, current?.facing)\\n    prior.forEach((p) => {\\n      if (!paths.has(p.node)) process.push(p)\\n      paths.add(p.node)\\n    })\\n  }\\n  return paths\\n}\\n\\nfunction findPriorNeighbours(node: FacingNode, direction: number) {\\n  const directionalCosts: number[][] = [\\n    [direction, 1],\\n    [(direction + 5) % 4, 1001],\\n    [(direction + 6) % 4, 2001],\\n    [(direction + 7) % 4, 1001],\\n  ]\\n  const res: { node: FacingNode; facing: number }[] = []\\n\\n  for (let i = 0; i < 4; i++) {\\n    const edge = node.edges[directionalCosts[i][0]]\\n    const opposite = directionalCosts[(i + 6) % 4]\\n\\n    if (\\n      edge &&\\n      edge.shortestPaths[opposite[0]] ==\\n        node.shortestPaths[direction] - opposite[1]\\n    )\\n      res.push({ node: edge, facing: opposite[0] })\\n  }\\n  return res\\n}\\n\")), React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-csharp\"\n  }, \"public override object PartTwo()\\n{\\n    var graph = Parse();\\n    var shortestPaths = FindShortestPaths(graph);\\n    var allPaths = FindAllPaths(shortestPaths);\\n\\n    return allPaths.Count;\\n}\\n\\nprivate static HashSet<FacingNode> FindAllPaths(Dictionary<FacingNode, int[]> shortestPaths)\\n{\\n    var end = shortestPaths.Keys.First(x => x.Value == 'E');\\n    var min = shortestPaths[end].Min();\\n    int i = 0;\\n    while (shortestPaths[end][i] != min)\\n    {\\n        i++;\\n    }\\n    HashSet<FacingNode> paths = [];\\n    paths.Add(end);\\n\\n    Queue<(FacingNode node, int facing)> process = [];\\n    process.Enqueue((end, i));\\n    while (process.Count > 0)\\n    {\\n        var (node, facing) = process.Dequeue();\\n        foreach (var prior in FindPriorNeighbours(shortestPaths, node, facing))\\n        {\\n            if (!paths.Contains(prior.node))\\n                process.Enqueue(prior);\\n            paths.Add(prior.node);\\n        }\\n    }\\n    return paths;\\n}\\n\\nprivate static IEnumerable<(FacingNode node, int facing)> FindPriorNeighbours(Dictionary<FacingNode, int[]> shortestPaths, FacingNode node, int direction)\\n{\\n    var cost = shortestPaths[node][direction];\\n    (int facing, int rotationCost)[] directionRotationCosts = [\\n        (direction, 1),\\n        ((direction+5)%4, 1001),\\n        ((direction+6)%4, 2001),\\n        ((direction+7)%4, 1001),\\n        ];\\n\\n    for (int i = 0; i < 4; i++)\\n    {\\n        var edge = node.Edges[directionRotationCosts[i].facing];\\n        var (facing, rotationCost) = directionRotationCosts[(i + 6) % 4];\\n\\n        if (edge != null && shortestPaths[edge][facing] == cost - rotationCost)\\n            yield return (edge, facing);\\n    }\\n}\\n\"))));\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? React.createElement(MDXLayout, props, React.createElement(_createMdxContent, props)) : _createMdxContent(props);\n}\nexport default MDXContent;\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","import GATSBY_COMPILED_MDX from \"/home/joel/personal/advent-of-code/joel-allan-nz.github.io/days/2024/16.mdx\";\nimport React from 'react';\nimport {MDXProvider} from '@mdx-js/react';\nimport CodeBox from './CodeBox';\nimport TryYourself from './TryYourself';\nimport AdventSideNav from './AdventSideNav';\nimport Header from './Header';\nimport Footer from './Footer';\nconst shortcodes = {\n  CodeBox\n};\nfunction Layout(_ref) {\n  let {pageContext, children} = _ref;\n  return React.createElement(React.Fragment, null, React.createElement(Header, null), React.createElement(\"div\", {\n    className: \"min-h-screen bg-chicPrimary\"\n  }, React.createElement(AdventSideNav, {\n    props: pageContext.list\n  }), React.createElement(\"div\", {\n    className: \"adventofcode max-w-[60%] ml-[20%]\"\n  }, React.createElement(\"h1\", null, React.createElement(\"a\", {\n    href: \"https://adventofcode.com/\" + pageContext.year + \"/day/\" + pageContext.puzz\n  }, pageContext.year + \" Day \" + pageContext.puzz + \" - \" + pageContext.title)), React.createElement(MDXProvider, {\n    components: shortcodes\n  }, children), pageContext.puzz && pageContext.year ? React.createElement(TryYourself, {\n    year: pageContext.year,\n    puzz: pageContext.puzz\n  }) : React.createElement(React.Fragment, null))), React.createElement(Footer, null));\n}\nexport default function GatsbyMDXWrapper(props) {\n  return React.createElement(Layout, props, React.createElement(GATSBY_COMPILED_MDX, props));\n}\nexport const Head = () => React.createElement(React.Fragment, null, React.createElement(\"title\", null, \"Joel-Allan-NZ - Advent of Code\"), React.createElement(\"html\", {\n  lang: \"en\"\n}), React.createElement(\"link\", {\n  rel: \"preconnect\",\n  href: \"https://fonts.googleapis.com\"\n}), React.createElement(\"link\", {\n  rel: \"preconnect\",\n  href: \"https://fonts.gstatic.com\"\n}), React.createElement(\"link\", {\n  href: \"https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&family=VT323&display=swap\",\n  rel: \"stylesheet\"\n}));\n"],"names":["_createMdxContent","props","_components","Object","assign","h2","p","pre","code","_provideComponents","components","CodeBox","id","component","Error","_missingMdxReference","React","boxname","names","className","wrapper","MDXLayout","shortcodes","Layout","_ref","pageContext","children","Header","AdventSideNav","list","href","year","puzz","title","MDXProvider","TryYourself","Footer","GatsbyMDXWrapper","GATSBY_COMPILED_MDX","Head","lang","rel"],"sourceRoot":""}