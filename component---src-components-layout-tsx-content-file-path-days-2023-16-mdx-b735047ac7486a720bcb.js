"use strict";(self.webpackChunkjoel_allan_nz_github_io=self.webpackChunkjoel_allan_nz_github_io||[]).push([[620],{8726:function(e,n,t){t.r(n),t.d(n,{Head:function(){return x},default:function(){return b}});var i=t(8453),r=t(6540);function a(e){const n=Object.assign({h2:"h2",p:"p",a:"a",pre:"pre",code:"code"},(0,i.RP)(),e.components),{CodeBox:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("CodeBox",!0),r.createElement(r.Fragment,null,r.createElement(n.h2,null,"Part One"),"\n",r.createElement(n.p,null,r.createElement(n.a,{href:"https://en.wikipedia.org/wiki/Breadth-first_search"},"BFS")," with some rules about how nodes are connected. ",r.createElement("br"),"\nI opted not to manipulate the input to avoid complicating things - the BFS just walks along the cardinal directions, changing direction when required."),"\n",r.createElement(t,{names:"typescript|C#"},r.createElement(n.pre,null,r.createElement(n.code,{className:"language-ts"},"export function partOne(input: string[]): number | string {\n  return countEnergizedTiles(0, 0, 1, input)\n}\n\nfunction countEnergizedTiles(\n  x: number,\n  y: number,\n  direction: number,\n  input: string[]\n): number {\n  const energizedTiles = new Set<number>()\n  const beamed = new Set<number>()\n  const beams: number[][] = []\n\n  energizedTiles.add(x * input.length + 1 + y)\n  beamed.add(x * input.length * 10 + y * 10 + direction)\n  beams.push([x, y, direction])\n\n  while (beams.length > 0) {\n    let beam = beams.pop()!\n    for (let next of nextBeamState(beam, input)) {\n      if (\n        next[1] > -1 &&\n        next[1] < input.length &&\n        next[0] > -1 &&\n        next[0] < input[next[1]].length\n      ) {\n        const beamedNumber =\n          next[0] * input.length * 10 + next[1] * 10 + next[2]\n        if (!beamed.has(beamedNumber)) {\n          energizedTiles.add(next[0] * input.length + 1 + next[1])\n          beams.push(next)\n          beamed.add(beamedNumber)\n        }\n      }\n    }\n  }\n  return energizedTiles.size\n}\n\nfunction nextBeamPosition(beam: number[], direction: number) {\n  return [\n    beam[0] + (direction == 1 ? 1 : direction == 3 ? -1 : 0),\n    beam[1] + (direction == 0 ? -1 : direction == 2 ? 1 : 0),\n    direction,\n  ]\n}\n\nfunction nextBeamState(beam: number[], input: string[]): number[][] {\n  const currentTile = input[beam[1]][beam[0]]\n  let direction = beam[2]\n\n  if (currentTile == '|' && (direction == 1 || direction == 3)) {\n    return [nextBeamPosition(beam, 2), nextBeamPosition(beam, 0)]\n  } else if (currentTile == '-' && (direction == 0 || direction == 2)) {\n    return [nextBeamPosition(beam, 1), nextBeamPosition(beam, 3)]\n  } else if (currentTile == '/') {\n    direction = direction % 2 == 0 ? (direction + 5) % 4 : (direction + 3) % 4\n  } else if (currentTile == '\\\\') {\n    direction = direction % 2 == 0 ? (direction + 3) % 4 : (direction + 5) % 4\n  }\n  return [nextBeamPosition(beam, direction)]\n}\n")),r.createElement(n.pre,null,r.createElement(n.code,{className:"language-csharp"},"public override object PartOne()\n{\n    return CountEnergizedTiles(0, 0, 1, Input);\n}\n\nprivate static int[][] NextBeamState(int[] beam, string[] input)\n{\n    char currentTile = input[beam[1]][beam[0]];\n    var direction = beam[2];\n\n    if (currentTile == '|' && (direction == 1 || direction == 3))\n    {\n        return [NextBeamPosition(beam, 2), NextBeamPosition(beam, 0)];\n    }\n    else if (currentTile == '-' && (direction == 0 || direction == 2))\n    {\n        return [NextBeamPosition(beam, 1), NextBeamPosition(beam, 3)];\n    }\n    else if (currentTile == '/')\n    {\n        direction = direction % 2 == 0 ? (direction + 5) % 4 : (direction + 3) % 4;\n    }\n    else if (currentTile == '\\\\')\n    {\n        direction = direction % 2 == 0 ? (direction + 3) % 4 : (direction + 5) % 4;\n    }\n    return [NextBeamPosition(beam, direction)];\n}\n\nprivate static int[] NextBeamPosition(int[] beam, int direction)\n{\n    return [beam[0] + (direction == 1 ? 1 : direction == 3 ? -1 : 0), beam[1] + (direction == 0 ? -1 : direction == 2 ? 1 : 0), direction];\n}\n\nprivate static int CountEnergizedTiles(int x, int y, int direction, string[] input)\n{\n    HashSet<int> energizedTiles = [];\n    HashSet<int> beamed = [];\n    Stack<int[]> beams = [];\n\n    energizedTiles.Add(x * input.Length + 1 + y);\n    beamed.Add(x * input.Length * 10 + y * 10 + direction);\n    beams.Push([x, y, direction]);\n\n    while (beams.Count > 0)\n    {\n        var beam = beams.Pop();\n        foreach (var next in NextBeamState(beam, input))\n        {\n            if (next[1] > -1 && next[1] < input.Length && next[0] > -1 && next[0] < input[next[1]].Length)\n            {\n                int beamedNumber = next[0] * input.Length * 10 + next[1] * 10 + next[2];\n                if (!beamed.Contains(beamedNumber))\n                {\n                    energizedTiles.Add(next[0] * input.Length + 1 + next[1]);\n                    beams.Push(next);\n                    beamed.Add(beamedNumber);\n                }\n            }\n        }\n    }\n    return energizedTiles.Count;\n}\n"))),"\n",r.createElement(n.h2,null,"Part Two"),"\n",r.createElement(n.p,null,"The same thing, but more :). I played around with a few optimization approaches with various takes on memoization, but the truth is that brute-forcing it works just as quickly for me, and without adding a lot of complexity to the code (memoization is a little tricky here: beams split, which adds complexity to cycles etc)."),"\n",r.createElement(t,{names:"typescript|C#"},r.createElement(n.pre,null,r.createElement(n.code,{className:"language-ts"},"export function partTwo(input: string[]): number | string {\n  let max = 0\n\n  for (let y = 0; y < input.length; y++) {\n    let result = countEnergizedTiles(0, y, 1, input)\n    if (result > max) max = result\n    result = countEnergizedTiles(input[0].length - 1, y, 3, input)\n    if (result > max) max = result\n  }\n  for (let x = 0; x < input.length; x++) {\n    let result = countEnergizedTiles(x, 0, 2, input)\n    if (result > max) max = result\n    result = countEnergizedTiles(x, input.length - 1, 0, input)\n    if (result > max) max = result\n  }\n\n  return max\n}\n")),r.createElement(n.pre,null,r.createElement(n.code,{className:"language-csharp"},"public override object PartTwo()\n{\n    int max = 0;\n    for (int y = 0; y < Input.Length; y++)\n    {\n        var result = CountEnergizedTiles(0, y, 1, Input);\n        if (result > max)\n            max = result;\n        result = CountEnergizedTiles(Input[0].Length - 1, y, 3, Input);\n        if (result > max)\n            max = result;\n    }\n    for (int x = 0; x < Input[0].Length; x++)\n    {\n        var result = CountEnergizedTiles(x, 0, 2, Input);\n        if (result > max)\n            max = result;\n        result = CountEnergizedTiles(x, Input.Length - 1, 0, Input);\n        if (result > max)\n            max = result;\n    }\n    return max;\n}\n"))))}var o=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,i.RP)(),e.components);return n?r.createElement(n,e,r.createElement(a,e)):a(e)};var l=t(2779),c=t(7206),u=t(791),m=t(4813),s=t(572);const d={CodeBox:l.A};function p(e){let{pageContext:n,children:t}=e;return r.createElement(r.Fragment,null,r.createElement(m.A,null),r.createElement("div",{className:"min-h-screen bg-chicPrimary"},r.createElement(u.A,{props:n.list}),r.createElement("div",{className:"adventofcode max-w-[60%] ml-[20%]"},r.createElement("h1",null,r.createElement("a",{href:"https://adventofcode.com/"+n.year+"/day/"+n.puzz},n.year+" Day "+n.puzz+" - "+n.title)),r.createElement(i.xA,{components:d},t),n.puzz&&n.year?r.createElement(c.A,{year:n.year,puzz:n.puzz}):r.createElement(r.Fragment,null))),r.createElement(s.A,null))}function b(e){return r.createElement(p,e,r.createElement(o,e))}const x=()=>r.createElement(r.Fragment,null,r.createElement("title",null,"Joel-Allan-NZ - Advent of Code"),r.createElement("html",{lang:"en"}),r.createElement("link",{rel:"preconnect",href:"https://fonts.googleapis.com"}),r.createElement("link",{rel:"preconnect",href:"https://fonts.gstatic.com"}),r.createElement("link",{href:"https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&family=VT323&display=swap",rel:"stylesheet"}))}}]);
//# sourceMappingURL=component---src-components-layout-tsx-content-file-path-days-2023-16-mdx-b735047ac7486a720bcb.js.map