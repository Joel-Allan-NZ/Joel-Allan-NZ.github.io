{"version":3,"file":"component---src-components-layout-tsx-content-file-path-days-2024-8-mdx-226f2e917cd0a141325b.js","mappings":"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","sources":["webpack://joel-allan-nz.github.io/./days/2024/8.mdx","webpack://joel-allan-nz.github.io/./src/components/Layout.tsx"],"sourcesContent":["/*@jsxRuntime classic @jsx React.createElement @jsxFrag React.Fragment*/\nimport {useMDXComponents as _provideComponents} from \"@mdx-js/react\";\nimport React from \"react\";\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    p: \"p\",\n    pre: \"pre\",\n    code: \"code\"\n  }, _provideComponents(), props.components), {CodeBox} = _components;\n  if (!CodeBox) _missingMdxReference(\"CodeBox\", true);\n  return React.createElement(React.Fragment, null, React.createElement(_components.h2, null, \"Part One\"), \"\\n\", React.createElement(_components.p, null, \"The key insight is that for each pair of antenna, the antinodes must be on that same line, spaced as far apart as those two antenna. So I simply check if those points are in bounds, and record the coordinates if they are.\"), \"\\n\", React.createElement(CodeBox, {\n    names: \"typescript|C#\"\n  }, React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-js\"\n  }, \"export function partOne(input: string[]): number | string {\\n  const parsed = parse(input)\\n  const antinodes = new Map<number, Set<number>>()\\n\\n  parsed.forEach((antennaeType) => {\\n    antennaeType.forEach((antenna, index) => {\\n      antennaeType.slice(index + 1).forEach((ant, i) => {\\n        findAntinodes(antinodes, antenna, ant, input[0].length, input.length)\\n      })\\n    })\\n  })\\n  return antinodes\\n    .keys()\\n    .reduce((total, key) => total + antinodes.get(key)!.size, 0)\\n}\\n\\nfunction parse(input: string[]): Map<string, number[][]> {\\n  const result = new Map<string, number[][]>()\\n  input.forEach((line, y) => {\\n    line.split('').forEach((c, x) => {\\n      if (c != '.') {\\n        if (!result.has(c)) result.set(c, [[x, y]])\\n        else result.get(c)?.push([x, y])\\n      }\\n    })\\n  })\\n  return result\\n}\\n\\nfunction findAntinodes(\\n  antinodes: Map<number, Set<number>>,\\n  a: number[],\\n  b: number[],\\n  maxX: number,\\n  maxY: number\\n) {\\n  let xDiff = a[0] - b[0]\\n  let yDiff = a[1] - b[1]\\n\\n  ;[\\n    [a[0] + xDiff, a[1] + yDiff],\\n    [b[0] - xDiff, b[1] - yDiff],\\n  ].forEach((x) => {\\n    if (x[0] > -1 && x[0] < maxX && x[1] > -1 && x[1] < maxY) {\\n      if (!antinodes.has(x[0])) antinodes.set(x[0], new Set<number>([x[1]]))\\n      else antinodes.get(x[0])?.add(x[1])\\n    }\\n  })\\n}\\n\\n\")), React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-csharp\"\n  }, \"public override object PartOne()\\n{\\n    var antennae = ParseInput();\\n    HashSet<(int, int)> antinodes = [];\\n\\n    foreach (var antennaeType in antennae.Values)\\n    {\\n        foreach (var pair in antennaeType.UniquePairs())\\n            FindAntinodes(antinodes, pair[0], pair[1], Input[0].Length - 1, Input.Length - 1);\\n    }\\n    return antinodes.Count;\\n}\\n\\nprivate Dictionary<char, List<(int X, int Y)>> ParseInput()\\n{\\n    return Input.SelectMany((y, yIndex) => y.Select((x, index) => (key: x, X: index, Y: yIndex)))\\n                .GroupBy(x => x.key, v => (v.X, v.Y))\\n                .Where(x => x.Key != '.')\\n                .ToDictionary(k => k.Key, v => v.ToList());\\n\\n}\\n\\nprivate static void FindAntinodes(HashSet<(int, int)> antinodes, (int X, int Y) a, (int X, int Y) b, int maxX, int maxY)\\n{\\n    var xDiff = a.X - b.X;\\n    var yDiff = a.Y - b.Y;\\n\\n    (int X, int Y)[] candidates = [(a.X + xDiff, a.Y + yDiff), (b.X - xDiff, b.Y - yDiff)];\\n    foreach (var (X, Y) in candidates)\\n    {\\n        if (X >= 0 && X <= maxX && Y >= 0 && Y <= maxY)\\n        {\\n            antinodes.Add((X, Y));\\n        }\\n    }\\n}\\n\"))), \"\\n\", React.createElement(_components.h2, null, \"Part Two\"), \"\\n\", React.createElement(_components.p, null, \"Almost identical to the first part, except we must check all points on that line, rather than only those at a particular distance away from each antenna. Simple stuff\"), \"\\n\", React.createElement(CodeBox, {\n    names: \"typescript|C#\"\n  }, React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-js\"\n  }, \"export function partTwo(input: string[]): number | string {\\n  const parsed = parse(input)\\n  const antinodes = new Map<number, Set<number>>()\\n\\n  parsed.forEach((antennaeType) => {\\n    antennaeType.forEach((antenna, index) => {\\n      antennaeType.slice(index + 1).forEach((ant, i) => {\\n        findHarmonicAntinodes(\\n          antinodes,\\n          antenna,\\n          ant,\\n          input[0].length,\\n          input.length\\n        )\\n      })\\n    })\\n  })\\n  return antinodes\\n    .keys()\\n    .reduce((total, key) => total + antinodes.get(key)!.size, 0)\\n}\\n\\nfunction findHarmonicAntinodes(\\n  antinodes: Map<number, Set<number>>,\\n  a: number[],\\n  b: number[],\\n  maxX: number,\\n  maxY: number\\n) {\\n  let xDiff = a[0] - b[0]\\n  let yDiff = a[1] - b[1]\\n\\n  let x = a[0]\\n  let y = a[1]\\n\\n  while (x > -1 && x < maxX && y > -1 && y < maxY) {\\n    if (!antinodes.has(x)) antinodes.set(x, new Set<number>([y]))\\n    else antinodes.get(x)?.add(y)\\n    x = x + xDiff\\n    y = y + yDiff\\n  }\\n\\n  x = a[0]\\n  y = a[1]\\n\\n  while (x > -1 && x < maxX && y > -1 && y < maxY) {\\n    if (!antinodes.has(x)) antinodes.set(x, new Set<number>([y]))\\n    else antinodes.get(x)?.add(y)\\n    x = x - xDiff\\n    y = y - yDiff\\n  }\\n}\\n\")), React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-csharp\"\n  }, \"public override object PartTwo()\\n{\\n    var antennae = ParseInput();\\n    HashSet<(int, int)> antinodes = [];\\n\\n    foreach (var antennaeType in antennae.Values)\\n    {\\n        foreach (var pair in antennaeType.UniquePairs())\\n            FindHarmonicAntinodes(antinodes, pair[0], pair[1], Input[0].Length - 1, Input.Length - 1);\\n    }\\n    return antinodes.Count;\\n}\\n\\nprivate static void FindHarmonicAntinodes(HashSet<(int, int)> antinodes, (int X, int Y) a, (int X, int Y) b, int maxX, int maxY)\\n{\\n    var xDiff = a.X - b.X;\\n    var yDiff = a.Y - b.Y;\\n    List<Func<int, int, int>> ops = [(x, y) => x + y, (x, y) => x - y];\\n\\n    foreach (var op in ops)\\n    {\\n        var x = a.X;\\n        var y = a.Y;\\n\\n        while (x >= 0 && x <= maxX && y >= 0 && y <= maxY)\\n        {\\n            antinodes.Add((x, y));\\n            x = op(x, xDiff);\\n            y = op(y, yDiff);\\n        }\\n    }\\n}\\n\"))));\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? React.createElement(MDXLayout, props, React.createElement(_createMdxContent, props)) : _createMdxContent(props);\n}\nexport default MDXContent;\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","import GATSBY_COMPILED_MDX from \"/home/joel/personal/advent-of-code/joel-allan-nz.github.io/days/2024/8.mdx\";\nimport React from 'react';\nimport {MDXProvider} from '@mdx-js/react';\nimport CodeBox from './CodeBox';\nimport TryYourself from './TryYourself';\nimport AdventSideNav from './AdventSideNav';\nimport Header from './Header';\nimport Footer from './Footer';\nconst shortcodes = {\n  CodeBox\n};\nfunction Layout(_ref) {\n  let {pageContext, children} = _ref;\n  return React.createElement(React.Fragment, null, React.createElement(Header, null), React.createElement(\"div\", {\n    className: \"min-h-screen bg-chicPrimary\"\n  }, React.createElement(AdventSideNav, {\n    props: pageContext.list\n  }), React.createElement(\"div\", {\n    className: \"adventofcode max-w-[60%] ml-[20%]\"\n  }, React.createElement(\"h1\", null, React.createElement(\"a\", {\n    href: \"https://adventofcode.com/\" + pageContext.year + \"/day/\" + pageContext.puzz\n  }, pageContext.year + \" Day \" + pageContext.puzz + \" - \" + pageContext.title)), React.createElement(MDXProvider, {\n    components: shortcodes\n  }, children), pageContext.puzz && pageContext.year ? React.createElement(TryYourself, {\n    year: pageContext.year,\n    puzz: pageContext.puzz\n  }) : React.createElement(React.Fragment, null))), React.createElement(Footer, null));\n}\nexport default function GatsbyMDXWrapper(props) {\n  return React.createElement(Layout, props, React.createElement(GATSBY_COMPILED_MDX, props));\n}\nexport const Head = () => React.createElement(React.Fragment, null, React.createElement(\"title\", null, \"Joel-Allan-NZ - Advent of Code\"), React.createElement(\"html\", {\n  lang: \"en\"\n}), React.createElement(\"link\", {\n  rel: \"preconnect\",\n  href: \"https://fonts.googleapis.com\"\n}), React.createElement(\"link\", {\n  rel: \"preconnect\",\n  href: \"https://fonts.gstatic.com\"\n}), React.createElement(\"link\", {\n  href: \"https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&family=VT323&display=swap\",\n  rel: \"stylesheet\"\n}));\n"],"names":["_createMdxContent","props","_components","Object","assign","h2","p","pre","code","_provideComponents","components","CodeBox","id","component","Error","_missingMdxReference","React","names","className","wrapper","MDXLayout","shortcodes","Layout","_ref","pageContext","children","Header","AdventSideNav","list","href","year","puzz","title","MDXProvider","TryYourself","Footer","GatsbyMDXWrapper","GATSBY_COMPILED_MDX","Head","lang","rel"],"sourceRoot":""}