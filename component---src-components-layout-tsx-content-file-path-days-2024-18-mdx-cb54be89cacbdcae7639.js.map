{"version":3,"file":"component---src-components-layout-tsx-content-file-path-days-2024-18-mdx-cb54be89cacbdcae7639.js","mappings":"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","sources":["webpack://joel-allan-nz.github.io/./days/2024/18.mdx","webpack://joel-allan-nz.github.io/./src/components/Layout.tsx"],"sourcesContent":["/*@jsxRuntime classic @jsx React.createElement @jsxFrag React.Fragment*/\nimport {useMDXComponents as _provideComponents} from \"@mdx-js/react\";\nimport React from \"react\";\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    p: \"p\",\n    pre: \"pre\",\n    code: \"code\"\n  }, _provideComponents(), props.components), {CodeBox} = _components;\n  if (!CodeBox) _missingMdxReference(\"CodeBox\", true);\n  return React.createElement(React.Fragment, null, React.createElement(_components.h2, null, \"Part One\"), \"\\n\", React.createElement(_components.p, null, \"Veeery simple stuff here for this late into the year.\"), \"\\n\", React.createElement(\"br\"), \"\\n\", React.createElement(_components.p, null, \"Pick your poison of path finding; they should all perform adequately in this small\\ngrid size... which means part 2 will probably be tricksy.\"), \"\\n\", React.createElement(CodeBox, {\n    boxname: \"one\",\n    names: \"typescript|C#\"\n  }, React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-js\"\n  }, \"export function partOne(input: string[]): number | string {\\n  const graph = parse(input)\\n  const start = graph.get(0)?.get(0)!\\n  const end = graph.get(70)?.get(70)!\\n  return findShortestExitDistance(graph, start, end)\\n}\\n\\ninterface CoordAwareNode {\\n  X: number\\n  Y: number\\n  Value: string\\n  Edges: CoordAwareNode[]\\n}\\n\\nfunction parse(input: string[]): Map<number, Map<number, CoordAwareNode>> {\\n  const graph = new Map<number, Map<number, CoordAwareNode>>()\\n\\n  for (let y = 0; y < 71; y++) {\\n    for (let x = 0; x < 71; x++) {\\n      const node: CoordAwareNode = { X: x, Y: y, Value: '.', Edges: [] }\\n      if (!graph.has(y)) graph.set(y, new Map<number, CoordAwareNode>())\\n      graph.get(y)?.set(x, node)\\n      const neighbours = [graph.get(y - 1)?.get(x), graph.get(y)?.get(x - 1)]\\n      neighbours.forEach((neighbour) => {\\n        if (neighbour) {\\n          neighbour.Edges.push(node)\\n          node.Edges.push(neighbour)\\n        }\\n      })\\n    }\\n  }\\n  for (let i = 0; i < 1024; i++) {\\n    let coords = input[i].split(/,/).map((x) => parseInt(x))\\n    graph.get(coords[1])!.get(coords[0])!.Value = '#'\\n  }\\n  return graph\\n}\\n\\nfunction findShortestExitDistance(\\n  graph: Map<number, Map<number, CoordAwareNode>>,\\n  start: CoordAwareNode,\\n  end: CoordAwareNode\\n): number {\\n  const minimumDistances = new Map<CoordAwareNode, number>([\\n    [end, 2 ** 31],\\n    [start, 0],\\n  ])\\n  const toExplore = [start]\\n\\n  while (toExplore.length > 0) {\\n    const node = toExplore.shift()!\\n    const distance = minimumDistances.get(node)!\\n\\n    if (node == end) return distance\\n\\n    const possibleMin = minimumDistances.get(node)\\n    if (possibleMin && possibleMin < distance) continue\\n\\n    node.Edges.forEach((node) => {\\n      if (node.Value != '#') {\\n        const nodeDistance = minimumDistances.get(node)\\n        if (!nodeDistance || nodeDistance > distance + 1) {\\n          minimumDistances.set(node, distance + 1)\\n          toExplore.push(node)\\n        }\\n      }\\n    })\\n  }\\n  return minimumDistances.get(end)!\\n}\\n\")), React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-csharp\"\n  }, \"public override object PartOne()\\n{\\n    var graph = Parse();\\n    var start = graph[(0, 0)];\\n    var end = graph[(70, 70)];\\n    return FindShortestExit(graph, start, end);\\n}\\n\\nprivate static int FindShortestExit(Dictionary<(int x, int y), CoordAwareNode> graph, CoordAwareNode start, CoordAwareNode end)\\n{\\n    Dictionary<CoordAwareNode, int> minimumDistances = [];\\n    minimumDistances[end] = int.MaxValue;\\n    minimumDistances[start] = 0;\\n\\n    Queue<CoordAwareNode> toExplore = [];\\n    toExplore.Enqueue(start);\\n\\n    while (toExplore.Count > 0)\\n    {\\n        var node = toExplore.Dequeue();\\n        var distance = minimumDistances[node];\\n        if (node == end)\\n            return minimumDistances[end];\\n        if (minimumDistances.TryGetValue(node, out var minimumDistance) && minimumDistance < distance)\\n            continue;\\n\\n        foreach (var edge in node.Edges)\\n        {\\n            if (edge.Value != '#')\\n            {\\n                if (minimumDistances.TryGetValue(edge, out var edgeDistance) && edgeDistance <= distance + 1)\\n                    continue;\\n\\n                minimumDistances[edge] = distance + 1;\\n                toExplore.Enqueue(edge);\\n            }\\n        }\\n    }\\n    return minimumDistances[end];\\n}\\n\\nprivate Dictionary<(int x, int y), CoordAwareNode> Parse()\\n{\\n    Dictionary<(int x, int y), CoordAwareNode> graph = [];\\n\\n    for (int y = 0; y < 71; y++)\\n    {\\n        for (int x = 0; x < 71; x++)\\n        {\\n            CoordAwareNode node = new(x, y, '.');\\n            graph.Add((x, y), node);\\n            if (graph.TryGetValue((x - 1, y), out var neighbour))\\n            {\\n                neighbour.Edges.Add(node);\\n                node.Edges.Add(neighbour);\\n            }\\n            if (graph.TryGetValue((x, y - 1), out neighbour))\\n            {\\n                neighbour.Edges.Add(node);\\n                node.Edges.Add(neighbour);\\n            }\\n        }\\n    }\\n\\n    for (int i = 0; i < 1024; i++)\\n    {\\n        var byteCoords = Input[i].Split(',').Select(x => int.Parse(x)).ToArray();\\n        graph[(byteCoords[1], byteCoords[0])].Value = '#';\\n    }\\n\\n    return graph;\\n}\\n\\ninternal class CoordAwareNode(int x, int y, char c)\\n{\\n    internal int X = x;\\n    internal int Y = y;\\n    internal char Value = c;\\n    internal List<CoordAwareNode> Edges = [];\\n}\\n\"))), \"\\n\", React.createElement(_components.h2, null, \"Part Two\"), \"\\n\", React.createElement(_components.p, null, \"Well, my predictions of being tricksy were inaccurate. You could use your part one solution, updating the graph until the path-finding fails to complete... but the performance wouldn't be wonderful.\"), \"\\n\", React.createElement(_components.p, null, React.createElement(\"br\"), \"I opted for A* with a very simple heurisitic for the priority: consider\\nnodes closest (by manhattan distance) to the end first. I also decided to\\nremember which nodes had been visited while finding that valid path, and only\\nrecheck for a valid path when one was modified by a line of the input.\"), \"\\n\", React.createElement(CodeBox, {\n    boxname: \"two\",\n    names: \"typescript|C#\"\n  }, React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-js\"\n  }, \"export function partTwo(input: string[]): number | string {\\n  const graph = parse(input)\\n  const start = graph.get(0)?.get(0)!\\n  const end = graph.get(70)?.get(70)!\\n  const visitedNodes = new Set<CoordAwareNode>()\\n\\n  for (let i = 1024; i < input.length; i++) {\\n    let coords = input[i].split(/,/).map((x) => parseInt(x))\\n    graph.get(coords[1])!.get(coords[0])!.Value! = '#'\\n\\n    if (\\n      visitedNodes.size == 0 ||\\n      visitedNodes.has(graph.get(coords[1])!.get(coords[0])!)\\n    ) {\\n      if (!hasPossiblePath(graph, start, end, visitedNodes))\\n        return `${coords[0]},${coords[1]}`\\n    }\\n  }\\n  return 'Can still find a path.'\\n}\\n\\nfunction hasPossiblePath(\\n  graph: Map<number, Map<number, CoordAwareNode>>,\\n  start: CoordAwareNode,\\n  end: CoordAwareNode,\\n  visited: Set<CoordAwareNode>\\n): boolean {\\n  const priority = new Map<number, CoordAwareNode[]>()\\n  visited.clear()\\n  visited.add(start)\\n  addPriorityNode(priority, start)\\n  while (priority.size > 0) {\\n    let current = getPriorityNode(priority)\\n    if (current == end) return true\\n\\n    current.Edges.forEach((neighbour) => {\\n      if (neighbour.Value != '#' && !visited.has(neighbour)) {\\n        visited.add(neighbour)\\n        addPriorityNode(priority, neighbour)\\n      }\\n    })\\n  }\\n  return false\\n}\\n\\nfunction addPriorityNode(\\n  priority: Map<number, CoordAwareNode[]>,\\n  node: CoordAwareNode\\n) {\\n  const distance = 140 - node.X - node.Y\\n\\n  if (!priority.has(distance)) priority.set(distance, [node])\\n  else priority.get(distance)?.push(node)\\n}\\n\\nfunction getPriorityNode(\\n  priority: Map<number, CoordAwareNode[]>\\n): CoordAwareNode {\\n  const smallest = priority\\n    .keys()\\n    .reduce((min, current) => (min > current ? current : min), 2 ** 31)\\n  const toReturn = priority.get(smallest)!.shift()!\\n  if (priority.get(smallest)?.length == 0) {\\n    priority.delete(smallest)\\n  }\\n  return toReturn\\n}\\n\")), React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-csharp\"\n  }, \"public override object PartTwo()\\n{\\n    HashSet<CoordAwareNode> pathNodes = [];\\n    var graph = Parse();\\n    var start = graph[(0, 0)];\\n    var end = graph[(70, 70)];\\n\\n    for (int i = 1024; i < Input.Length; i++)\\n    {\\n        var byteCoords = Input[i].Split(',').Select(x => int.Parse(x)).ToArray();\\n        graph[(byteCoords[1], byteCoords[0])].Value = '#';\\n\\n        if (pathNodes.Count == 0 || pathNodes.Contains(graph[(byteCoords[1], byteCoords[0])]))\\n        {\\n            if (!HasPossiblePath(graph, start, end, out pathNodes))\\n                return $\\\"{byteCoords[0]},{byteCoords[1]}\\\";\\n        }\\n    }\\n    return -1;\\n}\\n\\nprivate static bool HasPossiblePath(Dictionary<(int x, int y), CoordAwareNode> graph, CoordAwareNode start, CoordAwareNode end, out HashSet<CoordAwareNode> visited)\\n{\\n    PriorityQueue<CoordAwareNode, int> toVisit = new();\\n    visited = [];\\n    visited.Add(start);\\n    toVisit.Enqueue(start, 0);\\n\\n    while (toVisit.Count > 0)\\n    {\\n        var current = toVisit.Dequeue();\\n        if (current == end)\\n            return true;\\n\\n        foreach (var neighbour in current.Edges)\\n        {\\n            if (neighbour.Value == '#' || visited.Contains(neighbour))\\n                continue;\\n\\n            visited.Add(neighbour);\\n            toVisit.Enqueue(neighbour, 140 - neighbour.X - neighbour.Y);\\n        }\\n    }\\n    return false;\\n}\\n\"))));\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? React.createElement(MDXLayout, props, React.createElement(_createMdxContent, props)) : _createMdxContent(props);\n}\nexport default MDXContent;\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","import GATSBY_COMPILED_MDX from \"/home/joel/personal/advent-of-code/joel-allan-nz.github.io/days/2024/18.mdx\";\nimport React from 'react';\nimport {MDXProvider} from '@mdx-js/react';\nimport CodeBox from './CodeBox';\nimport TryYourself from './TryYourself';\nimport AdventSideNav from './AdventSideNav';\nimport Header from './Header';\nimport Footer from './Footer';\nconst shortcodes = {\n  CodeBox\n};\nfunction Layout(_ref) {\n  let {pageContext, children} = _ref;\n  return React.createElement(React.Fragment, null, React.createElement(Header, null), React.createElement(\"div\", {\n    className: \"min-h-screen bg-chicPrimary\"\n  }, React.createElement(AdventSideNav, {\n    props: pageContext.list\n  }), React.createElement(\"div\", {\n    className: \"adventofcode max-w-[60%] ml-[20%]\"\n  }, React.createElement(\"h1\", null, React.createElement(\"a\", {\n    href: \"https://adventofcode.com/\" + pageContext.year + \"/day/\" + pageContext.puzz\n  }, pageContext.year + \" Day \" + pageContext.puzz + \" - \" + pageContext.title)), React.createElement(MDXProvider, {\n    components: shortcodes\n  }, children), pageContext.puzz && pageContext.year ? React.createElement(TryYourself, {\n    year: pageContext.year,\n    puzz: pageContext.puzz\n  }) : React.createElement(React.Fragment, null))), React.createElement(Footer, null));\n}\nexport default function GatsbyMDXWrapper(props) {\n  return React.createElement(Layout, props, React.createElement(GATSBY_COMPILED_MDX, props));\n}\nexport const Head = () => React.createElement(React.Fragment, null, React.createElement(\"title\", null, \"Joel-Allan-NZ - Advent of Code\"), React.createElement(\"html\", {\n  lang: \"en\"\n}), React.createElement(\"link\", {\n  rel: \"preconnect\",\n  href: \"https://fonts.googleapis.com\"\n}), React.createElement(\"link\", {\n  rel: \"preconnect\",\n  href: \"https://fonts.gstatic.com\"\n}), React.createElement(\"link\", {\n  href: \"https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&family=VT323&display=swap\",\n  rel: \"stylesheet\"\n}));\n"],"names":["_createMdxContent","props","_components","Object","assign","h2","p","pre","code","_provideComponents","components","CodeBox","id","component","Error","_missingMdxReference","React","boxname","names","className","wrapper","MDXLayout","shortcodes","Layout","_ref","pageContext","children","Header","AdventSideNav","list","href","year","puzz","title","MDXProvider","TryYourself","Footer","GatsbyMDXWrapper","GATSBY_COMPILED_MDX","Head","lang","rel"],"sourceRoot":""}