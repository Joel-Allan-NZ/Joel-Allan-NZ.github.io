"use strict";(self.webpackChunkjoel_allan_nz_github_io=self.webpackChunkjoel_allan_nz_github_io||[]).push([[6271],{4433:function(e,n,t){t.r(n),t.d(n,{Head:function(){return b},default:function(){return d}});var i=t(8453),a=t(6540);function r(e){const n=Object.assign({h2:"h2",p:"p",a:"a",pre:"pre",code:"code"},(0,i.RP)(),e.components),{CodeBox:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("CodeBox",!0),a.createElement(a.Fragment,null,a.createElement(n.h2,null,"Part One"),"\n",a.createElement(n.p,null,"This is all about ",a.createElement(n.a,{href:"https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection"},"line-line intersection"),". The specific apoproach I'm using is to find the time distance between the current point and the intercept, and using that to find said intercept point. It should be trivial to roll the past-checking aspect of whether an intercept is valid into this method, but I've separated them here in the interest of legibility."),"\n",a.createElement("br"),"\n",a.createElement(n.p,null,"There ought to be a number of different valid mathematical approaches here, but this\none was sufficiently fast to be fit for purpose. I'm more worried about what Part\n2 will entail than refining this further."),"\n",a.createElement(t,{names:"typescript|C#"},a.createElement(n.pre,null,a.createElement(n.code,{className:"language-ts"},"export function partOne(input: string[]): number | string {\n  const hail = parse(input)\n  const MIN = 200000000000000\n  const MAX = 400000000000000\n\n  let count = 0\n  for (let i = 0; i < hail.length; i++) {\n    for (let j = i + 1; j < hail.length; j++) {\n      const inter = intercept(hail[i], hail[j])\n      if (isValidIntercept(hail[i], hail[j], inter, MIN, MAX)) {\n        count++\n      }\n    }\n  }\n  return count\n}\n\nfunction parse(input: string[]): number[][][] {\n  const hail: number[][][] = []\n  input.forEach((line) => {\n    const split = line.split('@')\n    hail.push(split.map((x) => x.split(', ').map((x) => parseInt(x))))\n  })\n  return hail\n}\n\nfunction intercept(a: number[][], b: number[][]): number[] {\n  if (a[1][1] * b[1][0] - a[0][0] * b[1][1] == 0) return [-1, -1]\n\n  const numerator =\n    a[0][0] * b[1][1] -\n    a[0][1] * b[1][0] -\n    b[0][0] * b[1][1] +\n    b[0][1] * b[1][0]\n  const denominator = a[1][1] * b[1][0] - a[1][0] * b[1][1]\n\n  const lambda = numerator / denominator\n\n  return [a[0][0] + lambda * a[1][0], a[0][1] + lambda * a[1][1]]\n}\n\nfunction isValidIntercept(\n  a: number[][],\n  b: number[][],\n  intercept: number[],\n  min: number,\n  max: number\n): boolean {\n  if (\n    intercept.some(\n      (i, index) =>\n        (i < a[0][index] && a[1][index] > 0) ||\n        (i < b[0][index] && b[1][index] > 0)\n    )\n  )\n    return false\n  if (\n    intercept.some(\n      (i, index) =>\n        (i > a[0][index] && a[1][index] < 0) ||\n        (i > b[0][index] && b[1][index] < 0)\n    )\n  )\n    return false\n\n  return intercept.every((i) => i >= min && i <= max)\n}\n")),a.createElement(n.pre,null,a.createElement(n.code,{className:"language-csharp"},"public override object PartOne()\n{\n    var hail = Parse(Input);\n    long MIN = 200000000000000;\n    long MAX = 400000000000000;\n\n    return hail.UniquePairs().Count(pair =>\n    {\n        var inter = Intercept(pair[0], pair[1]);\n        return !IsInterceptInPast(pair, inter) && inter[0] >= MIN && inter[0] <= MAX && inter[1] >= MIN && inter[1] <= MAX;\n    });\n}\n\nprivate static bool IsInterceptInPast(Hail[] pair, decimal[] inter)\n{\n    if (inter[0] < pair[0].Position[0] && pair[0].Velocity[0] > 0 || inter[0] < pair[1].Position[0] && pair[1].Velocity[0] > 0)\n        return true;\n    if (inter[1] < pair[0].Position[1] && pair[0].Velocity[1] > 0 || inter[1] < pair[1].Position[1] && pair[1].Velocity[1] > 0)\n        return true;\n    if (inter[0] > pair[0].Position[0] && pair[0].Velocity[0] < 0 || inter[0] > pair[1].Position[0] && pair[1].Velocity[0] < 0)\n        return true;\n    if (inter[1] > pair[0].Position[1] && pair[0].Velocity[1] < 0 || inter[1] > pair[1].Position[1] && pair[1].Velocity[1] < 0)\n        return true;\n    return false;\n}\n\nprivate static decimal[] Intercept(Hail a, Hail b)\n{\n    if (a.Velocity[1] * b.Velocity[0] - a.Velocity[0] * b.Velocity[1] == 0)\n        return [-1, -1];\n\n    var numerator = (a.Position[0] * b.Velocity[1] - a.Position[1] * b.Velocity[0] - b.Position[0] * b.Velocity[1] + b.Position[1] * b.Velocity[0]);\n    var denominator = (a.Velocity[1] * b.Velocity[0] - a.Velocity[0] * b.Velocity[1]);\n    var lambda = numerator / denominator;\n\n    return [a.Position[0] + lambda * a.Velocity[0], a.Position[1] + lambda * a.Velocity[1]];\n}\n\ninternal class Hail(decimal[] position, decimal[] velocity)\n{\n    internal decimal[] Position = position;\n    internal decimal[] Velocity = velocity;\n}\n\nprivate static List<Hail> Parse(string[] input)\n{\n    List<Hail> hail = [];\n    foreach (var line in input)\n    {\n        var split = line.Split(\"@\");\n        hail.Add(new(split[0].Split([',', ' '], StringSplitOptions.RemoveEmptyEntries).Select(x => decimal.Parse(x)).ToArray(),\n                    split[1].Split([',', ' '], StringSplitOptions.RemoveEmptyEntries).Select(x => decimal.Parse(x)).ToArray()));\n    }\n    return hail;\n}\n"))),"\n",a.createElement(n.h2,null,"Part Two"),"\n",a.createElement(n.p,null,"Argh, now this one was a toughie. The hardest puzzle in years (for me, at least)."),"\n",a.createElement("br"),"\n",a.createElement(n.p,null,"The more obvious approach involves linear algebra and finding a possible intersect\npath for any 3 stones. Implementing a solution that way however, proved difficult\nto debug; hunting possible algebraic errors as well as programming ones while also\nkeeping the very large input values meaningful and precise was a headache. After\nmore debugging time than I'd like to admit I resorted to the wisdom of crowds, and\nwas gifted with this very tidy solution."),"\n",a.createElement("br"),"\n",a.createElement(n.p,null,"The idea is that there are a (limited) number of hailstones with identical velocities\nin a dimension. Those identical velocities guarantee that their relative distance\nwill always be the same at it was at the beginning, and greatly limits the possible\nvelocities our thrown stone could have. Testing all pairs of same-velocity stones\nwith a reasonable range of possible velocities quite quickly reduces down to only\na single possible velocity vector, from which we can calculate our starting position."," "),"\n",a.createElement(t,{names:"typescript|C#"},a.createElement(n.pre,null,a.createElement(n.code,{className:"language-ts"},"export function partTwo(input: string[]): number | string {\n  const hail = parse(input)\n  const velocityVector = findIntersectVelocity(hail)\n\n  const a = hail[0]\n  const ab = [a, hail[1]]\n\n  const m = ab.map(\n    (x) => (x[1][1] - velocityVector[1]) / (x[1][0] - velocityVector[0])\n  )\n  const c = ab.map((x, index) => x[0][1] - m[index] * x[0][0])\n\n  const x = Math.floor((c[1] - c[0]) / (m[0] - m[1]))\n  const y = Math.floor(m[0] * x + c[0])\n  const z =\n    a[0][2] +\n    ((a[1][2] - velocityVector[2]) * (x - a[0][0])) /\n      (a[1][0] - velocityVector[0])\n\n  return x + y + z\n}\n\nfunction findIntersectVelocity(hail: number[][][]): number[] {\n  const sets = [new Set<number>(), new Set<number>(), new Set<number>()]\n\n  for (let i = 0; i < hail.length; i++) {\n    for (let j = i + 1; j < hail.length; j++) {\n      for (let k = 0; k < 3; k++) {\n        const res = findPotentialIntersectVelocity(hail[i], hail[j], k, 2000)\n        if (res.size > 0) {\n          sets[k] = sets[k].size > 0 ? sets[k].intersection(res) : res\n        }\n      }\n    }\n  }\n  return sets.map((x) => x.values().toArray()[0])\n}\n\nfunction findPotentialIntersectVelocity(\n  a: number[][],\n  b: number[][],\n  vectorDimension: number,\n  speedRange: number\n): Set<number> {\n  const potential = new Set<number>()\n  if (a[1][vectorDimension] == b[1][vectorDimension]) {\n    const diff = b[0][vectorDimension] - a[0][vectorDimension]\n    for (let v = -1 * speedRange; v <= speedRange; v++) {\n      const c = v - a[1][vectorDimension]\n      if (c != 0 && diff != 0 && ((diff % c) + c) % c == 0) potential.add(v)\n    }\n  }\n  return potential\n}\n")),a.createElement(n.pre,null,a.createElement(n.code,{className:"language-csharp"},"public override object PartTwo()\n{\n    var hail = Parse(Input);\n    var velocityVector = FindIntersectVelocity(hail);\n\n    var a = hail[0];\n    Hail[] ab = [a, hail[1]];\n\n    var m = ab.Select(x => (x.Velocity[1] - velocityVector[1]) / (x.Velocity[0] - velocityVector[0])).ToArray();\n    var c = ab.Select((x, index) => x.Position[1] - (m[index] * x.Position[0])).ToArray();\n\n    var x = Math.Floor((c[1] - c[0]) / (m[0] - m[1]));\n    var y = Math.Floor(m[0] * x + c[0]);\n    var z = a.Position[2] + (a.Velocity[2] - velocityVector[2]) * (x - a.Position[0]) / (a.Velocity[0] - velocityVector[0]);\n\n    return x + y + z;\n}\n\nprivate static int[] FindIntersectVelocity(List<Hail> hail)\n{\n    HashSet<int>?[] sets = [null, null, null];\n\n    foreach (var pair in hail.UniquePairs())\n    {\n        for (int i = 0; i < 3; i++)\n        {\n            var res = FindPotentialIntersectVelocity(pair[0], pair[1], i, 2000);\n            if (res.Count > 0)\n                (sets[i] ??= res).IntersectWith(res);\n        }\n    }\n\n    return sets!.Select(x => x!.First()).ToArray();\n}\n\nprivate static HashSet<int> FindPotentialIntersectVelocity(Hail a, Hail b, int vectorDimension, int speedRange)\n{\n    HashSet<int> potentialIntersectVelocities = [];\n    if (a.Velocity[vectorDimension] == b.Velocity[vectorDimension])\n    {\n        var diff = b.Position[vectorDimension] - a.Position[vectorDimension];\n        for (int v = -1 * speedRange; v <= speedRange; v++)\n        {\n            var c = v - a.Velocity[vectorDimension];\n\n            if (c != 0 && diff != 0 && (((diff % c) + c) % c) == 0)\n                potentialIntersectVelocities.Add(v);\n        }\n    }\n    return potentialIntersectVelocities;\n}\n"))))}var o=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,i.RP)(),e.components);return n?a.createElement(n,e,a.createElement(r,e)):r(e)};var l=t(2779),c=t(7206),s=t(791),p=t(4813),m=t(572);const u={CodeBox:l.A};function h(e){let{pageContext:n,children:t}=e;return a.createElement(a.Fragment,null,a.createElement(p.A,null),a.createElement("div",{className:"min-h-screen bg-chicPrimary"},a.createElement(s.A,{props:n.list}),a.createElement("div",{className:"adventofcode max-w-[60%] ml-[20%]"},a.createElement("h1",null,a.createElement("a",{href:"https://adventofcode.com/"+n.year+"/day/"+n.puzz},n.year+" Day "+n.puzz+" - "+n.title)),a.createElement(i.xA,{components:u},t),n.puzz&&n.year?a.createElement(c.A,{year:n.year,puzz:n.puzz}):a.createElement(a.Fragment,null))),a.createElement(m.A,null))}function d(e){return a.createElement(h,e,a.createElement(o,e))}const b=()=>a.createElement(a.Fragment,null,a.createElement("title",null,"Joel-Allan-NZ - Advent of Code"),a.createElement("html",{lang:"en"}),a.createElement("link",{rel:"preconnect",href:"https://fonts.googleapis.com"}),a.createElement("link",{rel:"preconnect",href:"https://fonts.gstatic.com"}),a.createElement("link",{href:"https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&family=VT323&display=swap",rel:"stylesheet"}))}}]);
//# sourceMappingURL=component---src-components-layout-tsx-content-file-path-days-2023-24-mdx-9c9eaa866d0fc6f47b58.js.map