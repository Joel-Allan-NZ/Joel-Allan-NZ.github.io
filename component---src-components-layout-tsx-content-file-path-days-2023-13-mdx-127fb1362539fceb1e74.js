"use strict";(self.webpackChunkjoel_allan_nz_github_io=self.webpackChunkjoel_allan_nz_github_io||[]).push([[6605],{7737:function(n,e,t){t.r(e),t.d(e,{Head:function(){return g},default:function(){return d}});var a=t(8453),r=t(6540);function i(n){const e=Object.assign({h2:"h2",p:"p",em:"em",pre:"pre",code:"code"},(0,a.RP)(),n.components),{CodeBox:t}=e;return t||function(n,e){throw new Error("Expected "+(e?"component":"object")+" `"+n+"` to be defined: you likely forgot to import, pass, or provide it.")}("CodeBox",!0),r.createElement(r.Fragment,null,r.createElement(e.h2,null,"Part One"),"\n",r.createElement(e.p,null,"The solution code has been modified to suit part 2, but the core idea is pretty simple: check each column (and then each row) for a reflection by checking rows/columns equally distant from a potential reflection for equality."),"\n",r.createElement("br"),"\n",r.createElement(e.p,null,"You ",r.createElement(e.em,null,"could")," use string equality comparisons for the rows, but part 2 causes issues\nthere."),"\n",r.createElement(t,{names:"typescript|C#"},r.createElement(e.pre,null,r.createElement(e.code,{className:"language-ts"},"export function partOne(input: string[]): number | string {\n  const maps = parse(input)\n  return maps.reduce(\n    (total, map) =>\n      total +\n      (findVerticalReflection(map) ?? findHorizontalReflection(map)! * 100),\n    0\n  )\n}\n\nfunction parse(input: string[]): string[][] {\n  const read: string[][] = [[]]\n  input.forEach((line) => {\n    if (line != '') {\n      read[read.length - 1].push(line)\n    } else read.push([])\n  })\n  return read\n}\n\nfunction findVerticalReflection(\n  map: string[],\n  flawTarget: number = 0\n): number | undefined {\n  for (let x = 1; x < map[0].length; x++) {\n    const distance = Math.min(map[0].length - x, x)\n    let mirrorPosition: number | undefined = x\n    let flaws = 0\n\n    for (let j = 0; j < distance; j++) {\n      for (let line of map) {\n        if (line[x - j - 1] != line[x + j]) {\n          if (++flaws > flawTarget) break\n        }\n      }\n      if (flaws > flawTarget) break\n    }\n    if (flaws == flawTarget) return mirrorPosition\n  }\n}\n\nfunction findHorizontalReflection(\n  map: string[],\n  flawTarget: number = 0\n): number | undefined {\n  for (let y = 1; y < map.length; y++) {\n    let flaws = 0\n    const distance = Math.min(map.length - y, y)\n    let mirrorPosition: number | undefined = y\n\n    for (let j = 0; j < distance; j++) {\n      for (let x = 0; x < map[0].length; x++) {\n        if (map[y + j][x] != map[y - j - 1][x]) {\n          if (++flaws > flawTarget) break\n        }\n      }\n      if (flaws > flawTarget) break\n    }\n    if (flaws == flawTarget) return mirrorPosition\n  }\n}\n")),r.createElement(e.pre,null,r.createElement(e.code,{className:"language-csharp"},"public override object PartOne()\n{\n    var maps = Parse();\n    return maps.Sum(map => FindVerticalReflection(map) ?? FindHorizontalReflection(map) * 100 ?? 0);\n}\n\nprivate List<List<string>> Parse()\n{\n    List<List<string>> maps = [[]];\n    foreach (var line in Input)\n    {\n        if (string.IsNullOrEmpty(line))\n        {\n            maps.Add([]);\n            continue;\n        }\n        maps[^1].Add(line);\n    }\n    return maps;\n}\n\nprivate static int? FindVerticalReflection(List<string> map, int flawLimit = 0)\n{\n    for (int x = 1; x < map[0].Length; x++)\n    {\n        int? mirrorPosition = x;\n        int flaws = 0;\n        var distance = Math.Min(map[0].Length - x, x);\n\n        for (int j = 0; j < distance; j++)\n        {\n            foreach (var line in map)\n            {\n                if (line[x - j - 1] != line[x + j])\n                {\n                    if (++flaws > flawLimit)\n                        break;\n                }\n            }\n            if (flaws > flawLimit)\n                break;\n        }\n        if (flaws == flawLimit)\n            return mirrorPosition;\n    }\n    return null;\n}\n\nprivate static int? FindHorizontalReflection(List<string> map, int flawLimit = 0)\n{\n    for (int y = 1; y < map.Count; y++)\n    {\n        int flaws = 0;\n        int distance = Math.Min(map.Count - y, y);\n        int? mirrorPosition = y;\n\n        for (int j = 0; j < distance; j++)\n        {\n            for (int x = 0; x < map[0].Length; x++)\n            {\n                if (map[y + j][x] != map[y - j - 1][x])\n                {\n                    if (++flaws > flawLimit)\n                        break;\n                }\n            }\n            if (flaws > flawLimit)\n                break;\n        }\n        if (flaws == flawLimit)\n            return mirrorPosition;\n    }\n    return null;\n}\n"))),"\n",r.createElement(e.h2,null,"Part Two"),"\n",r.createElement(e.p,null,"Valid reflections are now required to have a single flaw. The code is identical to the changes I made to part 1, and as we only consider reflections with a single flaw we don't need to first explicitly eliminate the part 1 reflections as valid options."),"\n",r.createElement(t,{names:"typescript|C#"},r.createElement(e.pre,null,r.createElement(e.code,{className:"language-ts"},"export function partTwo(input: string[]): number | string {\n  const maps = parse(input)\n  return maps.reduce(\n    (total, map) =>\n      total +\n      (findVerticalReflection(map, 1) ??\n        findHorizontalReflection(map, 1)! * 100),\n    0\n  )\n}\n")),r.createElement(e.pre,null,r.createElement(e.code,{className:"language-csharp"},"public override object PartTwo()\n{\n    var maps = Parse();\n    return maps.Sum(map => FindVerticalReflection(map, 1) ?? FindHorizontalReflection(map, 1) * 100 ?? 0);\n}\n\n"))))}var l=function(n){void 0===n&&(n={});const{wrapper:e}=Object.assign({},(0,a.RP)(),n.components);return e?r.createElement(e,n,r.createElement(i,n)):i(n)};var o=t(2779),s=t(7206),c=t(791),m=t(4813),f=t(572);const p={CodeBox:o.A};function u(n){let{pageContext:e,children:t}=n;return r.createElement(r.Fragment,null,r.createElement(m.A,null),r.createElement("div",{className:"min-h-screen bg-chicPrimary"},r.createElement(c.A,{props:e.list}),r.createElement("div",{className:"adventofcode max-w-[60%] ml-[20%]"},r.createElement("h1",null,r.createElement("a",{href:"https://adventofcode.com/"+e.year+"/day/"+e.puzz},e.year+" Day "+e.puzz+" - "+e.title)),r.createElement(a.xA,{components:p},t),e.puzz&&e.year?r.createElement(s.A,{year:e.year,puzz:e.puzz}):r.createElement(r.Fragment,null))),r.createElement(f.A,null))}function d(n){return r.createElement(u,n,r.createElement(l,n))}const g=()=>r.createElement(r.Fragment,null,r.createElement("title",null,"Joel-Allan-NZ - Advent of Code"),r.createElement("html",{lang:"en"}),r.createElement("link",{rel:"preconnect",href:"https://fonts.googleapis.com"}),r.createElement("link",{rel:"preconnect",href:"https://fonts.gstatic.com"}),r.createElement("link",{href:"https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&family=VT323&display=swap",rel:"stylesheet"}))}}]);
//# sourceMappingURL=component---src-components-layout-tsx-content-file-path-days-2023-13-mdx-127fb1362539fceb1e74.js.map