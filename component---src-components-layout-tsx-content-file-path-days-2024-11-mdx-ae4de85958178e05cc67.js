"use strict";(self.webpackChunkjoel_allan_nz_github_io=self.webpackChunkjoel_allan_nz_github_io||[]).push([[3786],{5390:function(e,n,t){t.r(n),t.d(n,{Head:function(){return g},default:function(){return d}});var a=t(8453),l=t(6540);function r(e){const n=Object.assign({h2:"h2",p:"p",code:"code",em:"em",pre:"pre"},(0,a.RP)(),e.components),{CodeBox:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("CodeBox",!0),l.createElement(l.Fragment,null,l.createElement(n.h2,null,"Part One"),"\n",l.createElement(n.p,null,"Although I was expecting a real headscratcher, this has a good argument to be the easiest of the year to date! There's really no trick to it beyond needing to use a little memoization."),"\n",l.createElement("br"),"\n",l.createElement(n.p,null,"The key insight here is that stones don't affect the progression of other stones,\nso we can work stone-by-stone, and remembering the results of applying the rules\nto a stone for a given number of blinks can prevent us from having to re-do work\nlater."),"\n",l.createElement("br"),"\n",l.createElement(n.p,null,"Consider the most obvious example, where we have two stones: ",l.createElement(n.code,null,"0 0"),". After 25 blinks\neach stones ought to have the same value. Or, a slightly more realistic example:\n",l.createElement(n.code,null,"1 0"),". 0's first blink will give it the value of one, so after running 25 blinks\non 1, we'll ",l.createElement(n.em,null,"also know the result of running ",l.createElement(n.em,null,"26")," blinks for 0"),". That's potentially\na lot of repetition saved!"),"\n",l.createElement("br"),"\n",l.createElement(n.p,null,"The one 'trick' that might need a touch of explanation is ",l.createElement(n.code,null,"if(Math.floor(Math.log10(stone))%2==0)"),".\nIt's simply checking whether a value has an odd number of digits - ",l.createElement(n.code,null,"Math.log10(1000)"),"=\n3, ",l.createElement(n.code,null,"Math.log10(10000)")," = 4 etc, with the ",l.createElement(n.code,null,"Math.floor()")," ensuring we get an integer\nvalue to check with the modulo operator."),"\n",l.createElement(t,{boxname:"one",names:"typescript|C#"},l.createElement(n.pre,null,l.createElement(n.code,{className:"language-js"},"export function partOne(input: string[]): number | string {\n  const cache = new Map<number, Map<number, number>>()\n\n  return input[0]\n    .split(' ')\n    .map((x) => parseInt(x))\n    .reduce((total, current) => total + applyRules(current, 25, cache), 0)\n}\n\nexport function applyRules(\n  stone: number,\n  count: number,\n  cache: Map<number, Map<number, number>>\n): number {\n  if (cache.has(stone)) {\n    const blinks = cache.get(stone)\n    if (blinks?.has(count)) return blinks.get(count)!\n  }\n\n  if (count == 0) return nestedAdd(cache, stone, 0, 1)\n  if (stone == 0)\n    return nestedAdd(cache, stone, count, applyRules(1, count - 1, cache))\n  if (Math.floor(Math.log10(stone)) % 2 == 0)\n    return nestedAdd(\n      cache,\n      stone,\n      count,\n      applyRules(stone * 2024, count - 1, cache)\n    )\n\n  let s = stone.toString()\n  let half = Math.floor(s.length / 2)\n  return nestedAdd(\n    cache,\n    stone,\n    count,\n    applyRules(parseInt(s.slice(0, half)), count - 1, cache) +\n      applyRules(parseInt(s.slice(half)), count - 1, cache)\n  )\n}\n\nfunction nestedAdd<T, U, V>(\n  map: Map<T, Map<U, V>>,\n  key: T,\n  nestedKey: U,\n  value: V\n): V {\n  if (!map.has(key)) {\n    map.set(key, new Map<U, V>([[nestedKey, value]]))\n  } else if (!map.get(key)?.has(nestedKey)) {\n    map.get(key)?.set(nestedKey, value)\n  }\n  return value\n}\n")),l.createElement(n.pre,null,l.createElement(n.code,{className:"language-csharp"},"Dictionary<long, Dictionary<long, long>>? cache;\n\npublic override object PartOne()\n{\n    cache ??= [];\n\n    return Input[0].Split(' ', StringSplitOptions.RemoveEmptyEntries)\n                  .Select(x => long.Parse(x))\n                  .Sum(x => ApplyRules(x, 25, cache));\n}\n\nprivate static long ApplyRules(long stone, int count, Dictionary<long, Dictionary<long, long>> cache)\n{\n  if (cache.TryGetValue(stone, out var blinks))\n  {\n      if (blinks.TryGetValue(count, out var stones))\n      {\n          return stones;\n      }\n  }\n\n  if (count == 0)\n      return cache.NestedAdd(stone, 0, 1);\n\n  if (stone == 0)\n  {\n      return cache.NestedAdd(stone, count, ApplyRules(1, count - 1, cache));\n  }\n  else if (Math.Floor(Math.Log10(stone)) % 2 == 0)\n  {\n      return cache.NestedAdd(stone, count, ApplyRules(stone * 2024, count - 1, cache));\n  }\n\n  var s = stone.ToString();\n  var halfLength = s.Length / 2;\n  return cache.NestedAdd(stone, count, ApplyRules(long.Parse(s[0..halfLength]), count - 1, cache) +\n                                    ApplyRules(long.Parse(s[halfLength..]), count - 1, cache));\n\n}\n\npublic static V NestedAdd<TKey, UKey, V>(this Dictionary<TKey, Dictionary<UKey, V>> dictionary,\n    TKey key, UKey nestedKey, V value) where TKey : notnull where UKey : notnull\n{\n    if (!dictionary.TryGetValue(key, out Dictionary<UKey, V>? subDict))\n    {\n        subDict = [];\n        dictionary[key] = subDict;\n    }\n    subDict[nestedKey] = value;\n    return value;\n}\n"))),"\n",l.createElement(n.h2,null,"Part Two"),"\n",l.createElement(n.p,null,"Exact same algorithm, just starting with a bigger input."),"\n",l.createElement(t,{boxname:"two",names:"typescript|C#"},l.createElement(n.pre,null,l.createElement(n.code,{className:"language-js"},"export function partTwo(input: string[]): number | string {\n  const cache = new Map<number, Map<number, number>>()\n\n  return input[0]\n    .split(' ')\n    .map((x) => parseInt(x))\n    .reduce((total, current) => total + applyRules(current, 75, cache), 0)\n}\n")),l.createElement(n.pre,null,l.createElement(n.code,{className:"language-csharp"},"public override object PartTwo()\n{\n    cache ??= [];\n\n    return Input[0].Split(' ', StringSplitOptions.RemoveEmptyEntries)\n                    .Select(x => long.Parse(x))\n                    .Sum(x => ApplyRules(x, 75, cache));\n}\n"))))}var o=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,a.RP)(),e.components);return n?l.createElement(n,e,l.createElement(r,e)):r(e)};var c=t(2779),s=t(7206),u=t(791),i=t(4813),p=t(572);const h={CodeBox:c.A};function m(e){let{pageContext:n,children:t}=e;return l.createElement(l.Fragment,null,l.createElement(i.A,null),l.createElement("div",{className:"min-h-screen bg-chicPrimary"},l.createElement(u.A,{props:n.list}),l.createElement("div",{className:"adventofcode max-w-[60%] ml-[20%]"},l.createElement("h1",null,l.createElement("a",{href:"https://adventofcode.com/"+n.year+"/day/"+n.puzz},n.year+" Day "+n.puzz+" - "+n.title)),l.createElement(a.xA,{components:h},t),n.puzz&&n.year?l.createElement(s.A,{year:n.year,puzz:n.puzz}):l.createElement(l.Fragment,null))),l.createElement(p.A,null))}function d(e){return l.createElement(m,e,l.createElement(o,e))}const g=()=>l.createElement(l.Fragment,null,l.createElement("title",null,"Joel-Allan-NZ - Advent of Code"),l.createElement("html",{lang:"en"}),l.createElement("link",{rel:"preconnect",href:"https://fonts.googleapis.com"}),l.createElement("link",{rel:"preconnect",href:"https://fonts.gstatic.com"}),l.createElement("link",{href:"https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&family=VT323&display=swap",rel:"stylesheet"}))}}]);
//# sourceMappingURL=component---src-components-layout-tsx-content-file-path-days-2024-11-mdx-ae4de85958178e05cc67.js.map