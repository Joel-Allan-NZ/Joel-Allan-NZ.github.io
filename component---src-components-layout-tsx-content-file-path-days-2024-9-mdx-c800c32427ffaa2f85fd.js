"use strict";(self.webpackChunkjoel_allan_nz_github_io=self.webpackChunkjoel_allan_nz_github_io||[]).push([[7809],{7725:function(e,n,t){t.r(n),t.d(n,{Head:function(){return p},default:function(){return g}});var i=t(8453),o=t(6540);function l(e){const n=Object.assign({h2:"h2",p:"p",strong:"strong",code:"code",pre:"pre"},(0,i.RP)(),e.components),{CodeBox:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("CodeBox",!0),o.createElement(o.Fragment,null,o.createElement(n.h2,null,"Part One"),"\n",o.createElement(n.p,null,"Well that's certainly a big single line input."),"\n",o.createElement("br"),"\n",o.createElement(n.p,null,"With the size of the input in mind, I immediately discarded the idea of using something\nlike a LinkedList to accurately model the data while maintaining efficient removes/inserts...\nit was simply going to be too memory heavy."),"\n",o.createElement("br"),"\n",o.createElement(n.p,null,"Instead I model the memory based on the disk map, simply using properties to record\nwhether it's a file, id, length of the memory block, and the index of that memory.\nWith those in hand we can generate the checksum by iterating over the disk map, amd\nchecking what the current point in the diskmap represents"),"\n",o.createElement("br"),"\n",o.createElement(n.p,null,"If we are looking at a ",o.createElement(n.strong,null,"file"),", then we simply apply the checksum calculation to\nthose memory blocks and add them to our running total. I used Gauss' summation here\nto simply sum the entire contiguous block of memory and cut down on unncessary iteration\nover each of the individual blocks."),"\n",o.createElement("br"),"\n",o.createElement(n.p,null,"If, however, we're looking at ",o.createElement(n.strong,null,"space"),', then we can treat that space as an equal\nnumber of file memory blocks from the end of the diskmap ("moving" them to the front).\n',o.createElement(n.code,null,"moveAndCountChunks()"),' performs this work, "moving" as many blocks of one file as\npossible. It calculates what that file (or partial file)\'s contribution to the checksum\nshould be, then updates the remaining size and start index of the space to reflect\nthe space "used" when "moving" the file memory. It repeats this process until the\ncurrent block of space has been entirely used, or we\'ve run out of file memory to\nmove into it.'),"\n",o.createElement(t,{boxname:"one",names:"typescript|C#"},o.createElement(n.pre,null,o.createElement(n.code,{className:"language-js"},"\nexport function partOne(input: string[]): number | string {\n  const spaces = parse(input)\n  return calculateChecksum(spaces)\n}\n\nInterface Memory {\n  file: boolean\n  id: number\n  length: number\n  index: number\n}\n\nfunction parse(input: string[]): Memory[] {\n  const memoryBlocks: Memory[] = []\n  let file = true\n  let index = 0\n  let id = 0\n  input[0].split('').forEach((c) => {\n    let length = parseInt(c)\n    memoryBlocks.push({ file, length, id: file ? id : -1, index })\n    index += length\n    id = file ? id + 1 : id\n    file = !file\n  })\n  return memoryBlocks\n}\n\nfunction calculateChecksum(memoryBlocks: Memory[]): number {\n  let checksum = 0\n  let lastFileIndex = memoryBlocks.findLastIndex((x) => x.file)\n\n  memoryBlocks.forEach((space) => {\n    if (space.file) {\n      checksum += gaussSum(space.id, space.length, space.index)\n      space.file = false\n    } else {\n      while (space.length > 0) {\n        const origin = memoryBlocks[lastFileIndex]\n        if (!origin.file) return checksum\n\n        checksum += moveAndCountChunks(origin, space)\n\n        if (origin.length == 0) {\n          origin.file = false\n          lastFileIndex -= 2\n        }\n      }\n    }\n  })\n  return checksum\n}\n\nfunction moveAndCountChunks(origin: Memory, destination: Memory): number {\n  const bigger = origin.length > destination.length ? origin : destination\n  const smaller = origin.length > destination.length ? destination : origin\n\n  const checksum = gaussSum(origin.id, smaller.length, destination.index)\n\n  destination.index += smaller.length\n  bigger.length -= smaller.length\n  smaller.length = 0\n\n  return checksum\n}\n\nfunction gaussSum(id: number, length: number, index: number): number {\n  return Math.floor(id * (length / 2) * (2 * index + length - 1))\n}\n")),o.createElement(n.pre,null,o.createElement(n.code,{className:"language-csharp"},"internal class Memory(bool file, long length, int id, long index)\n{\n    internal bool File = file;\n    internal int Id = id;\n    internal long Length = length;\n    internal long Index = index;\n}\n\npublic override object PartOne()\n{\n    var blocks = ParseInput();\n\n    return CalculateChecksum(blocks);\n}\n\nprivate List<Memory> ParseInput()\n{\n    List<Memory> memoryBlocks = [];\n\n    bool file = true;\n    long index = 0;\n    var id = 0;\n    foreach (char c in Input[0])\n    {\n        var length = int.Parse(c.ToString());\n        memoryBlocks.Add(new(file, length, file ? id : -1, index));\n        index += length;\n        if (file)\n            id++;\n        file = !file;\n    }\n    return memoryBlocks;\n}\n\nprivate static double CalculateChecksum(List<Memory> memoryBlocks)\n{\n    double checksum = 0;\n    int lastFileIndex = memoryBlocks.FindLastIndex(x => x.File);\n\n    foreach (Memory block in memoryBlocks)\n    {\n        if (block.File)\n        {\n            checksum += GaussSum(block.Id, block.Length, block.Index);\n            block.File = false;\n        }\n        else\n        {\n            while (block.Length > 0)\n            {\n                Memory origin = memoryBlocks[lastFileIndex];\n                if (!origin.File)\n                    return checksum;\n\n                checksum += MoveAndCountChunks(origin, block);\n\n                if (origin.Length == 0)\n                {\n                    origin.File = false;\n                    lastFileIndex -= 2;\n                }\n            }\n        }\n    }\n    return checksum;\n}\n\nprivate static double MoveAndCountChunks(Memory origin, Memory destination)\n{\n    Memory bigger, smaller;\n    if (origin.Length > destination.Length)\n    {\n        bigger = origin;\n        smaller = destination;\n    }\n    else\n    {\n        bigger = destination;\n        smaller = origin;\n    }\n\n    var checksum = GaussSum(origin.Id, smaller.Length, destination.Index);\n\n    destination.Index += smaller.Length;\n    bigger.Length -= smaller.Length;\n    smaller.Length = 0;\n\n    return checksum;\n}\n\nprivate static double GaussSum(int id, long length, long index) => Math.Floor(id * (length / 2d) * (index + index + length - 1));\n\n"))),"\n",o.createElement(n.h2,null,"Part Two"),"\n",o.createElement(n.p,null,'Much like my approach to the first part, I chose to model it via the disk map rather than actually "moving" files.'),"\n",o.createElement("br"),"\n",o.createElement(n.p,null,'This is a little simpler than the first part - we iterate through the disk map\'s\nmemory in reverse, finding the first space they can wholly fit into (if any), and\nrecording their (potentially new) checksum value. Finally, we reduce the length of\nthe space and update its index to finish representing "moving" the file into it.'),"\n",o.createElement(t,{boxname:"two",names:"typescript|C#"},o.createElement(n.pre,null,o.createElement(n.code,{className:"language-js"},"export function partTwo(input: string[]): number | string {\n  const memoryBlocks = parse(input)\n  return calculateNoFragChecksum(memoryBlocks)\n}\n\nfunction calculateNoFragChecksum(memoryBlocks: Memory[]): number {\n  let total = 0\n  const lastIndex = memoryBlocks.findLastIndex((x) => x.file)\n\n  for (let i = lastIndex; i > -1; i -= 2) {\n    const origin = memoryBlocks[i]\n    const destination = tryFindDestination(memoryBlocks, i)\n    if (!destination) total += gaussSum(origin.id, origin.length, origin.index)\n    else {\n      total += gaussSum(origin.id, origin.length, destination.index)\n      destination.length -= origin.length\n      destination.index += origin.length\n    }\n  }\n  return total\n}\n\nfunction tryFindDestination(\n  memoryBlocks: Memory[],\n  toMoveIndex: number\n): Memory | null {\n  let firstFit = memoryBlocks.findIndex(\n    (x) => !x.file && x.length >= memoryBlocks[toMoveIndex].length\n  )\n  return firstFit != -1 && firstFit < toMoveIndex\n    ? memoryBlocks[firstFit]\n    : null\n}\n")),o.createElement(n.pre,null,o.createElement(n.code,{className:"language-csharp"},"public override object PartTwo()\n{\n    var blocks = ParseInput();\n\n    return CalculateNoFragChecksum(blocks);\n}\n\nprivate static double CalculateNoFragChecksum(List<Memory> memoryBlocks)\n{\n    double total = 0D;\n    int last = memoryBlocks.FindLastIndex(x => x.File);\n\n    for (int i = last; i > -1; i -= 2)\n    {\n        Memory origin = memoryBlocks[i];\n        if (!TryFindDestination(memoryBlocks, i, out Memory? destination))\n        {\n            total += GaussSum(origin.Id, origin.Length, origin.Index);\n            continue;\n        }\n        total += GaussSum(origin.Id, origin.Length, destination!.Index);\n        destination.Length -= origin.Length;\n        destination.Index += origin.Length;\n    }\n    return total;\n}\n\nprivate static bool TryFindDestination(List<Memory> memoryBlocks, int toMoveIndex, out Memory? destination)\n{\n    int firstFit = memoryBlocks.FindIndex(x => !x.File && x.Length >= memoryBlocks[toMoveIndex].Length);\n    destination = (firstFit != -1 && firstFit < toMoveIndex) ? memoryBlocks[firstFit] : null;\n\n    return destination != null;\n}\n"))))}var r=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,i.RP)(),e.components);return n?o.createElement(n,e,o.createElement(l,e)):l(e)};var a=t(2779),s=t(7206),c=t(791),m=t(4813),u=t(572);const d={CodeBox:a.A};function h(e){let{pageContext:n,children:t}=e;return o.createElement(o.Fragment,null,o.createElement(m.A,null),o.createElement("div",{className:"min-h-screen bg-chicPrimary"},o.createElement(c.A,{props:n.list}),o.createElement("div",{className:"adventofcode max-w-[60%] ml-[20%]"},o.createElement("h1",null,o.createElement("a",{href:"https://adventofcode.com/"+n.year+"/day/"+n.puzz},n.year+" Day "+n.puzz+" - "+n.title)),o.createElement(i.xA,{components:d},t),n.puzz&&n.year?o.createElement(s.A,{year:n.year,puzz:n.puzz}):o.createElement(o.Fragment,null))),o.createElement(u.A,null))}function g(e){return o.createElement(h,e,o.createElement(r,e))}const p=()=>o.createElement(o.Fragment,null,o.createElement("title",null,"Joel-Allan-NZ - Advent of Code"),o.createElement("html",{lang:"en"}),o.createElement("link",{rel:"preconnect",href:"https://fonts.googleapis.com"}),o.createElement("link",{rel:"preconnect",href:"https://fonts.gstatic.com"}),o.createElement("link",{href:"https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&family=VT323&display=swap",rel:"stylesheet"}))}}]);
//# sourceMappingURL=component---src-components-layout-tsx-content-file-path-days-2024-9-mdx-c800c32427ffaa2f85fd.js.map