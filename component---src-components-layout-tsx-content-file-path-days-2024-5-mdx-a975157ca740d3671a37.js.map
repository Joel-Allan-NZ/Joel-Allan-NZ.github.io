{"version":3,"file":"component---src-components-layout-tsx-content-file-path-days-2024-5-mdx-a975157ca740d3671a37.js","mappings":"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","sources":["webpack://joel-allan-nz.github.io/./days/2024/5.mdx","webpack://joel-allan-nz.github.io/./src/components/Layout.tsx"],"sourcesContent":["/*@jsxRuntime classic @jsx React.createElement @jsxFrag React.Fragment*/\nimport {useMDXComponents as _provideComponents} from \"@mdx-js/react\";\nimport React from \"react\";\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    p: \"p\",\n    pre: \"pre\",\n    code: \"code\"\n  }, _provideComponents(), props.components), {CodeBox} = _components;\n  if (!CodeBox) _missingMdxReference(\"CodeBox\", true);\n  return React.createElement(React.Fragment, null, React.createElement(_components.h2, null, \"Part One\"), \"\\n\", React.createElement(_components.p, null, \"This first part is pretty straightforward: parse the input (in my case, very messily), then test the update collections to filter out the valid ones, and sum the middle values of each (easy, as they all have odd lengths).\"), \"\\n\", React.createElement(_components.p, null, React.createElement(\"br\"), \"I opted to model it as a simple unweighted graph, in a basic Node,Edges\\nDictionary/Map. Nothing fancy here.\"), \"\\n\", React.createElement(CodeBox, {\n    names: \"typescript|C#\"\n  }, React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-js\"\n  }, \"export function partOne(input: string[]): number | string {\\n  const { edges, updates } = parse(input)\\n  return updates.reduce(\\n    (total, update) =>\\n      isValidOrder(edges, update)\\n        ? total + update[Math.floor(update.length / 2)]\\n        : total,\\n    0\\n  )\\n}\\n\\nfunction isValidOrder(edges: Map<number, number[]>, update: number[]) {\\n  let valid = update.every((item, index) => {\\n    return (\\n      update.slice(index + 1).find((after) => {\\n        return edges.has(after) && edges.get(after)!.includes(item)\\n      }) === undefined\\n    )\\n  })\\n  return valid\\n}\\n\\nfunction parse(input: string[]): {\\n  edges: Map<number, number[]>\\n  updates: number[][]\\n} {\\n  const edges = new Map<number, number[]>()\\n  const updates: number[][] = []\\n  let updating = false\\n\\n  input.forEach((line) => {\\n    if (!line || line.length == 0) updating = true\\n    else if (updating) {\\n      updates.push(line.split(',').map((x) => parseInt(x)))\\n    } else if (!updating) {\\n      const split = line.split('|').map((x) => parseInt(x))\\n      if (!edges.has(split[0])) edges.set(split[0], [split[1]])\\n      else if (!edges.get(split[0])!.includes(split[1]))\\n        edges.set(split[0], [...edges.get(split[0])!, split[1]])\\n    }\\n  })\\n\\n  return { edges, updates }\\n}\\n\")), React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-csharp\"\n  }, \"public override object PartOne()\\n{\\n    var (edges, updates) = Parse();\\n    var c = updates.Count(update => IsValidOrder(edges, update));\\n    return updates.Sum(update => IsValidOrder(edges, update) ? update[update.Count / 2] : 0);\\n}\\n\\nprivate static bool IsValidOrder(Dictionary<int, HashSet<int>> edges, List<int> order)\\n{\\n    return Enumerable.Range(0, order.Count).All(index =>\\n    {\\n        return !order.Skip(index + 1).Any(j =>\\n        {\\n            return edges.TryGetValue(j, out var result) && result.Contains(order[index]);\\n        });\\n    });\\n}\\n\\nprivate (Dictionary<int, HashSet<int>>, IEnumerable<List<int>>) Parse()\\n{\\n    IEnumerable<List<int>> order = [];\\n    Dictionary<int, HashSet<int>> edges = [];\\n    bool readingUpdates = false;\\n\\n    foreach (var line in Input)\\n    {\\n        if (string.IsNullOrEmpty(line))\\n        {\\n            readingUpdates = true;\\n            continue;\\n        }\\n        if (!readingUpdates)\\n        {\\n            var rule = line.Split('|').Select(x => int.Parse(x)).ToArray();\\n            if (edges.TryGetValue(rule[0], out var xEdges))\\n                edges[rule[0]].Add(rule[1]);\\n            else\\n                edges[rule[0]] = [rule[1]];\\n        }\\n        else\\n        {\\n            order = order.Append(line.Split(',').Select(x => int.Parse(x)).ToList());\\n        }\\n    }\\n    return (edges, order);\\n}\\n\"))), \"\\n\", React.createElement(_components.h2, null, \"Part Two\"), \"\\n\", React.createElement(_components.p, null, \"The first time I got tricked this year! I (wrongly) assumed I could quickly solve the entire graph with a topological sort, but alas the input had a (hamiltonian) cycle. A quick inspection of the input suggested the graph was complete, which allows for an even lazier approach than implementing a tsort: we can just use the default sort algorithm and check only the immediate edges for any given node.\"), \"\\n\", React.createElement(\"br\"), \"\\n\", React.createElement(_components.p, null, \"While writing the TS solution I had a small bug in the \", React.createElement(_components.code, null, \"parse()\"), \" code that didn't\\ncause any issues in part one. I started going down the rabbit hole of testing whether\\n\", React.createElement(_components.code, null, \"Array.prototype.sort()\"), \" was meaningfully different from C#'s \", React.createElement(_components.code, null, \"List<T>.Sort(IComparer<T>)\"), \"\\nbefore noticing the simple problem. Hooray for being an idiot!\"), \"\\n\", React.createElement(CodeBox, {\n    names: \"typescript|C#\"\n  }, React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-js\"\n  }, \"export function partTwo(input: string[]): number | string {\\n  const { edges, updates } = parse(input)\\n  return updates.reduce((total, update) => {\\n    if (isValidOrder(edges, update)) return total\\n    update.sort((a, b) => {\\n      return edges.get(a)!.includes(b) ? -1 : edges.get(b)!.includes(a) ? 1 : 0\\n    })\\n    return total + update[Math.floor(update.length / 2)]\\n  }, 0)\\n}\\n\")), React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-csharp\"\n  }, \"public override object PartTwo()\\n{\\n    var (edges, updates) = Parse();\\n    return updates.Sum(update =>\\n    {\\n        if (IsValidOrder(edges, update))\\n            return 0;\\n        update.Sort(new NodeComparer(edges));\\n        return update[update.Count / 2];\\n    });\\n}\\n\\ninternal class NodeComparer(Dictionary<int, HashSet<int>> e) : IComparer<int>\\n{\\n    private readonly Dictionary<int, HashSet<int>> edges = e;\\n    public int Compare(int x, int y)\\n    {\\n        if (edges[x].Contains(y)) return -1;\\n        if (edges[y].Contains(x)) return 1;\\n        return 0;\\n    }\\n}\\n\"))));\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? React.createElement(MDXLayout, props, React.createElement(_createMdxContent, props)) : _createMdxContent(props);\n}\nexport default MDXContent;\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","import GATSBY_COMPILED_MDX from \"/home/joel/personal/advent-of-code/joel-allan-nz.github.io/days/2024/5.mdx\";\nimport React from 'react';\nimport {MDXProvider} from '@mdx-js/react';\nimport CodeBox from './CodeBox';\nimport TryYourself from './TryYourself';\nimport AdventSideNav from './AdventSideNav';\nimport Header from './Header';\nimport Footer from './Footer';\nconst shortcodes = {\n  CodeBox\n};\nfunction Layout(_ref) {\n  let {pageContext, children} = _ref;\n  return React.createElement(React.Fragment, null, React.createElement(Header, null), React.createElement(\"div\", {\n    className: \"min-h-screen bg-chicPrimary\"\n  }, React.createElement(AdventSideNav, {\n    props: pageContext.list\n  }), React.createElement(\"div\", {\n    className: \"adventofcode max-w-[60%] ml-[20%]\"\n  }, React.createElement(\"h1\", null, React.createElement(\"a\", {\n    href: \"https://adventofcode.com/\" + pageContext.year + \"/day/\" + pageContext.puzz\n  }, pageContext.year + \" Day \" + pageContext.puzz + \" - \" + pageContext.title)), React.createElement(MDXProvider, {\n    components: shortcodes\n  }, children), pageContext.puzz && pageContext.year ? React.createElement(TryYourself, {\n    year: pageContext.year,\n    puzz: pageContext.puzz\n  }) : React.createElement(React.Fragment, null))), React.createElement(Footer, null));\n}\nexport default function GatsbyMDXWrapper(props) {\n  return React.createElement(Layout, props, React.createElement(GATSBY_COMPILED_MDX, props));\n}\nexport const Head = () => React.createElement(React.Fragment, null, React.createElement(\"title\", null, \"Joel-Allan-NZ - Advent of Code\"), React.createElement(\"html\", {\n  lang: \"en\"\n}), React.createElement(\"link\", {\n  rel: \"preconnect\",\n  href: \"https://fonts.googleapis.com\"\n}), React.createElement(\"link\", {\n  rel: \"preconnect\",\n  href: \"https://fonts.gstatic.com\"\n}), React.createElement(\"link\", {\n  href: \"https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&family=VT323&display=swap\",\n  rel: \"stylesheet\"\n}));\n"],"names":["_createMdxContent","props","_components","Object","assign","h2","p","pre","code","_provideComponents","components","CodeBox","id","component","Error","_missingMdxReference","React","names","className","wrapper","MDXLayout","shortcodes","Layout","_ref","pageContext","children","Header","AdventSideNav","list","href","year","puzz","title","MDXProvider","TryYourself","Footer","GatsbyMDXWrapper","GATSBY_COMPILED_MDX","Head","lang","rel"],"sourceRoot":""}