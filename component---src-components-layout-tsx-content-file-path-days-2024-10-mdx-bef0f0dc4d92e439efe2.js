"use strict";(self.webpackChunkjoel_allan_nz_github_io=self.webpackChunkjoel_allan_nz_github_io||[]).push([[8423],{4692:function(e,n,t){t.r(n),t.d(n,{Head:function(){return f},default:function(){return m}});var a=t(8453),r=t(6540);function i(e){const n=Object.assign({h2:"h2",p:"p",code:"code",pre:"pre"},(0,a.RP)(),e.components),{CodeBox:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("CodeBox",!0),r.createElement(r.Fragment,null,r.createElement(n.h2,null,"Part One"),"\n",r.createElement(n.p,null,"I chose to be lazy, and do 90% of the work while parsing the input. If we treat the data as a set of nodes that only have edges to a direct neighbour in the same row or column that has a value exactly one greater, then we effectively have a graph of valid trails."),"\n",r.createElement("br"),"\n",r.createElement(n.p,null,"From there it's as simple as a quick breadth first search to find the number of 9s reachable from each trailhead."),"\n",r.createElement("br"),"\n",r.createElement(n.p,null,"I opted for a non-recursive approach in the C# solution, purely because recursion is never as reliable as an interative method (stack overflow!), and the C# syntax is brief enough to be easily read. The C# solution also makes use of a basic helper class ",r.createElement(n.code,null,"GridGraph<Tvalue, TedgeValue>")," that I wrote to lazily work with graphs that use grid coordinates - a frequent theme in Advent of Code!"),"\n",r.createElement(t,{boxname:"one",names:"typescript|C#"},r.createElement(n.pre,null,r.createElement(n.code,{className:"language-js"},"export function partOne(input: string[]): number | string {\n  const trails = parse(input)\n  const trailHeads = trails.flatMap((row) =>\n    row.filter((col) => col.value == 0)\n  )\n\n  return trailHeads.reduce(\n    (total, head) =>\n      total + findNines(trails, head, new Map<number, Set<number>>()),\n    0\n  )\n}\n\nfunction findNines(\n  trails: Node[][],\n  current: Node,\n  nines: Map<number, Set<number>>\n) {\n  current.edges.forEach((edge) => {\n    const node = trails[edge[0]][edge[1]]\n    if (node.value == 9) {\n      if (!nines.has(node.y)) nines.set(node.y, new Set<number>([node.x]))\n      else nines.get(node.y)?.add(node.x)\n    } else findNines(trails, node, nines)\n  })\n\n  return nines.keys().reduce((t, y) => nines.get(y)!.size + t, 0)\n}\n\ninterface Node {\n  value: number\n  edges: number[][]\n  x: number\n  y: number\n}\n\nfunction parse(input: string[]): Node[][] {\n  const trailMap: Node[][] = []\n  input.forEach((line, y) => {\n    trailMap.push([])\n    line.split('').forEach((val, x) => {\n      trailMap[y].push({ value: parseInt(val), edges: [], x, y })\n\n      if (y != 0) {\n        if (trailMap[y - 1][x].value == trailMap[y][x].value + 1)\n          trailMap[y][x].edges.push([y - 1, x])\n        else if (trailMap[y - 1][x].value == trailMap[y][x].value - 1)\n          trailMap[y - 1][x].edges.push([y, x])\n      }\n\n      if (x != 0) {\n        if (trailMap[y][x - 1].value == trailMap[y][x].value + 1)\n          trailMap[y][x].edges.push([y, x - 1])\n        else if (trailMap[y][x - 1].value == trailMap[y][x].value - 1)\n          trailMap[y][x - 1].edges.push([y, x])\n      }\n    })\n  })\n  return trailMap\n}\n")),r.createElement(n.pre,null,r.createElement(n.code,{className:"language-csharp"},"public override object PartOne()\n{\n    GridGraph<int, int> graph = Parse();\n    var trailHeads = graph.Nodes.Where(x => x.Value == 0);\n    int score = 0;\n\n    foreach (var trailHead in trailHeads)\n    {\n        HashSet<Node<int, int>> nines = [];\n        Queue<Node<int, int>> toVisit = [];\n        toVisit.Enqueue(trailHead);\n\n        while (toVisit.Count > 0)\n        {\n            var current = toVisit.Dequeue();\n            foreach (var neighbour in current.Edges.Keys)\n            {\n                if (neighbour.Value == 9)\n                    nines.Add(neighbour);\n                else\n                    toVisit.Enqueue(neighbour);\n            }\n        }\n        score += nines.Count;\n    }\n    return score;\n}\n\nprivate GridGraph<int, int> Parse()\n{\n    GridGraph<int, int> graph = new();\n\n    for (int i = 0; i < Input.Length; i++)\n    {\n        for (int j = 0; j < Input[i].Length; j++)\n        {\n            if (Input[i][j] != '.')\n                graph.AddNodeWithGridNeighbours(j, i, int.Parse(Input[i][j].ToString()), true, (x, y) => x.Value == y.Value - 1);\n        }\n    }\n    return graph;\n}\n"))),"\n",r.createElement(n.h2,null,"Part Two"),"\n",r.createElement(n.p,null,"A theme of these early puzzles seems to be simple/simpler part twos. I used almost an identical BFS algorithm, except it no longer had to ensure that found 9s are unique. Easy peasy."),"\n",r.createElement(t,{boxname:"two",names:"typescript|C#"},r.createElement(n.pre,null,r.createElement(n.code,{className:"language-js"},"export function partTwo(input: string[]): number | string {\n  const trails = parse(input)\n  const trailHeads = trails.flatMap((row) =>\n    row.filter((col) => col.value == 0)\n  )\n\n  return trailHeads.reduce((total, head) => {\n    let score = 0\n    const toVisit: Node[] = [head]\n\n    while (toVisit.length > 0) {\n      const current = toVisit.shift()\n\n      current!.edges.forEach((edge) => {\n        const node = trails[edge[0]][edge[1]]\n        if (node.value == 9) score++\n        else toVisit.push(node)\n      })\n    }\n\n    return score + total\n  }, 0)\n}\n\n")),r.createElement(n.pre,null,r.createElement(n.code,{className:"language-csharp"},"public override object PartTwo()\n{\n    GridGraph<int, int> graph = Parse();\n    var trailHeads = graph.Nodes.Where(x => x.Value == 0);\n    int score = 0;\n    foreach (var trailHead in trailHeads)\n    {\n        Queue<Node<int, int>> toVisit = [];\n        toVisit.Enqueue(trailHead);\n\n        while (toVisit.Count > 0)\n        {\n            var current = toVisit.Dequeue();\n            foreach (var neighbour in current.Edges.Keys)\n            {\n                if (neighbour.Value == 9)\n                    score++;\n                else\n                    toVisit.Enqueue(neighbour);\n            }\n        }\n    }\n    return score;\n}\n"))))}var l=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,a.RP)(),e.components);return n?r.createElement(n,e,r.createElement(i,e)):i(e)};var o=t(2779),s=t(7206),u=t(791),c=t(4813),d=t(572);const p={CodeBox:o.A};function h(e){let{pageContext:n,children:t}=e;return r.createElement(r.Fragment,null,r.createElement(c.A,null),r.createElement("div",{className:"min-h-screen bg-chicPrimary"},r.createElement(u.A,{props:n.list}),r.createElement("div",{className:"adventofcode max-w-[60%] ml-[20%]"},r.createElement("h1",null,r.createElement("a",{href:"https://adventofcode.com/"+n.year+"/day/"+n.puzz},n.year+" Day "+n.puzz+" - "+n.title)),r.createElement(a.xA,{components:p},t),n.puzz&&n.year?r.createElement(s.A,{year:n.year,puzz:n.puzz}):r.createElement(r.Fragment,null))),r.createElement(d.A,null))}function m(e){return r.createElement(h,e,r.createElement(l,e))}const f=()=>r.createElement(r.Fragment,null,r.createElement("title",null,"Joel-Allan-NZ - Advent of Code"),r.createElement("html",{lang:"en"}),r.createElement("link",{rel:"preconnect",href:"https://fonts.googleapis.com"}),r.createElement("link",{rel:"preconnect",href:"https://fonts.gstatic.com"}),r.createElement("link",{href:"https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&family=VT323&display=swap",rel:"stylesheet"}))}}]);
//# sourceMappingURL=component---src-components-layout-tsx-content-file-path-days-2024-10-mdx-bef0f0dc4d92e439efe2.js.map