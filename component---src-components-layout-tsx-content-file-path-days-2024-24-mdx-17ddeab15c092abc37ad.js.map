{"version":3,"file":"component---src-components-layout-tsx-content-file-path-days-2024-24-mdx-17ddeab15c092abc37ad.js","mappings":"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","sources":["webpack://joel-allan-nz.github.io/./days/2024/24.mdx","webpack://joel-allan-nz.github.io/./src/components/Layout.tsx"],"sourcesContent":["/*@jsxRuntime classic @jsx React.createElement @jsxFrag React.Fragment*/\nimport {useMDXComponents as _provideComponents} from \"@mdx-js/react\";\nimport React from \"react\";\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    p: \"p\",\n    pre: \"pre\",\n    code: \"code\"\n  }, _provideComponents(), props.components), {CodeBox} = _components;\n  if (!CodeBox) _missingMdxReference(\"CodeBox\", true);\n  return React.createElement(React.Fragment, null, React.createElement(_components.h2, null, \"Part One\"), \"\\n\", React.createElement(_components.p, null, \"As is so often the case with Advent of Code, the first part is mostly just setting things up.\"), \"\\n\", React.createElement(\"br\"), \"\\n\", React.createElement(_components.p, null, \"All we need to do is model the system of wires, run the system until it's in its\\nfinal state, and convert a binary string to a decimal number.\"), \"\\n\", React.createElement(CodeBox, {\n    boxname: \"one\",\n    names: \"typescript|C#\"\n  }, React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-js\"\n  }, \"export function partOne(input: string[]): number | string {\\n  const { wires, gatesByWire } = parse(input)\\n  const binaryString = runSystem(wires, gatesByWire)\\n  return parseInt(binaryString, 2)\\n}\\n\\ninterface Gate {\\n  a: string\\n  b: string\\n  operation: string\\n  output: string\\n}\\n\\nfunction parse(input: string[]): {\\n  wires: Map<string, boolean | undefined>\\n  gatesByWire: Map<string, Gate[]>\\n} {\\n  const wires = new Map<string, boolean | undefined>()\\n  const gatesByWire = new Map<string, Gate[]>()\\n  let gates = false\\n\\n  input.forEach((line) => {\\n    if (!line || line.length == 0) {\\n      gates = true\\n    } else {\\n      if (gates) {\\n        const split = line.split(/ /)\\n        const gate: Gate = {\\n          a: split[0],\\n          b: split[2],\\n          operation: split[1],\\n          output: split[4],\\n        }\\n        if (!gatesByWire.has(gate.a)) gatesByWire.set(gate.a, [gate])\\n        else gatesByWire.get(gate.a)?.push(gate)\\n        if (!gatesByWire.has(gate.b)) gatesByWire.set(gate.b, [gate])\\n        else gatesByWire.get(gate.b)?.push(gate)\\n\\n        if (!wires.has(gate.a)) wires.set(gate.a, undefined)\\n        if (!wires.has(gate.b)) wires.set(gate.b, undefined)\\n        if (!wires.has(gate.output)) wires.set(gate.output, undefined)\\n      } else {\\n        const split = line.split(/: /)\\n        wires.set(split[0], split[1] === '1')\\n      }\\n    }\\n  })\\n  return { wires, gatesByWire }\\n}\\n\\nfunction runSystem(\\n  wires: Map<string, boolean | undefined>,\\n  gates: Map<string, Gate[]>\\n): string {\\n  let gatesToProcess = [...gates.values().toArray()].flatMap((x) => x)\\n  let gatesToProcessNext: Gate[] = []\\n\\n  while (gatesToProcess.length > 0) {\\n    const currentGate = gatesToProcess.shift()!\\n    const gateResult = resolveGate(currentGate, wires)\\n    if (wires.get(currentGate.output) != gateResult) {\\n      wires.set(currentGate.output, gateResult)\\n      if (gates.has(currentGate.output)) {\\n        gatesToProcessNext = [\\n          ...gatesToProcessNext,\\n          ...gates.get(currentGate.output)!,\\n        ]\\n      }\\n    }\\n    if (gatesToProcess.length == 0) {\\n      gatesToProcess = gatesToProcessNext\\n      gatesToProcessNext = []\\n    }\\n  }\\n\\n  return wires\\n    .keys()\\n    .filter((x) => x.startsWith('z'))\\n    .toArray()\\n    .sort((x, y) => (y > x ? 1 : y == x ? 0 : -1))\\n    .reduce(\\n      (total, current) => (wires.get(current) ? total + '1' : total + '0'),\\n      ''\\n    )\\n}\\n\\nfunction resolveGate(\\n  gate: Gate,\\n  wires: Map<string, boolean | undefined>\\n): boolean | undefined {\\n  const a = wires.get(gate.a)\\n  const b = wires.get(gate.b)\\n\\n  if (a === undefined || b === undefined) return undefined\\n  if (gate.operation == 'AND') return a && b\\n  if (gate.operation == 'OR') return a || b\\n  if (gate.operation == 'XOR') return a != b\\n}\\n\")), React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-csharp\"\n  }, \"public override object PartOne()\\n{\\n    var (wires, gates) = Parse();\\n    var binaryString = RunSystem(wires, gates);\\n    return Convert.ToInt64(binaryString, 2);\\n}\\n\\nprivate static string RunSystem(Dictionary<string, bool?> wires, Dictionary<string, List<Gate>> gates)\\n{\\n    Queue<Gate> gatesToProcess = new(gates.SelectMany(x => x.Value).ToHashSet());\\n    Queue<Gate> gatesToProcessNextStep = [];\\n\\n    while (gatesToProcess.Count > 0)\\n    {\\n        var currentGate = gatesToProcess.Dequeue();\\n        var gateResult = ResolveGate(currentGate, wires);\\n        if (wires[currentGate.Output] != gateResult)\\n        {\\n            wires[currentGate.Output] = gateResult;\\n            if (gates.TryGetValue(currentGate.Output, out var nextGates))\\n            {\\n                foreach (var potentiallyChangedGate in nextGates)\\n                    gatesToProcessNextStep.Enqueue(potentiallyChangedGate);\\n            }\\n        }\\n\\n        if (gatesToProcess.Count == 0)\\n        {\\n            gatesToProcess = gatesToProcessNextStep;\\n            gatesToProcessNextStep = [];\\n        }\\n    }\\n\\n    return wires.Where(x => x.Key.StartsWith('z'))\\n                .OrderByDescending(x => x.Key)\\n                .Aggregate(\\\"\\\", (x, y) => x + (y.Value == true ? \\\"1\\\" : \\\"0\\\"));\\n}\\n\\nprivate (Dictionary<string, bool?> wires, Dictionary<string, List<Gate>> gates) Parse()\\n{\\n    Dictionary<string, bool?> wires = [];\\n    Dictionary<string, List<Gate>> gatesByWire = [];\\n    bool gates = false;\\n\\n    foreach (var line in Input)\\n    {\\n        if (string.IsNullOrEmpty(line))\\n        {\\n            gates = true;\\n            continue;\\n        }\\n        if (gates)\\n        {\\n            var split = line.Split([' ', '-', '>'], StringSplitOptions.RemoveEmptyEntries);\\n\\n            Gate gate = new(split[0], split[2], OperationFromString(split[1]), split[3]);\\n            gatesByWire.AddToOrCreateCollection(gate.A, gate);\\n            gatesByWire.AddToOrCreateCollection(gate.B, gate);\\n\\n            if (!wires.ContainsKey(gate.A))\\n                wires.Add(gate.A, null);\\n            if (!wires.ContainsKey(gate.B))\\n                wires.Add(gate.B, null);\\n            if (!wires.ContainsKey(gate.Output))\\n                wires.Add(gate.Output, null);\\n        }\\n        else\\n        {\\n            var split = line.Split([' ', ':'], StringSplitOptions.RemoveEmptyEntries);\\n            wires.Add(split[0], split[1].Equals(\\\"1\\\"));\\n        }\\n    }\\n\\n    return (wires, gatesByWire);\\n}\\n\\nprivate static bool? ResolveGate(Gate gate, Dictionary<string, bool?> wires)\\n{\\n    if (wires[gate.A] == null || wires[gate.B] == null)\\n        return null;\\n\\n    bool a = wires[gate.A] == true, b = wires[gate.B] == true;\\n    return gate.Operation switch\\n    {\\n        GateOperation.AND => a && b,\\n        GateOperation.OR => a || b,\\n        _ => a != b,\\n    };\\n}\\n\\nprivate static GateOperation OperationFromString(string s) => s switch\\n{\\n    \\\"AND\\\" => GateOperation.AND,\\n    \\\"OR\\\" => GateOperation.OR,\\n    _ => GateOperation.XOR,\\n};\\n\\ninternal struct Gate(string wireA, string wireB, GateOperation operation, string outputWire)\\n{\\n    internal string A = wireA;\\n    internal string B = wireB;\\n    internal GateOperation Operation = operation;\\n    internal string Output = outputWire;\\n\\n}\\ninternal enum GateOperation { AND, OR, XOR };\\n\"))), \"\\n\", React.createElement(_components.h2, null, \"Part Two\"), \"\\n\", React.createElement(_components.p, null, \"The puzzle gives us the critical piece of information without needing to deduce it: the system is simulating the addition of two binary numbers.\"), \"\\n\", React.createElement(\"br\"), \"\\n\", React.createElement(_components.p, null, \"Once we know that, we can simplify the system a little to look for where logic gates\\naren't currently correct for the \", React.createElement(\"a\", {\n    href: \"https://www.electronics-tutorials.ws/combination/comb_7.html\"\n  }, \"binary addition\"), \" process, which is exactly what we're looking for. So I simulate some \", React.createElement(\"a\", {\n    href: \"https://en.wikipedia.org/wiki/Adder_(electronics)\"\n  }, \"adders\"), \" to find the logic gate sets that aren't correct. It requires a little domain specific knowledge, but the actual code is pretty simple.\"), \"\\n\", React.createElement(CodeBox, {\n    boxname: \"two\",\n    names: \"typescript|C#\"\n  }, React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-js\"\n  }, \"eexport function partTwo(input: string[]): number | string {\\n  const { wires, gatesByWire } = parse(input)\\n  const zBits =\\n    'z' +\\n    wires\\n      .keys()\\n      .reduce((sum, wire) => (wire.startsWith('z') ? sum + 1 : sum), -1)\\n  const gates = [...new Set([...gatesByWire.values().flatMap((x) => x)])]\\n  const incorrectGates = gates.filter(\\n    (gate) => !isValidGate(gatesByWire, gate, zBits)\\n  )\\n\\n  return incorrectGates\\n    .map((x) => x.output)\\n    .sort()\\n    .join(',')\\n}\\n\\nfunction isValidGate(\\n  gatesByWire: Map<string, Gate[]>,\\n  gate: Gate,\\n  zBits: string\\n): boolean {\\n  if (isFullAdderStart(gate)) {\\n    if (gatesByWire.has(gate.output)) {\\n      const childGates = gatesByWire.get(gate.output)!\\n      if (\\n        gate.operation == 'AND' &&\\n        childGates.some((x) => x.operation == 'AND')\\n      )\\n        return false\\n      if (\\n        gate.operation == 'XOR' &&\\n        childGates.some((x) => x.operation == 'OR')\\n      )\\n        return false\\n    }\\n  }\\n  if (isFullAdderEnd(gate, zBits) && gate.operation != 'XOR') return false\\n  if (isAdderMiddle(gate) && gate.operation == 'XOR') return false\\n  return true\\n}\\n\\nfunction isAdderMiddle(gate: Gate): boolean {\\n  return (\\n    !gate.a.startsWith('x') &&\\n    !gate.a.startsWith('y') &&\\n    !gate.b.startsWith('x') &&\\n    !gate.b.startsWith('y') &&\\n    !gate.output.startsWith('z')\\n  )\\n}\\n\\nfunction isFullAdderEnd(gate: Gate, zBits: string): boolean {\\n  return gate.output.startsWith('z') && gate.output != zBits\\n}\\n\\nfunction isFullAdderStart(gate: Gate) {\\n  return (\\n    (gate.a.startsWith('x') || gate.a.startsWith('y')) &&\\n    (gate.b.startsWith('x') || gate.b.startsWith('y')) &&\\n    !gate.a.endsWith('00') &&\\n    !gate.b.endsWith('00')\\n  )\\n}\\n\")), React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-csharp\"\n  }, \"public override object PartTwo()\\n{\\n    var (wires, gates) = Parse();\\n    var bigEndianZ = \\\"z\\\" + (wires.Count(x => x.Key.StartsWith('z')) - 1);\\n    var gatesList = gates.Values.SelectMany(x => x).ToHashSet();\\n\\n    var incorrectGates = gatesList.Where(x => !IsValidGate(gates, x, bigEndianZ));\\n\\n    return incorrectGates.OrderBy(x => x.Output)\\n                         .Aggregate(\\\"\\\", (x, y) => x + ',' + y.Output)[1..];\\n}\\n\\nprivate static bool IsValidGate(Dictionary<string, List<Gate>> gates, Gate gate, string zMax)\\n{\\n    if (IsFullAdderStart(gate))\\n    {\\n        if (gates.TryGetValue(gate.Output, out var childGates))\\n        {\\n            if (gate.Operation == GateOperation.AND && childGates.Any(x => x.Operation == GateOperation.AND))\\n                return false;\\n            if (gate.Operation == GateOperation.XOR && childGates.Any(x => x.Operation == GateOperation.OR))\\n                return false;\\n        }\\n    }\\n\\n    if (IsFullAdderEnd(gate, zMax) && gate.Operation != GateOperation.XOR)\\n        return false;\\n\\n    if (IsAdderMiddle(gate) && gate.Operation == GateOperation.XOR)\\n        return false;\\n\\n    return true;\\n}\\n\\nprivate static bool IsAdderMiddle(Gate gate) => (!gate.A.StartsWith(['x', 'y']) && !gate.B.StartsWith(['x', 'y']) && !gate.Output.StartsWith('z'));\\n\\nprivate static bool IsFullAdderEnd(Gate gate, string bigEndianStart) => gate.Output.StartsWith('z') && gate.Output != bigEndianStart;\\n\\nprivate static bool IsFullAdderStart(Gate gate) => gate.A.StartsWith(['x', 'y']) && gate.B.StartsWith(['x', 'y']) && !gate.A.EndsWith(\\\"00\\\") && !gate.B.EndsWith(\\\"00\\\");\\n\\n\"))));\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? React.createElement(MDXLayout, props, React.createElement(_createMdxContent, props)) : _createMdxContent(props);\n}\nexport default MDXContent;\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","import GATSBY_COMPILED_MDX from \"/home/joel/personal/advent-of-code/joel-allan-nz.github.io/days/2024/24.mdx\";\nimport React from 'react';\nimport {MDXProvider} from '@mdx-js/react';\nimport CodeBox from './CodeBox';\nimport TryYourself from './TryYourself';\nimport AdventSideNav from './AdventSideNav';\nimport Header from './Header';\nimport Footer from './Footer';\nconst shortcodes = {\n  CodeBox\n};\nfunction Layout(_ref) {\n  let {pageContext, children} = _ref;\n  return React.createElement(React.Fragment, null, React.createElement(Header, null), React.createElement(\"div\", {\n    className: \"min-h-screen bg-chicPrimary\"\n  }, React.createElement(AdventSideNav, {\n    props: pageContext.list\n  }), React.createElement(\"div\", {\n    className: \"adventofcode max-w-[60%] ml-[20%]\"\n  }, React.createElement(\"h1\", null, React.createElement(\"a\", {\n    href: \"https://adventofcode.com/\" + pageContext.year + \"/day/\" + pageContext.puzz\n  }, pageContext.year + \" Day \" + pageContext.puzz + \" - \" + pageContext.title)), React.createElement(MDXProvider, {\n    components: shortcodes\n  }, children), pageContext.puzz && pageContext.year ? React.createElement(TryYourself, {\n    year: pageContext.year,\n    puzz: pageContext.puzz\n  }) : React.createElement(React.Fragment, null))), React.createElement(Footer, null));\n}\nexport default function GatsbyMDXWrapper(props) {\n  return React.createElement(Layout, props, React.createElement(GATSBY_COMPILED_MDX, props));\n}\nexport const Head = () => React.createElement(React.Fragment, null, React.createElement(\"title\", null, \"Joel-Allan-NZ - Advent of Code\"), React.createElement(\"html\", {\n  lang: \"en\"\n}), React.createElement(\"link\", {\n  rel: \"preconnect\",\n  href: \"https://fonts.googleapis.com\"\n}), React.createElement(\"link\", {\n  rel: \"preconnect\",\n  href: \"https://fonts.gstatic.com\"\n}), React.createElement(\"link\", {\n  href: \"https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&family=VT323&display=swap\",\n  rel: \"stylesheet\"\n}));\n"],"names":["_createMdxContent","props","_components","Object","assign","h2","p","pre","code","_provideComponents","components","CodeBox","id","component","Error","_missingMdxReference","React","boxname","names","className","href","wrapper","MDXLayout","shortcodes","Layout","_ref","pageContext","children","Header","AdventSideNav","list","year","puzz","title","MDXProvider","TryYourself","Footer","GatsbyMDXWrapper","GATSBY_COMPILED_MDX","Head","lang","rel"],"sourceRoot":""}