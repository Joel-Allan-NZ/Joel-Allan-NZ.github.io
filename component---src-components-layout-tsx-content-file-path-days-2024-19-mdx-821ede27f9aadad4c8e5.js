"use strict";(self.webpackChunkjoel_allan_nz_github_io=self.webpackChunkjoel_allan_nz_github_io||[]).push([[2450],{3113:function(e,t,n){n.r(t),n.d(t,{Head:function(){return f},default:function(){return g}});var r=n(8453),a=n(6540);function o(e){const t=Object.assign({h2:"h2",p:"p",pre:"pre",code:"code"},(0,r.RP)(),e.components),{CodeBox:n}=t;return n||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("CodeBox",!0),a.createElement(a.Fragment,null,a.createElement(t.h2,null,"Part One"),"\n",a.createElement(t.p,null,"I'm saying this a frightening number of times (hinting at horrors to come?), but this was nice and straight forward yet again."),"\n",a.createElement("br"),"\n",a.createElement(t.p,null,"For each pattern consider each towel it could start with, and then take the sub-pattern\nbeginning after that towel. Repeat the process for each of those sub-patterns until\nyou have no more sub-pattern left to check (a full match!), or nothing matches with\nthe remaining sub-patterns (an invalid pattern)."),"\n",a.createElement("br"),"\n",a.createElement(t.p,null,"This should be pretty simple to do recursively, but I opted to use a stack and avoid\nany possible recursive depth problems (not that there should be any)."),"\n",a.createElement(n,{boxname:"one",names:"typescript|C#"},a.createElement(t.pre,null,a.createElement(t.code,{className:"language-js"},"export function partOne(input: string[]): number | string {\n  const towels = input[0].split(/, /)\n  const patterns = input.slice(2)\n\n  return patterns.reduce(\n    (total, pattern) => (canMakePattern(pattern, towels) ? total + 1 : total),\n    0\n  )\n}\n\nfunction canMakePattern(pattern: string, towels: string[]): boolean {\n  const patterns = []\n  patterns.push(pattern)\n  while (patterns.length > 0) {\n    let currentPattern = patterns.pop()\n\n    for (let towel of towels) {\n      if (currentPattern?.startsWith(towel)) {\n        if (currentPattern.length == towel.length) return true\n\n        patterns.push(currentPattern.slice(towel.length))\n      }\n    }\n  }\n  return false\n}\n")),a.createElement(t.pre,null,a.createElement(t.code,{className:"language-csharp"},"public override object PartOne()\n{\n    var towels = Input[0].Split([',', ' '], StringSplitOptions.RemoveEmptyEntries);\n    var patterns = Input.Skip(2).ToList();\n\n    return patterns.Sum(pattern => CanMakePattern(pattern, towels) ? 1 : 0);\n}\n\nprivate static bool CanMakePattern(string pattern, IEnumerable<string> towels)\n{\n    Stack<string> patterns = [];\n    patterns.Push(pattern);\n    while (patterns.Count > 0)\n    {\n        var currentPattern = patterns.Pop();\n\n        foreach (var towel in towels)\n        {\n            if (currentPattern.StartsWith(towel))\n            {\n                if (currentPattern.Length == towel.Length)\n                    return true;\n\n                patterns.Push(currentPattern[towel.Length..]);\n            }\n        }\n    }\n    return false;\n}\n"))),"\n",a.createElement(t.h2,null,"Part Two"),"\n",a.createElement(t.p,null,"Quite straight forward again, but the predictably large solution means we can't be horribly inefficient. Some memoization goes a long way."),"\n",a.createElement(t.p,null,a.createElement("br"),"I surrendered to the evils of recursion for this one, but otherwise my\napproach is very similar to part one: check which towels are a valid beginning\nfor the pattern, and for each of them then consider the remaining part of the\npattern again checking for matching towels at the beginning. The only real\ndifference is that I record the number of towel arrangements that exist for each\nof these patterns, and use it to avoid duplicate work. Without that memoization\nthis would not be quick at all!"),"\n",a.createElement(n,{boxname:"two",names:"typescript|C#"},a.createElement(t.pre,null,a.createElement(t.code,{className:"language-js"},"export function partTwo(input: string[]): number | string {\n  const towels = input[0].split(/, /)\n  const patterns = input.slice(2)\n  const cache = new Map<string, number>()\n\n  return patterns.reduce(\n    (total, pattern) => total + countValidPatterns(cache, pattern, towels),\n    0\n  )\n}\n\nfunction countValidPatterns(\n  cache: Map<string, number>,\n  pattern: string,\n  towels: string[]\n): number {\n  if (!pattern || pattern.length == 0) return 1\n  if (cache.has(pattern)) return cache.get(pattern)!\n\n  const prefixMatches = towels.filter((towel) => pattern.startsWith(towel))\n  const matchCount = prefixMatches.reduce(\n    (total, towel) =>\n      total + countValidPatterns(cache, pattern.slice(towel.length), towels),\n    0\n  )\n  cache.set(pattern, matchCount)\n  return matchCount\n}\n")),a.createElement(t.pre,null,a.createElement(t.code,{className:"language-csharp"},"public override object PartTwo()\n{\n    Dictionary<string, long> uniqueFound = [];\n    var towels = Input[0].Split([',', ' '], StringSplitOptions.RemoveEmptyEntries).ToList();\n    var patterns = Input.Skip(2).ToList();\n\n    return patterns.Sum(x => CountValidPatterns(uniqueFound, x, towels));\n}\n\nprivate static long CountValidPatterns(Dictionary<string, long> cache, string pattern, IEnumerable<string> towels)\n{\n    if (String.IsNullOrEmpty(pattern))\n        return 1;\n    if (cache.TryGetValue(pattern, out var possibleCount))\n        return possibleCount;\n\n    var towelPrefixMatches = towels.Where(towel => pattern.StartsWith(towel));\n    long matches = towelPrefixMatches.Sum(towel => CountValidPatterns(cache, pattern[towel.Length..], towels));\n\n    cache[pattern] = matches;\n    return matches;\n}\n"))))}var l=function(e){void 0===e&&(e={});const{wrapper:t}=Object.assign({},(0,r.RP)(),e.components);return t?a.createElement(t,e,a.createElement(o,e)):o(e)};var s=n(2779),i=n(7206),c=n(791),p=n(4813),u=n(572);const h={CodeBox:s.A};function m(e){let{pageContext:t,children:n}=e;return a.createElement(a.Fragment,null,a.createElement(p.A,null),a.createElement("div",{className:"min-h-screen bg-chicPrimary"},a.createElement(c.A,{props:t.list}),a.createElement("div",{className:"adventofcode max-w-[60%] ml-[20%]"},a.createElement("h1",null,a.createElement("a",{href:"https://adventofcode.com/"+t.year+"/day/"+t.puzz},t.year+" Day "+t.puzz+" - "+t.title)),a.createElement(r.xA,{components:h},n),t.puzz&&t.year?a.createElement(i.A,{year:t.year,puzz:t.puzz}):a.createElement(a.Fragment,null))),a.createElement(u.A,null))}function g(e){return a.createElement(m,e,a.createElement(l,e))}const f=()=>a.createElement(a.Fragment,null,a.createElement("title",null,"Joel-Allan-NZ - Advent of Code"),a.createElement("html",{lang:"en"}),a.createElement("link",{rel:"preconnect",href:"https://fonts.googleapis.com"}),a.createElement("link",{rel:"preconnect",href:"https://fonts.gstatic.com"}),a.createElement("link",{href:"https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&family=VT323&display=swap",rel:"stylesheet"}))}}]);
//# sourceMappingURL=component---src-components-layout-tsx-content-file-path-days-2024-19-mdx-821ede27f9aadad4c8e5.js.map