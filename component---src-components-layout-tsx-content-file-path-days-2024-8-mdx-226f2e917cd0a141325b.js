"use strict";(self.webpackChunkjoel_allan_nz_github_io=self.webpackChunkjoel_allan_nz_github_io||[]).push([[4276],{2776:function(n,e,t){t.r(e),t.d(e,{Head:function(){return x},default:function(){return f}});var a=t(8453),i=t(6540);function r(n){const e=Object.assign({h2:"h2",p:"p",pre:"pre",code:"code"},(0,a.RP)(),n.components),{CodeBox:t}=e;return t||function(n,e){throw new Error("Expected "+(e?"component":"object")+" `"+n+"` to be defined: you likely forgot to import, pass, or provide it.")}("CodeBox",!0),i.createElement(i.Fragment,null,i.createElement(e.h2,null,"Part One"),"\n",i.createElement(e.p,null,"The key insight is that for each pair of antenna, the antinodes must be on that same line, spaced as far apart as those two antenna. So I simply check if those points are in bounds, and record the coordinates if they are."),"\n",i.createElement(t,{names:"typescript|C#"},i.createElement(e.pre,null,i.createElement(e.code,{className:"language-js"},"export function partOne(input: string[]): number | string {\n  const parsed = parse(input)\n  const antinodes = new Map<number, Set<number>>()\n\n  parsed.forEach((antennaeType) => {\n    antennaeType.forEach((antenna, index) => {\n      antennaeType.slice(index + 1).forEach((ant, i) => {\n        findAntinodes(antinodes, antenna, ant, input[0].length, input.length)\n      })\n    })\n  })\n  return antinodes\n    .keys()\n    .reduce((total, key) => total + antinodes.get(key)!.size, 0)\n}\n\nfunction parse(input: string[]): Map<string, number[][]> {\n  const result = new Map<string, number[][]>()\n  input.forEach((line, y) => {\n    line.split('').forEach((c, x) => {\n      if (c != '.') {\n        if (!result.has(c)) result.set(c, [[x, y]])\n        else result.get(c)?.push([x, y])\n      }\n    })\n  })\n  return result\n}\n\nfunction findAntinodes(\n  antinodes: Map<number, Set<number>>,\n  a: number[],\n  b: number[],\n  maxX: number,\n  maxY: number\n) {\n  let xDiff = a[0] - b[0]\n  let yDiff = a[1] - b[1]\n\n  ;[\n    [a[0] + xDiff, a[1] + yDiff],\n    [b[0] - xDiff, b[1] - yDiff],\n  ].forEach((x) => {\n    if (x[0] > -1 && x[0] < maxX && x[1] > -1 && x[1] < maxY) {\n      if (!antinodes.has(x[0])) antinodes.set(x[0], new Set<number>([x[1]]))\n      else antinodes.get(x[0])?.add(x[1])\n    }\n  })\n}\n\n")),i.createElement(e.pre,null,i.createElement(e.code,{className:"language-csharp"},"public override object PartOne()\n{\n    var antennae = ParseInput();\n    HashSet<(int, int)> antinodes = [];\n\n    foreach (var antennaeType in antennae.Values)\n    {\n        foreach (var pair in antennaeType.UniquePairs())\n            FindAntinodes(antinodes, pair[0], pair[1], Input[0].Length - 1, Input.Length - 1);\n    }\n    return antinodes.Count;\n}\n\nprivate Dictionary<char, List<(int X, int Y)>> ParseInput()\n{\n    return Input.SelectMany((y, yIndex) => y.Select((x, index) => (key: x, X: index, Y: yIndex)))\n                .GroupBy(x => x.key, v => (v.X, v.Y))\n                .Where(x => x.Key != '.')\n                .ToDictionary(k => k.Key, v => v.ToList());\n\n}\n\nprivate static void FindAntinodes(HashSet<(int, int)> antinodes, (int X, int Y) a, (int X, int Y) b, int maxX, int maxY)\n{\n    var xDiff = a.X - b.X;\n    var yDiff = a.Y - b.Y;\n\n    (int X, int Y)[] candidates = [(a.X + xDiff, a.Y + yDiff), (b.X - xDiff, b.Y - yDiff)];\n    foreach (var (X, Y) in candidates)\n    {\n        if (X >= 0 && X <= maxX && Y >= 0 && Y <= maxY)\n        {\n            antinodes.Add((X, Y));\n        }\n    }\n}\n"))),"\n",i.createElement(e.h2,null,"Part Two"),"\n",i.createElement(e.p,null,"Almost identical to the first part, except we must check all points on that line, rather than only those at a particular distance away from each antenna. Simple stuff"),"\n",i.createElement(t,{names:"typescript|C#"},i.createElement(e.pre,null,i.createElement(e.code,{className:"language-js"},"export function partTwo(input: string[]): number | string {\n  const parsed = parse(input)\n  const antinodes = new Map<number, Set<number>>()\n\n  parsed.forEach((antennaeType) => {\n    antennaeType.forEach((antenna, index) => {\n      antennaeType.slice(index + 1).forEach((ant, i) => {\n        findHarmonicAntinodes(\n          antinodes,\n          antenna,\n          ant,\n          input[0].length,\n          input.length\n        )\n      })\n    })\n  })\n  return antinodes\n    .keys()\n    .reduce((total, key) => total + antinodes.get(key)!.size, 0)\n}\n\nfunction findHarmonicAntinodes(\n  antinodes: Map<number, Set<number>>,\n  a: number[],\n  b: number[],\n  maxX: number,\n  maxY: number\n) {\n  let xDiff = a[0] - b[0]\n  let yDiff = a[1] - b[1]\n\n  let x = a[0]\n  let y = a[1]\n\n  while (x > -1 && x < maxX && y > -1 && y < maxY) {\n    if (!antinodes.has(x)) antinodes.set(x, new Set<number>([y]))\n    else antinodes.get(x)?.add(y)\n    x = x + xDiff\n    y = y + yDiff\n  }\n\n  x = a[0]\n  y = a[1]\n\n  while (x > -1 && x < maxX && y > -1 && y < maxY) {\n    if (!antinodes.has(x)) antinodes.set(x, new Set<number>([y]))\n    else antinodes.get(x)?.add(y)\n    x = x - xDiff\n    y = y - yDiff\n  }\n}\n")),i.createElement(e.pre,null,i.createElement(e.code,{className:"language-csharp"},"public override object PartTwo()\n{\n    var antennae = ParseInput();\n    HashSet<(int, int)> antinodes = [];\n\n    foreach (var antennaeType in antennae.Values)\n    {\n        foreach (var pair in antennaeType.UniquePairs())\n            FindHarmonicAntinodes(antinodes, pair[0], pair[1], Input[0].Length - 1, Input.Length - 1);\n    }\n    return antinodes.Count;\n}\n\nprivate static void FindHarmonicAntinodes(HashSet<(int, int)> antinodes, (int X, int Y) a, (int X, int Y) b, int maxX, int maxY)\n{\n    var xDiff = a.X - b.X;\n    var yDiff = a.Y - b.Y;\n    List<Func<int, int, int>> ops = [(x, y) => x + y, (x, y) => x - y];\n\n    foreach (var op in ops)\n    {\n        var x = a.X;\n        var y = a.Y;\n\n        while (x >= 0 && x <= maxX && y >= 0 && y <= maxY)\n        {\n            antinodes.Add((x, y));\n            x = op(x, xDiff);\n            y = op(y, yDiff);\n        }\n    }\n}\n"))))}var o=function(n){void 0===n&&(n={});const{wrapper:e}=Object.assign({},(0,a.RP)(),n.components);return e?i.createElement(e,n,i.createElement(r,n)):r(n)};var s=t(2779),l=t(7206),c=t(791),p=t(4813),u=t(572);const m={CodeBox:s.A};function d(n){let{pageContext:e,children:t}=n;return i.createElement(i.Fragment,null,i.createElement(p.A,null),i.createElement("div",{className:"min-h-screen bg-chicPrimary"},i.createElement(c.A,{props:e.list}),i.createElement("div",{className:"adventofcode max-w-[60%] ml-[20%]"},i.createElement("h1",null,i.createElement("a",{href:"https://adventofcode.com/"+e.year+"/day/"+e.puzz},e.year+" Day "+e.puzz+" - "+e.title)),i.createElement(a.xA,{components:m},t),e.puzz&&e.year?i.createElement(l.A,{year:e.year,puzz:e.puzz}):i.createElement(i.Fragment,null))),i.createElement(u.A,null))}function f(n){return i.createElement(d,n,i.createElement(o,n))}const x=()=>i.createElement(i.Fragment,null,i.createElement("title",null,"Joel-Allan-NZ - Advent of Code"),i.createElement("html",{lang:"en"}),i.createElement("link",{rel:"preconnect",href:"https://fonts.googleapis.com"}),i.createElement("link",{rel:"preconnect",href:"https://fonts.gstatic.com"}),i.createElement("link",{href:"https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&family=VT323&display=swap",rel:"stylesheet"}))}}]);
//# sourceMappingURL=component---src-components-layout-tsx-content-file-path-days-2024-8-mdx-226f2e917cd0a141325b.js.map