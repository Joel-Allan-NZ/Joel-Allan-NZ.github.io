"use strict";(self.webpackChunkjoel_allan_nz_github_io=self.webpackChunkjoel_allan_nz_github_io||[]).push([[6765],{892:function(n,e,t){t.r(e),t.d(e,{Head:function(){return p},default:function(){return g}});var i=t(8453),r=t(6540);function o(n){const e=Object.assign({h2:"h2",p:"p",pre:"pre",code:"code"},(0,i.RP)(),n.components),{CodeBox:t}=e;return t||function(n,e){throw new Error("Expected "+(e?"component":"object")+" `"+n+"` to be defined: you likely forgot to import, pass, or provide it.")}("CodeBox",!0),r.createElement(r.Fragment,null,r.createElement(e.h2,null,"Part One"),"\n",r.createElement(e.p,null,"Finding a shortest path, but with a little twist of having the direction of edges be important."),"\n",r.createElement("br"),"\n",r.createElement(e.p,null,"I feel like there are two pretty straightforward approaches to this - model the graph\nwith 4x the nodes (one for each facing), and have edge costs that represent the cost\nof both rotation and movement, OR the approach I opted for: \"directional\" edge allocation,\nwhere each vertex has 4 potentially null edges; 1 for each cardinal direction. I\nsuspect the more node/edge version would be more concise and legible, but I'm deeply\nconditioned to avoid making graphs more complex than they need to be - a Djikstra-like\nalgorithm's time complexity increases relative to the square of the number of vertices\n(if you aren't using a priority queue at least)."),"\n",r.createElement("br"),"\n",r.createElement(e.p,null,"The non-expanded graph seemed small enough to avoid needing to implement a priority\nqueue, and even with somewhat bloated code it resolves at effectively instant speeds\n(< 30 ms) on my machine."),"\n",r.createElement("br"),"\n",r.createElement(t,{boxname:"one",names:"typescript|C#"},r.createElement(e.pre,null,r.createElement(e.code,{className:"language-js"},"export function partOne(input: string[]): number | string {\n  const { graph, start, end } = parse(input)\n  findShortestPaths(graph, start)\n  return end.shortestPaths.reduce(\n    (min, current) => (min < current ? min : current),\n    2 ** 31\n  )\n}\n\ninterface FacingNode {\n  c: string\n  edges: (FacingNode | null)[]\n  x: number\n  y: number\n  shortestPaths: number[]\n}\n\nfunction parse(input: string[]): {\n  graph: Map<number, Map<number, FacingNode>>\n  start: FacingNode\n  end: FacingNode\n} {\n  const graph = new Map<number, Map<number, FacingNode>>()\n  let pathMax = 2 ** 31\n  let end: FacingNode = {\n    c: 'a',\n    edges: [],\n    x: 1,\n    y: 1,\n    shortestPaths: [pathMax, pathMax, pathMax, pathMax],\n  }\n  let start: FacingNode = {\n    c: 'a',\n    edges: [],\n    x: 1,\n    y: 1,\n    shortestPaths: [1000, 0, 1000, 2000],\n  }\n\n  input.forEach((line, y) => {\n    line.split('').forEach((c, x) => {\n      if (c != '#') {\n        let node: FacingNode = {\n          c,\n          edges: [null, null, null, null],\n          x,\n          y,\n          shortestPaths: [pathMax, pathMax, pathMax, pathMax],\n        }\n        if (c == 'E') end = node\n        else if (c == 'S') {\n          node = start\n          start.x = x\n          start.y = y\n        }\n        if (!graph.has(y)) graph.set(y, new Map<number, FacingNode>())\n        graph.get(y)?.set(x, node)\n        let left = graph.get(y)?.get(x - 1)\n        if (left) {\n          left.edges[1] = node\n          node.edges[3] = left\n        }\n        let top = graph.get(y - 1)?.get(x)\n        if (top) {\n          node.edges[0] = top\n          top.edges[2] = node\n        }\n      }\n    })\n  })\n  return { graph, start, end }\n}\n\nfunction findShortestPaths(\n  graph: Map<number, Map<number, FacingNode>>,\n  start: FacingNode\n): void {\n  const positions: FacingNode[] = [start]\n  while (positions.length > 0) {\n    let current = positions.shift()!\n    for (let i = 0; i < 4; i++) {\n      let neighbour = current.edges[i]\n      if (!neighbour) continue\n      let smaller = false\n      const minimums = getSmallestNextValues(\n        current?.shortestPaths,\n        neighbour.shortestPaths,\n        i\n      )\n      for (let j = 0; j < 4; j++) {\n        if (neighbour.shortestPaths[j] > minimums[j]) {\n          neighbour.shortestPaths[j] = minimums[j]\n          smaller = true\n        }\n      }\n      if (smaller) positions.push(neighbour)\n    }\n  }\n}\n\nfunction getSmallestNextValues(\n  costs: number[],\n  nextCosts: number[],\n  direction: number\n) {\n  const minimums = [2 ** 31, 2 ** 31, 2 ** 31, 2 ** 31]\n  const directionalCosts: number[][] = [\n    [direction, 0],\n    [(direction + 5) % 4, 1000],\n    [(direction + 6) % 4, 2000],\n    [(direction + 7) % 4, 1000],\n  ]\n\n  let minCost = directionalCosts.reduce((min, current) => {\n    let currentValue = costs[current[0]] + 1 + current[1]\n    return min < currentValue ? min : currentValue\n  }, 2 ** 31)\n\n  if (minCost < nextCosts[direction]) {\n    minimums[direction] = minCost\n    directionalCosts.forEach((facing, cost) =>\n      minimums[facing[0]] > minimums[direction] + facing[1]\n        ? (minimums[facing[0]] = minimums[direction] + facing[1])\n        : null\n    )\n    return minimums\n  }\n  return nextCosts\n}\n")),r.createElement(e.pre,null,r.createElement(e.code,{className:"language-csharp"},"public override object PartOne()\n{\n    var graph = Parse();\n    var shortestPaths = FindShortestPaths(graph);\n\n    var end = graph.Values.First(x => x.Value == 'E');\n    return shortestPaths[end].Min();\n}\n\nprivate Dictionary<(int x, int y), FacingNode> Parse()\n{\n    Dictionary<(int x, int y), FacingNode> dict = [];\n\n    for (int y = 0; y < Input.Length; y++)\n    {\n        for (int x = 0; x < Input[y].Length; x++)\n        {\n            if (Input[y][x] != '#')\n            {\n                var node = new FacingNode(Input[y][x], x, y);\n                dict.Add((x, y), node);\n                if (x > 0 && dict.TryGetValue((x - 1, y), out var left))\n                {\n                    left.Edges[1] = node;\n                    node.Edges[3] = (left);\n\n                }\n                if (y > 0 && dict.TryGetValue((x, y - 1), out var top))\n                {\n                    node.Edges[0] = top;\n                    top.Edges[2] = node;\n                }\n            }\n        }\n    }\n    return dict;\n}\n\nprivate static Dictionary<FacingNode, int[]> FindShortestPaths(Dictionary<(int x, int y), FacingNode> graph)\n{\n    Queue<FacingNode> positions = [];\n    var start = graph.Values.First(x => x.Value == 'S');\n    Dictionary<FacingNode, int[]> shortestPaths = [];\n    shortestPaths[start] = [1000, 0, 1000, 2000];\n    positions.Enqueue(start);\n\n    while (positions.Count > 0)\n    {\n        var current = positions.Dequeue();\n\n        for (int i = 0; i < 4; i++)\n        {\n            var neighbour = current.Edges[i];\n            if (neighbour == null)\n                continue;\n\n            if (!shortestPaths.TryGetValue(neighbour, out var edgeCosts))\n            {\n                edgeCosts = [int.MaxValue, int.MaxValue, int.MaxValue, int.MaxValue];\n                shortestPaths[neighbour] = edgeCosts;\n            }\n            var minimums = GetSmallestNextValues(shortestPaths[current], edgeCosts, i);\n            bool smaller = false;\n\n            for (int j = 0; j < 4; j++)\n            {\n                if (edgeCosts[j] > minimums[j])\n                {\n                    edgeCosts[j] = minimums[j];\n                    smaller = true;\n                }\n            }\n            if (smaller)\n                positions.Enqueue(neighbour);\n        }\n    }\n    return shortestPaths;\n}\n\nprivate static int[] GetSmallestNextValues(int[] costs, int[] nextCosts, int edgeDirection)\n{\n    int[] minimums = new int[4];\n    (int facing, int rotationCost)[] directionRotationCosts = [\n        (edgeDirection, 0),\n        ((edgeDirection+5)%4, 1000),\n        ((edgeDirection+6)%4, 2000),\n        ((edgeDirection+7)%4, 1000),\n        ];\n\n    var minCost = directionRotationCosts.Min(x => costs[x.facing] + x.rotationCost + 1);\n\n    if (minCost < nextCosts[edgeDirection])\n    {\n        minimums[edgeDirection] = minCost;\n        foreach (var (facing, rotationCost) in directionRotationCosts)\n        {\n            minimums[facing] = Math.Min(nextCosts[facing], minimums[edgeDirection] + rotationCost);\n        }\n        return minimums;\n    }\n    return nextCosts;\n}\n\ninternal class FacingNode(char c, int x, int y)\n{\n    internal char Value = c;\n    internal FacingNode?[] Edges = [null, null, null, null];\n    internal int X = x;\n    internal int Y = y;\n}\n"))),"\n",r.createElement(e.h2,null,"Part Two"),"\n",r.createElement(e.p,null,"Part Two is a more clear-cut solution: run a shortest path finding algorithm that doesn't terminate on finding the target position, and then back-track along all shortest routes to find all nodes that can be part of a possible shortest path. Quick + easy."),"\n",r.createElement(t,{boxname:"two",names:"typescript|C#"},r.createElement(e.pre,null,r.createElement(e.code,{className:"language-js"},"export function partTwo(input: string[]): number | string {\n  const { graph, start, end } = parse(input)\n  findShortestPaths(graph, start)\n  const allPaths = findAllPaths(end)\n  return allPaths.size\n}\n\nfunction findAllPaths(end: FacingNode): Set<FacingNode> {\n  let min = end.shortestPaths.reduce(\n    (min, current) => (min < current ? min : current),\n    2 ** 31\n  )\n  let minIndex = 0\n  while (end.shortestPaths[minIndex] != min) minIndex++\n  const paths = new Set<FacingNode>()\n  paths.add(end)\n  const process: { node: FacingNode; facing: number }[] = [\n    { node: end, facing: minIndex },\n  ]\n  while (process.length > 0) {\n    let current = process.shift()!\n    const prior = findPriorNeighbours(current.node, current?.facing)\n    prior.forEach((p) => {\n      if (!paths.has(p.node)) process.push(p)\n      paths.add(p.node)\n    })\n  }\n  return paths\n}\n\nfunction findPriorNeighbours(node: FacingNode, direction: number) {\n  const directionalCosts: number[][] = [\n    [direction, 1],\n    [(direction + 5) % 4, 1001],\n    [(direction + 6) % 4, 2001],\n    [(direction + 7) % 4, 1001],\n  ]\n  const res: { node: FacingNode; facing: number }[] = []\n\n  for (let i = 0; i < 4; i++) {\n    const edge = node.edges[directionalCosts[i][0]]\n    const opposite = directionalCosts[(i + 6) % 4]\n\n    if (\n      edge &&\n      edge.shortestPaths[opposite[0]] ==\n        node.shortestPaths[direction] - opposite[1]\n    )\n      res.push({ node: edge, facing: opposite[0] })\n  }\n  return res\n}\n")),r.createElement(e.pre,null,r.createElement(e.code,{className:"language-csharp"},"public override object PartTwo()\n{\n    var graph = Parse();\n    var shortestPaths = FindShortestPaths(graph);\n    var allPaths = FindAllPaths(shortestPaths);\n\n    return allPaths.Count;\n}\n\nprivate static HashSet<FacingNode> FindAllPaths(Dictionary<FacingNode, int[]> shortestPaths)\n{\n    var end = shortestPaths.Keys.First(x => x.Value == 'E');\n    var min = shortestPaths[end].Min();\n    int i = 0;\n    while (shortestPaths[end][i] != min)\n    {\n        i++;\n    }\n    HashSet<FacingNode> paths = [];\n    paths.Add(end);\n\n    Queue<(FacingNode node, int facing)> process = [];\n    process.Enqueue((end, i));\n    while (process.Count > 0)\n    {\n        var (node, facing) = process.Dequeue();\n        foreach (var prior in FindPriorNeighbours(shortestPaths, node, facing))\n        {\n            if (!paths.Contains(prior.node))\n                process.Enqueue(prior);\n            paths.Add(prior.node);\n        }\n    }\n    return paths;\n}\n\nprivate static IEnumerable<(FacingNode node, int facing)> FindPriorNeighbours(Dictionary<FacingNode, int[]> shortestPaths, FacingNode node, int direction)\n{\n    var cost = shortestPaths[node][direction];\n    (int facing, int rotationCost)[] directionRotationCosts = [\n        (direction, 1),\n        ((direction+5)%4, 1001),\n        ((direction+6)%4, 2001),\n        ((direction+7)%4, 1001),\n        ];\n\n    for (int i = 0; i < 4; i++)\n    {\n        var edge = node.Edges[directionRotationCosts[i].facing];\n        var (facing, rotationCost) = directionRotationCosts[(i + 6) % 4];\n\n        if (edge != null && shortestPaths[edge][facing] == cost - rotationCost)\n            yield return (edge, facing);\n    }\n}\n"))))}var a=function(n){void 0===n&&(n={});const{wrapper:e}=Object.assign({},(0,i.RP)(),n.components);return e?r.createElement(e,n,r.createElement(o,n)):o(n)};var s=t(2779),c=t(7206),l=t(791),d=t(4813),u=t(572);const h={CodeBox:s.A};function m(n){let{pageContext:e,children:t}=n;return r.createElement(r.Fragment,null,r.createElement(d.A,null),r.createElement("div",{className:"min-h-screen bg-chicPrimary"},r.createElement(l.A,{props:e.list}),r.createElement("div",{className:"adventofcode max-w-[60%] ml-[20%]"},r.createElement("h1",null,r.createElement("a",{href:"https://adventofcode.com/"+e.year+"/day/"+e.puzz},e.year+" Day "+e.puzz+" - "+e.title)),r.createElement(i.xA,{components:h},t),e.puzz&&e.year?r.createElement(c.A,{year:e.year,puzz:e.puzz}):r.createElement(r.Fragment,null))),r.createElement(u.A,null))}function g(n){return r.createElement(m,n,r.createElement(a,n))}const p=()=>r.createElement(r.Fragment,null,r.createElement("title",null,"Joel-Allan-NZ - Advent of Code"),r.createElement("html",{lang:"en"}),r.createElement("link",{rel:"preconnect",href:"https://fonts.googleapis.com"}),r.createElement("link",{rel:"preconnect",href:"https://fonts.gstatic.com"}),r.createElement("link",{href:"https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&family=VT323&display=swap",rel:"stylesheet"}))}}]);
//# sourceMappingURL=component---src-components-layout-tsx-content-file-path-days-2024-16-mdx-f5e147e484e33d01458a.js.map