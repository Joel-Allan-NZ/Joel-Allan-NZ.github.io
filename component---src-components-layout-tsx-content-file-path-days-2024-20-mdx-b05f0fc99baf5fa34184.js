"use strict";(self.webpackChunkjoel_allan_nz_github_io=self.webpackChunkjoel_allan_nz_github_io||[]).push([[4322],{1901:function(n,e,t){t.r(e),t.d(e,{Head:function(){return m},default:function(){return p}});var a=t(8453),r=t(6540);function i(n){const e=Object.assign({h2:"h2",p:"p",pre:"pre",code:"code",em:"em"},(0,a.RP)(),n.components),{CodeBox:t}=e;return t||function(n,e){throw new Error("Expected "+(e?"component":"object")+" `"+n+"` to be defined: you likely forgot to import, pass, or provide it.")}("CodeBox",!0),r.createElement(r.Fragment,null,r.createElement(e.h2,null,"Part One"),"\n",r.createElement(e.p,null,"This feels like the 40th ",r.createElement("a",{href:"https://en.wikipedia.org/wiki/Breadth-first_search"},"BFS")," / budget ",r.createElement("a",{href:"https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm"},"djikstra")," in only 20 days."),"\n",r.createElement("br"),"\n",r.createElement(e.p,null,"My approach here is simple: find the shortest path distance to every node in the\ngraph, then look for nodes at most two nodes apart (ie with at most one wall tile\nbetween them) with a distance between their shortest paths greater than or equal\nto our 100 target. Each of those pairs represents a valid cheat pair, so just count\n'em up."),"\n",r.createElement(t,{boxname:"one",names:"typescript|C#"},r.createElement(e.pre,null,r.createElement(e.code,{className:"language-js"},"export function partOne(input: string[]): number | string {\n  const { graph, start } = parse(input)\n  findMinimumDistances(graph, start)\n  const distance = 2,\n    target = 100\n  let count = 0\n\n  for (let y = 0; y < graph.length; y++) {\n    for (let x = 0; x < graph[y].length; x++) {\n      if (graph[y][x].value != '#')\n        count += neighboursWithinManhattanDistance(\n          graph,\n          graph[y][x],\n          distance,\n          target\n        )\n    }\n  }\n  return count\n}\n\ninterface DistanceAwareNode {\n  value: string\n  distance: number\n  x: number\n  y: number\n}\n\nfunction parse(input: string[]): {\n  graph: DistanceAwareNode[][]\n  start: DistanceAwareNode\n} {\n  const graph: DistanceAwareNode[][] = []\n  let start: DistanceAwareNode | undefined = undefined\n\n  for (let y = 0; y < input.length; y++) {\n    graph.push([])\n    for (let x = 0; x < input[y].length; x++) {\n      const node = {\n        value: input[y][x],\n        distance: input[y][x] == '#' ? 0 : 2 ** 31,\n        x,\n        y,\n      }\n      graph[y].push(node)\n      if (input[y][x] == 'S') start = node\n    }\n  }\n  return { graph, start: start! }\n}\n\nfunction findMinimumDistances(\n  graph: DistanceAwareNode[][],\n  start: DistanceAwareNode\n): void {\n  const toExplore: DistanceAwareNode[] = [start]\n  start.distance = 0\n\n  while (toExplore.length > 0) {\n    const current = toExplore.shift()!\n    const neighbours = getNeighbours(graph, current)\n    neighbours.forEach((neighbour) => {\n      if (neighbour.value != '#' && neighbour.distance > current.distance + 1) {\n        toExplore.push(neighbour)\n        neighbour.distance = current.distance + 1\n      }\n    })\n  }\n}\n\nfunction getNeighbours(graph: DistanceAwareNode[][], node: DistanceAwareNode) {\n  const res: DistanceAwareNode[] = []\n\n  if (node.x < graph[0].length - 1) res.push(graph[node.y][node.x + 1])\n  if (node.x > 0) res.push(graph[node.y][node.x - 1])\n  if (node.y < graph.length - 1) res.push(graph[node.y + 1][node.x])\n  if (node.y > 0) res.push(graph[node.y - 1][node.x])\n\n  return res\n}\n\nfunction neighboursWithinManhattanDistance(\n  graph: DistanceAwareNode[][],\n  node: DistanceAwareNode,\n  cheatDistance: number,\n  cheatTimeGain: number\n): number {\n  let count = 0\n  const yMin = Math.max(0, node.y - cheatDistance)\n  const yMax = Math.min(graph.length - 1, node.y + cheatDistance)\n\n  for (let y = yMin; y <= yMax; y++) {\n    const remainingManhattanDistance = cheatDistance - Math.abs(node.y - y)\n    const xMin = Math.max(0, node.x - remainingManhattanDistance)\n    const xMax = Math.min(\n      graph[y].length - 1,\n      node.x + remainingManhattanDistance\n    )\n\n    for (let x = xMin; x <= xMax; x++) {\n      const neighbour = graph[y][x]\n      const manhattanDistance = Math.abs(node.x - x) + Math.abs(node.y - y)\n\n      if (\n        neighbour.distance - manhattanDistance - cheatTimeGain >=\n        node.distance\n      )\n        count++\n    }\n  }\n  return count\n}\n")),r.createElement(e.pre,null,r.createElement(e.code,{className:"language-csharp"},"public override object PartOne()\n{\n    var (grid, start) = Parse();\n    FindMinimumDistances(grid, start);\n    int distance = 2, target = 100;\n    int count = 0;\n\n    for (int y = 0; y < grid.GetLength(0); y++)\n    {\n        for (int x = 0; x < grid.GetLength(1); x++)\n        {\n            if (grid[y, x].Value != '#')\n                count += NeighboursWithinManhattanDistance(grid, grid[y, x], distance, target);\n        }\n    }\n    return count;\n}\nprivate static int NeighboursWithinManhattanDistance(DistanceAwareNode[,] graph, DistanceAwareNode node, int cheatDistance, int targetSpeedGain)\n{\n    int count = 0;\n    int yMin = Math.Max(0, node.Y - cheatDistance);\n    int yMax = Math.Min(graph.GetLength(0) - 1, node.Y + cheatDistance);\n\n    for (int y = yMin; y <= yMax; y++)\n    {\n        var remainingDistance = cheatDistance - Math.Abs(node.Y - y);\n        int xMin = Math.Max(0, node.X - remainingDistance);\n        int xMax = Math.Min(graph.GetLength(1) - 1, node.X + remainingDistance);\n\n        for (int x = xMin; x <= xMax; x++)\n        {\n            var neighbour = graph[y, x];\n            var manhattanDistance = Math.Abs(node.X - x) + Math.Abs(node.Y - y);\n            if (neighbour.Distance - targetSpeedGain - manhattanDistance >= node.Distance)\n                count++;\n        }\n    }\n    return count;\n}\n\nprivate static IEnumerable<DistanceAwareNode> GetNeighbours(DistanceAwareNode[,] graph, DistanceAwareNode node)\n{\n    if (node.X < graph.GetLength(1) - 1)\n        yield return graph[node.Y, node.X + 1];\n    if (node.X > 0)\n        yield return graph[node.Y, node.X - 1];\n    if (node.Y > 0)\n        yield return graph[node.Y - 1, node.X];\n    if (node.Y < graph.GetLength(0) - 1)\n        yield return graph[node.Y + 1, node.X];\n}\n\nprivate static void FindMinimumDistances(DistanceAwareNode[,] graph, DistanceAwareNode start)\n{\n    Queue<DistanceAwareNode> toExplore = [];\n    start.Distance = 0;\n    toExplore.Enqueue(start);\n\n    while (toExplore.Count > 0)\n    {\n        var current = toExplore.Dequeue();\n        foreach (var neighbour in GetNeighbours(graph, current))\n        {\n            if (neighbour.Value == '#' || neighbour.Distance <= current.Distance + 1)\n                continue;\n\n            toExplore.Enqueue(neighbour);\n            neighbour.Distance = current.Distance + 1;\n        }\n    }\n}\n\nprivate (DistanceAwareNode[,] graph, DistanceAwareNode start) Parse()\n{\n    DistanceAwareNode[,] graph = new DistanceAwareNode[Input.Length, Input[0].Length];\n    DistanceAwareNode? start = null;\n\n    for (int y = 0; y < Input.Length; y++)\n    {\n        for (int x = 0; x < Input[y].Length; x++)\n        {\n            DistanceAwareNode node = new(Input[y][x], x, y);\n            graph[y, x] = node;\n            if (Input[y][x] == 'S')\n                start = node;\n        }\n    }\n    return (graph, start!);\n}\n\ninternal class DistanceAwareNode(char c, int x, int y)\n{\n    internal char Value = c;\n    internal int Distance = c == '#' ? 0 : int.MaxValue;\n    internal int X = x;\n    internal int Y = y;\n}\n"))),"\n",r.createElement(e.h2,null,"Part Two"),"\n",r.createElement(e.p,null,"I wasted a bit of time here with some confusion (I'm dumb) over the wording!"),"\n",r.createElement("br"),"\n",r.createElement(e.p,null,"The twenty picoseconds of no collision time is contiguous, and continues whether\nor not the 'car' is still within a 'wall', and ",r.createElement(e.em,null,"doesn't end")," when you leave a wall.\nI mistakenly read it as the cheat terminating as soon as the car left a wall... some\ntime wasted there for sure."),"\n",r.createElement("br"),"\n",r.createElement(e.p,null,"My apparently terrible reading comprehension aside, this is the exact same problem\njust on a bigger scope. As I was reusing functions for both part 1 and part 2 it's\nhard to show what I refactored to gain some speed, but the short version is that\nI'm using a two-dimensional array rather than my typically lazy \"manhattan distance\ngraph is a dictionary\" approach."),"\n",r.createElement("br"),"\n",r.createElement(e.p,null,"There's zero reason to use a repeated neighbour finding function like I'm doing,\nyou'd be better off just storing neighbours as edges within each node... I just felt\nlike sacrificing a tiny amount of speed for a little memory saving."," "),"\n",r.createElement(t,{boxname:"two",names:"typescript|C#"},r.createElement(e.pre,null,r.createElement(e.code,{className:"language-js"},"export function partTwo(input: string[]): number | string {\n  const { graph, start } = parse(input)\n  findMinimumDistances(graph, start)\n  const distance = 20,\n    target = 100\n  let count = 0\n\n  for (let y = 0; y < graph.length; y++) {\n    for (let x = 0; x < graph[y].length; x++) {\n      if (graph[y][x].value != '#')\n        count += neighboursWithinManhattanDistance(\n          graph,\n          graph[y][x],\n          distance,\n          target\n        )\n    }\n  }\n  return count\n}\n")),r.createElement(e.pre,null,r.createElement(e.code,{className:"language-csharp"},"public override object PartTwo()\n{\n    var (grid, start) = Parse();\n    FindMinimumDistances(grid, start);\n    int distance = 20, target = 100;\n    int count = 0;\n\n    for (int y = 0; y < grid.GetLength(0); y++)\n    {\n        for (int x = 0; x < grid.GetLength(1); x++)\n        {\n            if (grid[y, x].Value != '#')\n                count += NeighboursWithinManhattanDistance(grid, grid[y, x], distance, target);\n        }\n    }\n    return count;\n}\n"))))}var o=function(n){void 0===n&&(n={});const{wrapper:e}=Object.assign({},(0,a.RP)(),n.components);return e?r.createElement(e,n,r.createElement(i,n)):i(n)};var s=t(2779),c=t(7206),h=t(791),l=t(4813),u=t(572);const d={CodeBox:s.A};function g(n){let{pageContext:e,children:t}=n;return r.createElement(r.Fragment,null,r.createElement(l.A,null),r.createElement("div",{className:"min-h-screen bg-chicPrimary"},r.createElement(h.A,{props:e.list}),r.createElement("div",{className:"adventofcode max-w-[60%] ml-[20%]"},r.createElement("h1",null,r.createElement("a",{href:"https://adventofcode.com/"+e.year+"/day/"+e.puzz},e.year+" Day "+e.puzz+" - "+e.title)),r.createElement(a.xA,{components:d},t),e.puzz&&e.year?r.createElement(c.A,{year:e.year,puzz:e.puzz}):r.createElement(r.Fragment,null))),r.createElement(u.A,null))}function p(n){return r.createElement(g,n,r.createElement(o,n))}const m=()=>r.createElement(r.Fragment,null,r.createElement("title",null,"Joel-Allan-NZ - Advent of Code"),r.createElement("html",{lang:"en"}),r.createElement("link",{rel:"preconnect",href:"https://fonts.googleapis.com"}),r.createElement("link",{rel:"preconnect",href:"https://fonts.gstatic.com"}),r.createElement("link",{href:"https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&family=VT323&display=swap",rel:"stylesheet"}))}}]);
//# sourceMappingURL=component---src-components-layout-tsx-content-file-path-days-2024-20-mdx-b05f0fc99baf5fa34184.js.map