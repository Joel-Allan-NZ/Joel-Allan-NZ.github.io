"use strict";(self.webpackChunkjoel_allan_nz_github_io=self.webpackChunkjoel_allan_nz_github_io||[]).push([[4967],{3370:function(e,t,n){n.r(t),n.d(t,{Head:function(){return g},default:function(){return h}});var a=n(8453),l=n(6540);function r(e){const t=Object.assign({h2:"h2",p:"p",pre:"pre",code:"code",em:"em",strong:"strong"},(0,a.RP)(),e.components),{CodeBox:n}=t;return n||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("CodeBox",!0),l.createElement(l.Fragment,null,l.createElement(t.h2,null,"Part One"),"\n",l.createElement(t.p,null,'Our first "just use regular expressions" problem of the year.'),"\n",l.createElement("br"),"\n",l.createElement(t.p,null,"Nothing special here, just grabbing the number values that we need and performing\nsome basic math."),"\n",l.createElement(n,{names:"typescript|C#"},l.createElement(t.pre,null,l.createElement(t.code,{className:"language-js"},"export function partOne(input: string[]): number | string {\n  const singleLineInput = input.reduce((total, current) => total + current, '')\n  const matches = [...singleLineInput.matchAll(/mul\\((\\d+),(\\d+)\\)/g).toArray()]\n\n  return matches.reduce(\n    (total, match) => total + parseInt(match[1]) * parseInt(match[2]),\n    0\n  )\n}\n")),l.createElement(t.pre,null,l.createElement(t.code,{className:"language-csharp"},"public override object PartOne()\n{\n    return Input.Sum(line =>\n    {\n        var matches = Day3.MulRegex().Matches(line);\n        return SumMatches(matches);\n    });\n}\nprivate static int SumMatches(IEnumerable<Match> matches)\n{\n    return matches.Sum(match => match.Value[4..^1].Split(',')\n                                                  .Select(x => int.Parse(x))\n                                                  .Aggregate((x, y) => x * y));\n}\n\n[GeneratedRegex(@\"mul\\(\\d+,\\d+\\)\")]\ninternal static partial Regex MulRegex();\n"))),"\n",l.createElement(t.h2,null,"Part Two"),"\n",l.createElement(t.p,null,"I extended our RegExp to added capturing groups to also grab ",l.createElement(t.em,null,"do()")," and ",l.createElement(t.em,null,"don't()")," matches. This allows us to toggle a boolean and use a simple loop to only count ",l.createElement(t.em,null,"mul()")," matches while we're not immediately behind a ",l.createElement(t.em,null,"don't()"),"."),"\n",l.createElement("br"),"\n",l.createElement(t.p,null,"As a certified regex hater my original solution instead grabbed the ",l.createElement(t.em,null,"do()")," and ",l.createElement(t.em,null,"don't()")," matches separately and used them to construct a simple set of ranges we could check ",l.createElement(t.em,null,"mul()")," indexes against... but it was considerably more work than using ",l.createElement(t.strong,null,"slightly")," more regex, which seems like a good trade off."),"\n",l.createElement(n,{names:"typescript|C#"},l.createElement(t.pre,null,l.createElement(t.code,{className:"language-js"},"export function partTwo(input: string[]): number | string {\n  const singleLineInput = input.reduce((total, current) => total + current, '')\n  const matches = [\n    ...singleLineInput.matchAll(/mul\\((\\d+),(\\d+)\\)|(don\\'t\\(\\))|(do\\(\\))/g),\n  ]\n  let dont = false\n  let total = 0\n  matches.forEach((match) => {\n    if (match[0].startsWith('don')) dont = true\n    else if (match[0].startsWith('do')) dont = false\n    else if (!dont) total += parseInt(match[1]) * parseInt(match[2])\n  })\n  return total\n}\n")),l.createElement(t.pre,null,l.createElement(t.code,{className:"language-csharp"},'public override object PartTwo()\n{\n    string SingleLineInput = Input.Aggregate((x, y) => x + y);\n    bool dont = false;\n    MatchCollection matches = PartTwoRegex().Matches(SingleLineInput);\n    return matches.Sum(match =>\n    {\n        if (match.Value.StartsWith("don"))\n            dont = true;\n        else if (match.Value.StartsWith("do"))\n            dont = false;\n        else if (!dont)\n        {\n            return match.Value[4..^1].Split(\',\')\n                                      .Select(x => int.Parse(x))\n                                      .Aggregate((x, y) => x * y);\n        }\n        return 0;\n\n    });\n}\n\n[GeneratedRegex(@"mul\\(\\d+,\\d+\\)|(do\\(\\))|(don\'t\\(\\))")]\ninternal static partial Regex PartTwoRegex();\n'))))}var c=function(e){void 0===e&&(e={});const{wrapper:t}=Object.assign({},(0,a.RP)(),e.components);return t?l.createElement(t,e,l.createElement(r,e)):r(e)};var o=n(2779),s=n(7206),m=n(791),u=n(4813),i=n(572);const p={CodeBox:o.A};function d(e){let{pageContext:t,children:n}=e;return l.createElement(l.Fragment,null,l.createElement(u.A,null),l.createElement("div",{className:"min-h-screen bg-chicPrimary"},l.createElement(m.A,{props:t.list}),l.createElement("div",{className:"adventofcode max-w-[60%] ml-[20%]"},l.createElement("h1",null,l.createElement("a",{href:"https://adventofcode.com/"+t.year+"/day/"+t.puzz},t.year+" Day "+t.puzz+" - "+t.title)),l.createElement(a.xA,{components:p},n),t.puzz&&t.year?l.createElement(s.A,{year:t.year,puzz:t.puzz}):l.createElement(l.Fragment,null))),l.createElement(i.A,null))}function h(e){return l.createElement(d,e,l.createElement(c,e))}const g=()=>l.createElement(l.Fragment,null,l.createElement("title",null,"Joel-Allan-NZ - Advent of Code"),l.createElement("html",{lang:"en"}),l.createElement("link",{rel:"preconnect",href:"https://fonts.googleapis.com"}),l.createElement("link",{rel:"preconnect",href:"https://fonts.gstatic.com"}),l.createElement("link",{href:"https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&family=VT323&display=swap",rel:"stylesheet"}))}}]);
//# sourceMappingURL=component---src-components-layout-tsx-content-file-path-days-2024-3-mdx-48d7582d2eb1714f9dc3.js.map