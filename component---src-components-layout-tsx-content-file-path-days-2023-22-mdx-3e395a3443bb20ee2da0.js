"use strict";(self.webpackChunkjoel_allan_nz_github_io=self.webpackChunkjoel_allan_nz_github_io||[]).push([[2837],{8939:function(n,e,r){r.r(e),r.d(e,{Head:function(){return m},default:function(){return d}});var t=r(8453),i=r(6540);function c(n){const e=Object.assign({h2:"h2",p:"p",pre:"pre",code:"code"},(0,t.RP)(),n.components),{CodeBox:r}=e;return r||function(n,e){throw new Error("Expected "+(e?"component":"object")+" `"+n+"` to be defined: you likely forgot to import, pass, or provide it.")}("CodeBox",!0),i.createElement(i.Fragment,null,i.createElement(e.h2,null,"Part One"),"\n",i.createElement(e.p,null,"Yet another part one based around modeling a system. My lazy approach to brick falling is just to populate the cube coordinates of each brick, then take bricks from the lowest un-moved Z, and move those bricks downward to the lowest Z where a intersection with another brick or the ground doesn't exist."),"\n",i.createElement("br"),"\n",i.createElement(e.p,null,"After moving each brick, I check for any bricks that are supporting it, and update\nsets of supporting/being supported by. Finally, the number of disintegratable bricks\nis equivalent to the total number of bricks, less any that are the sole support for\nothers."," "),"\n",i.createElement(r,{names:"typescript|C#"},i.createElement(e.pre,null,i.createElement(e.code,{className:"language-ts"},"export function partOne(input: string[]): number | string {\n  const bricks = parse(input)\n  bricksWithGravity(bricks)\n  const removable = new Set<number>(bricks.map((brick) => brick.id))\n\n  bricks.forEach((brick) => {\n    if (brick.supportedBy.size == 1)\n      removable.delete(brick.supportedBy.values().toArray()[0])\n  })\n\n  return removable.size\n}\n\ninterface Brick {\n  cubes: number[][]\n  supportedBy: Set<number>\n  supporting: Set<number>\n  id: number\n}\n\nfunction parse(input: string[]): Brick[] {\n  const bricks: Brick[] = []\n\n  input.forEach((line, index) => {\n    const brickEnds = line\n      .split('~')\n      .map((c) => c.split(',').map((c) => parseInt(c)))\n\n    const cubes: number[][] = []\n    for (let x = brickEnds[0][0]; x <= brickEnds[1][0]; x++) {\n      for (let y = brickEnds[0][1]; y <= brickEnds[1][1]; y++) {\n        for (let z = brickEnds[0][2]; z <= brickEnds[1][2]; z++) {\n          cubes.push([x, y, z])\n        }\n      }\n    }\n\n    bricks.push({\n      cubes,\n      supportedBy: new Set<number>(),\n      supporting: new Set<number>(),\n      id: index,\n    })\n  })\n\n  return bricks\n}\n\nfunction bricksWithGravity(bricks: Brick[]): void {\n  const cubesOwnership = new Map<string, Brick>()\n  const bricksByZ = new Map<number, Brick[]>()\n\n  bricks.forEach((brick) => {\n    const lowestCubeZ = brick.cubes.reduce(\n      (min, cube) => (min < cube[2] ? min : cube[2]),\n      Infinity\n    )\n    if (bricksByZ.has(lowestCubeZ)) bricksByZ.get(lowestCubeZ)?.push(brick)\n    else bricksByZ.set(lowestCubeZ, [brick])\n  })\n\n  bricksByZ\n    .keys()\n    .toArray()\n    .sort((x, y) => x - y)\n    .forEach((key) => {\n      bricksByZ\n        .get(key)!\n        .values()\n        .forEach((brick) => dropBrick(brick, cubesOwnership))\n    })\n}\n\nfunction dropBrick(brick: Brick, cubesOwnership: Map<string, Brick>): void {\n  const dropDistance = findBottomDistance(brick.cubes, cubesOwnership)\n\n  brick.cubes.forEach((cube) => {\n    cube[2] -= dropDistance\n    cubesOwnership.set(cube.join(','), brick)\n    const below = cubesOwnership.get(\n      cube[0] + ',' + cube[1] + ',' + (cube[2] - 1)\n    )\n\n    if (below && below.id != brick.id) {\n      below.supporting.add(brick.id)\n      brick.supportedBy.add(below.id)\n    }\n  })\n}\n\nfunction findBottomDistance(\n  cubes: number[][],\n  cubesOwnership: Map<string, Brick>\n): number {\n  return cubes.reduce((min, cube) => {\n    for (let z = cube[2]; z > 0; z--) {\n      if (cubesOwnership.has(cube[0] + ',' + cube[1] + ',' + (z - 1))) {\n        return min < cube[2] - z ? min : cube[2] - z\n      }\n    }\n    return min < cube[2] ? min : cube[2]\n  }, Infinity)\n}\n")),i.createElement(e.pre,null,i.createElement(e.code,{className:"language-csharp"},"public override object PartOne()\n{\n    var bricks = Parse(Input);\n    BricksWithGravity(bricks);\n    HashSet<int> removable = bricks.Select(x => x.ID).ToHashSet();\n\n    foreach (var brick in bricks)\n    {\n        if (brick.SupportedBy.Count == 1)\n            removable.Remove(brick.SupportedBy.First());\n    }\n\n    return removable.Count;\n}\n\nprivate static List<Brick> Parse(string[] input)\n{\n    List<Brick> bricks = [];\n    for (int i = 0; i < input.Length; i++)\n    {\n        var b = input[i].Split(\"~\")\n                        .Select(x => x.Split(',')\n                                      .Select(x => int.Parse(x))\n                                      .ToArray()).ToArray();\n\n        bricks.Add(new(b[0], b[1], i));\n    }\n    return bricks;\n}\n\nprivate static void BricksWithGravity(List<Brick> bricks)\n{\n    Dictionary<(int x, int y, int z), Brick> cubesOwnership = [];\n    Dictionary<int, List<Brick>> bricksByZ = bricks.GroupBy(brick => brick.Cubes.Min(x => x[2]))\n                                                   .ToDictionary(key => key.Key, value => value.ToList());\n\n    foreach (var brick in bricksByZ.OrderBy(x => x.Key).SelectMany(v => v.Value))\n        DropBrick(brick, cubesOwnership);\n}\n\nprivate static void DropBrick(Brick brick, Dictionary<(int x, int y, int z), Brick> cubesOwnership)\n{\n    var distance = FindBottomDistance(cubesOwnership, brick.Cubes);\n    foreach (var cube in brick.Cubes)\n        cube[2] -= distance;\n\n    foreach (var cube in brick.Cubes)\n    {\n        cubesOwnership[(cube[0], cube[1], cube[2])] = brick;\n\n        if (cubesOwnership.TryGetValue((cube[0], cube[1], cube[2] - 1), out var support) && support.ID != brick.ID)\n        {\n            support.Supporting.Add(brick.ID);\n            brick.SupportedBy.Add(support.ID);\n        }\n    }\n\n    static int FindBottomDistance(Dictionary<(int x, int y, int z), Brick> cubesOwnership, List<int[]> cubes)\n    {\n        return (cubes.Min(cube =>\n        {\n            for (int z = cube[2]; z > 0; z--)\n            {\n                if (cubesOwnership.ContainsKey((cube[0], cube[1], z - 1)))\n                    return cube[2] - z;\n            }\n            return cube[2];\n        }));\n    }\n}\n\ninternal class Brick\n{\n    internal List<int[]> Cubes;\n    internal HashSet<int> SupportedBy = [];\n    internal HashSet<int> Supporting = [];\n    internal int ID;\n    public Brick(int[] coorda, int[] coordb, int iD)\n    {\n        ID = iD;\n        Cubes = [];\n        for (int x = coorda[0]; x <= coordb[0]; x++)\n        {\n            for (int y = coorda[1]; y <= coordb[1]; y++)\n            {\n                for (int z = coorda[2]; z <= coordb[2]; z++)\n                {\n                    Cubes.Add([x, y, z]);\n                }\n            }\n        }\n    }\n}\n"))),"\n",i.createElement(e.h2,null,"Part Two"),"\n",i.createElement(e.p,null,"After part 1 was a reasonably involved model (by the standards of part 1s), I was expecting a real brainteaser for part 2. Instead it played very nicely with my part 1 solution, and it simply requires walking up the pile of bricks testing which would no longer be supported. No tricks here!"),"\n",i.createElement(r,{names:"typescript|C#"},i.createElement(e.pre,null,i.createElement(e.code,{className:"language-ts"},"export function partTwo(input: string[]): number | string {\n  const bricks = parse(input)\n  bricksWithGravity(bricks)\n  const results = new Map<number, number>()\n\n  bricks.forEach((brick) =>\n    results.set(\n      brick.id,\n      countSupported(bricks, brick.id, new Set<number>([brick.id]))\n    )\n  )\n\n  return results.values().reduce((total, value) => total + value, 0)\n}\n\nfunction countSupported(\n  bricks: Brick[],\n  brickID: number,\n  fallen: Set<number>\n): number {\n  const brick = bricks[brickID]\n  if (\n    fallen.has(brickID) ||\n    brick.supportedBy.values().every((value) => fallen.has(value))\n  ) {\n    fallen.add(brickID)\n    brick.supporting.values().forEach((supported) => {\n      if (!fallen.has(supported)) countSupported(bricks, supported, fallen)\n    })\n  }\n\n  return fallen.size - 1\n}\n")),i.createElement(e.pre,null,i.createElement(e.code,{className:"language-csharp"},"public override object PartTwo()\n{\n    var bricks = Parse(Input);\n    BricksWithGravity(bricks);\n\n    Dictionary<int, int> results = [];\n\n    foreach (var brick in bricks)\n        results[brick.ID] = CountSupported(bricks, brick.ID, [brick.ID]);\n\n    return results.Values.Sum();\n\n}\n\nprivate static int CountSupported(List<Brick> bricks, int brickID, HashSet<int> fallen)\n{\n    var brick = bricks[brickID];\n\n    if (fallen.Contains(brick.ID) || brick.SupportedBy.All(x => fallen.Contains(x)))\n    {\n        fallen.Add(brickID);\n        foreach (var supported in brick.Supporting)\n            if (!fallen.Contains(supported))\n                CountSupported(bricks, supported, fallen);\n\n    }\n    return fallen.Count - 1;\n}\n"))))}var s=function(n){void 0===n&&(n={});const{wrapper:e}=Object.assign({},(0,t.RP)(),n.components);return e?i.createElement(e,n,i.createElement(c,n)):c(n)};var a=r(2779),o=r(7206),u=r(791),b=r(4813),l=r(572);const p={CodeBox:a.A};function k(n){let{pageContext:e,children:r}=n;return i.createElement(i.Fragment,null,i.createElement(b.A,null),i.createElement("div",{className:"min-h-screen bg-chicPrimary"},i.createElement(u.A,{props:e.list}),i.createElement("div",{className:"adventofcode max-w-[60%] ml-[20%]"},i.createElement("h1",null,i.createElement("a",{href:"https://adventofcode.com/"+e.year+"/day/"+e.puzz},e.year+" Day "+e.puzz+" - "+e.title)),i.createElement(t.xA,{components:p},r),e.puzz&&e.year?i.createElement(o.A,{year:e.year,puzz:e.puzz}):i.createElement(i.Fragment,null))),i.createElement(l.A,null))}function d(n){return i.createElement(k,n,i.createElement(s,n))}const m=()=>i.createElement(i.Fragment,null,i.createElement("title",null,"Joel-Allan-NZ - Advent of Code"),i.createElement("html",{lang:"en"}),i.createElement("link",{rel:"preconnect",href:"https://fonts.googleapis.com"}),i.createElement("link",{rel:"preconnect",href:"https://fonts.gstatic.com"}),i.createElement("link",{href:"https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&family=VT323&display=swap",rel:"stylesheet"}))}}]);
//# sourceMappingURL=component---src-components-layout-tsx-content-file-path-days-2023-22-mdx-3e395a3443bb20ee2da0.js.map