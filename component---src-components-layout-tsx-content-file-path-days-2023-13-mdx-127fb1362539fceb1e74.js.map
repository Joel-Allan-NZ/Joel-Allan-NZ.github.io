{"version":3,"file":"component---src-components-layout-tsx-content-file-path-days-2023-13-mdx-127fb1362539fceb1e74.js","mappings":"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","sources":["webpack://joel-allan-nz.github.io/./days/2023/13.mdx","webpack://joel-allan-nz.github.io/./src/components/Layout.tsx"],"sourcesContent":["/*@jsxRuntime classic @jsx React.createElement @jsxFrag React.Fragment*/\nimport {useMDXComponents as _provideComponents} from \"@mdx-js/react\";\nimport React from \"react\";\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    p: \"p\",\n    em: \"em\",\n    pre: \"pre\",\n    code: \"code\"\n  }, _provideComponents(), props.components), {CodeBox} = _components;\n  if (!CodeBox) _missingMdxReference(\"CodeBox\", true);\n  return React.createElement(React.Fragment, null, React.createElement(_components.h2, null, \"Part One\"), \"\\n\", React.createElement(_components.p, null, \"The solution code has been modified to suit part 2, but the core idea is pretty simple: check each column (and then each row) for a reflection by checking rows/columns equally distant from a potential reflection for equality.\"), \"\\n\", React.createElement(\"br\"), \"\\n\", React.createElement(_components.p, null, \"You \", React.createElement(_components.em, null, \"could\"), \" use string equality comparisons for the rows, but part 2 causes issues\\nthere.\"), \"\\n\", React.createElement(CodeBox, {\n    names: \"typescript|C#\"\n  }, React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-ts\"\n  }, \"export function partOne(input: string[]): number | string {\\n  const maps = parse(input)\\n  return maps.reduce(\\n    (total, map) =>\\n      total +\\n      (findVerticalReflection(map) ?? findHorizontalReflection(map)! * 100),\\n    0\\n  )\\n}\\n\\nfunction parse(input: string[]): string[][] {\\n  const read: string[][] = [[]]\\n  input.forEach((line) => {\\n    if (line != '') {\\n      read[read.length - 1].push(line)\\n    } else read.push([])\\n  })\\n  return read\\n}\\n\\nfunction findVerticalReflection(\\n  map: string[],\\n  flawTarget: number = 0\\n): number | undefined {\\n  for (let x = 1; x < map[0].length; x++) {\\n    const distance = Math.min(map[0].length - x, x)\\n    let mirrorPosition: number | undefined = x\\n    let flaws = 0\\n\\n    for (let j = 0; j < distance; j++) {\\n      for (let line of map) {\\n        if (line[x - j - 1] != line[x + j]) {\\n          if (++flaws > flawTarget) break\\n        }\\n      }\\n      if (flaws > flawTarget) break\\n    }\\n    if (flaws == flawTarget) return mirrorPosition\\n  }\\n}\\n\\nfunction findHorizontalReflection(\\n  map: string[],\\n  flawTarget: number = 0\\n): number | undefined {\\n  for (let y = 1; y < map.length; y++) {\\n    let flaws = 0\\n    const distance = Math.min(map.length - y, y)\\n    let mirrorPosition: number | undefined = y\\n\\n    for (let j = 0; j < distance; j++) {\\n      for (let x = 0; x < map[0].length; x++) {\\n        if (map[y + j][x] != map[y - j - 1][x]) {\\n          if (++flaws > flawTarget) break\\n        }\\n      }\\n      if (flaws > flawTarget) break\\n    }\\n    if (flaws == flawTarget) return mirrorPosition\\n  }\\n}\\n\")), React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-csharp\"\n  }, \"public override object PartOne()\\n{\\n    var maps = Parse();\\n    return maps.Sum(map => FindVerticalReflection(map) ?? FindHorizontalReflection(map) * 100 ?? 0);\\n}\\n\\nprivate List<List<string>> Parse()\\n{\\n    List<List<string>> maps = [[]];\\n    foreach (var line in Input)\\n    {\\n        if (string.IsNullOrEmpty(line))\\n        {\\n            maps.Add([]);\\n            continue;\\n        }\\n        maps[^1].Add(line);\\n    }\\n    return maps;\\n}\\n\\nprivate static int? FindVerticalReflection(List<string> map, int flawLimit = 0)\\n{\\n    for (int x = 1; x < map[0].Length; x++)\\n    {\\n        int? mirrorPosition = x;\\n        int flaws = 0;\\n        var distance = Math.Min(map[0].Length - x, x);\\n\\n        for (int j = 0; j < distance; j++)\\n        {\\n            foreach (var line in map)\\n            {\\n                if (line[x - j - 1] != line[x + j])\\n                {\\n                    if (++flaws > flawLimit)\\n                        break;\\n                }\\n            }\\n            if (flaws > flawLimit)\\n                break;\\n        }\\n        if (flaws == flawLimit)\\n            return mirrorPosition;\\n    }\\n    return null;\\n}\\n\\nprivate static int? FindHorizontalReflection(List<string> map, int flawLimit = 0)\\n{\\n    for (int y = 1; y < map.Count; y++)\\n    {\\n        int flaws = 0;\\n        int distance = Math.Min(map.Count - y, y);\\n        int? mirrorPosition = y;\\n\\n        for (int j = 0; j < distance; j++)\\n        {\\n            for (int x = 0; x < map[0].Length; x++)\\n            {\\n                if (map[y + j][x] != map[y - j - 1][x])\\n                {\\n                    if (++flaws > flawLimit)\\n                        break;\\n                }\\n            }\\n            if (flaws > flawLimit)\\n                break;\\n        }\\n        if (flaws == flawLimit)\\n            return mirrorPosition;\\n    }\\n    return null;\\n}\\n\"))), \"\\n\", React.createElement(_components.h2, null, \"Part Two\"), \"\\n\", React.createElement(_components.p, null, \"Valid reflections are now required to have a single flaw. The code is identical to the changes I made to part 1, and as we only consider reflections with a single flaw we don't need to first explicitly eliminate the part 1 reflections as valid options.\"), \"\\n\", React.createElement(CodeBox, {\n    names: \"typescript|C#\"\n  }, React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-ts\"\n  }, \"export function partTwo(input: string[]): number | string {\\n  const maps = parse(input)\\n  return maps.reduce(\\n    (total, map) =>\\n      total +\\n      (findVerticalReflection(map, 1) ??\\n        findHorizontalReflection(map, 1)! * 100),\\n    0\\n  )\\n}\\n\")), React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-csharp\"\n  }, \"public override object PartTwo()\\n{\\n    var maps = Parse();\\n    return maps.Sum(map => FindVerticalReflection(map, 1) ?? FindHorizontalReflection(map, 1) * 100 ?? 0);\\n}\\n\\n\"))));\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? React.createElement(MDXLayout, props, React.createElement(_createMdxContent, props)) : _createMdxContent(props);\n}\nexport default MDXContent;\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","import GATSBY_COMPILED_MDX from \"/home/joel/personal/advent-of-code/joel-allan-nz.github.io/days/2023/13.mdx\";\nimport React from 'react';\nimport {MDXProvider} from '@mdx-js/react';\nimport CodeBox from './CodeBox';\nimport TryYourself from './TryYourself';\nimport AdventSideNav from './AdventSideNav';\nimport Header from './Header';\nimport Footer from './Footer';\nconst shortcodes = {\n  CodeBox\n};\nfunction Layout(_ref) {\n  let {pageContext, children} = _ref;\n  return React.createElement(React.Fragment, null, React.createElement(Header, null), React.createElement(\"div\", {\n    className: \"min-h-screen bg-chicPrimary\"\n  }, React.createElement(AdventSideNav, {\n    props: pageContext.list\n  }), React.createElement(\"div\", {\n    className: \"adventofcode max-w-[60%] ml-[20%]\"\n  }, React.createElement(\"h1\", null, React.createElement(\"a\", {\n    href: \"https://adventofcode.com/\" + pageContext.year + \"/day/\" + pageContext.puzz\n  }, pageContext.year + \" Day \" + pageContext.puzz + \" - \" + pageContext.title)), React.createElement(MDXProvider, {\n    components: shortcodes\n  }, children), pageContext.puzz && pageContext.year ? React.createElement(TryYourself, {\n    year: pageContext.year,\n    puzz: pageContext.puzz\n  }) : React.createElement(React.Fragment, null))), React.createElement(Footer, null));\n}\nexport default function GatsbyMDXWrapper(props) {\n  return React.createElement(Layout, props, React.createElement(GATSBY_COMPILED_MDX, props));\n}\nexport const Head = () => React.createElement(React.Fragment, null, React.createElement(\"title\", null, \"Joel-Allan-NZ - Advent of Code\"), React.createElement(\"html\", {\n  lang: \"en\"\n}), React.createElement(\"link\", {\n  rel: \"preconnect\",\n  href: \"https://fonts.googleapis.com\"\n}), React.createElement(\"link\", {\n  rel: \"preconnect\",\n  href: \"https://fonts.gstatic.com\"\n}), React.createElement(\"link\", {\n  href: \"https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&family=VT323&display=swap\",\n  rel: \"stylesheet\"\n}));\n"],"names":["_createMdxContent","props","_components","Object","assign","h2","p","em","pre","code","_provideComponents","components","CodeBox","id","component","Error","_missingMdxReference","React","names","className","wrapper","MDXLayout","shortcodes","Layout","_ref","pageContext","children","Header","AdventSideNav","list","href","year","puzz","title","MDXProvider","TryYourself","Footer","GatsbyMDXWrapper","GATSBY_COMPILED_MDX","Head","lang","rel"],"sourceRoot":""}