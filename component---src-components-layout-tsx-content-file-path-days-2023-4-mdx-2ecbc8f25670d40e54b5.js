"use strict";(self.webpackChunkjoel_allan_nz_github_io=self.webpackChunkjoel_allan_nz_github_io||[]).push([[807],{9869:function(n,e,t){t.r(e),t.d(e,{Head:function(){return g},default:function(){return h}});var a=t(8453),r=t(6540);function c(n){const e=Object.assign({h2:"h2",p:"p",pre:"pre",code:"code"},(0,a.RP)(),n.components),{CodeBox:t}=e;return t||function(n,e){throw new Error("Expected "+(e?"component":"object")+" `"+n+"` to be defined: you likely forgot to import, pass, or provide it.")}("CodeBox",!0),r.createElement(r.Fragment,null,r.createElement(e.h2,null,"Part One"),"\n",r.createElement(e.p,null,"Purely a matter of parsing the input and checking whether the winning number count is adequate. Not a lot to this, definitely set up for part 2."),"\n",r.createElement(t,{names:"typescript|C#"},r.createElement(e.pre,null,r.createElement(e.code,{className:"language-js"},"export function partOne(input: string[]): number | string {\n  const cards = parse(input)\n\n  return cards\n    .values()\n    .reduce((total, card) => (card == 0 ? total : total + 2 ** (card - 1)), 0)\n}\n\nfunction parse(input: string[]): Map<number, number> {\n  const cards = new Map<number, number>()\n\n  input.forEach((line) => {\n    const split = line.split('|')\n    const num = split[0].split(':')\n    const numbers = new Set<string>([\n      ...num[1].matchAll(/\\d+/g).map((x) => x[0]),\n    ])\n    const winning = split[1].matchAll(/\\d+/g)\n    const game = parseInt(num[0].match(/\\d+/)![0])\n\n    const winningCount = winning.reduce(\n      (total, current) => (numbers.has(current[0]) ? total + 1 : total),\n      0\n    )\n    cards.set(game, winningCount)\n  })\n  return cards\n}\n")),r.createElement(e.pre,null,r.createElement(e.code,{className:"language-csharp"},'public override object PartOne()\n{\n    Dictionary<int, int> cards = Parse(Input);\n    return cards.Sum(x => x.Value == 0 ? 0 : (int)Math.Pow(2, x.Value - 1));\n}\n\nprivate static Dictionary<int, int> Parse(string[] input)\n{\n    Dictionary<int, int> cards = [];\n    foreach (var line in input)\n    {\n        var split = line.Split(\'|\');\n        var num = split[0].Split(\':\');\n        var numbers = Regex.Matches(num[1], @"\\d+").Select(x => x.Value).ToHashSet();\n        var winning = Regex.Matches(split[1], @"\\d+");\n        var game = Regex.Match(num[0], @"\\d+").Value;\n        cards[int.Parse(game)] = winning.Count(x => numbers.Contains(x.Value));\n    }\n    return cards;\n}\n'))),"\n",r.createElement(e.h2,null,"Part Two"),"\n",r.createElement(e.p,null,"Nothing groundbreaking here, just ",r.createElement("a",{href:"https://en.wikipedia.org/wiki/Recursion_(computer_science)"},"recursively")," finding the number of cards awarded by a win by also checking how cards the children award (and grandchildren and...). Values are ",r.createElement("a",{href:"https://en.wikipedia.org/wiki/Memoization"},"memoized")," to avoid recalculating values.\nTake those values, add 'em up, and you have your total."),"\n",r.createElement(t,{names:"typescript|C#"},r.createElement(e.pre,null,r.createElement(e.code,{className:"language-ts"},"export function partTwo(input: string[]): number | string {\n  const cards = parse(input)\n  const cache = new Map<number, number>()\n  return cards\n    .keys()\n    .reduce((total, card) => countCardWinnings(cards, cache, card) + total, 0)\n}\n\nfunction countCardWinnings(\n  cards: Map<number, number>,\n  cache: Map<number, number>,\n  card: number\n): number {\n  if (cache.has(card)) return cache.get(card)!\n\n  const winSize = cards.get(card)! + card\n  let total = 1\n  for (let i = card + 1; i <= winSize; i++)\n    total += countCardWinnings(cards, cache, i)\n\n  cache.set(card, total)\n  return total\n}\n")),r.createElement(e.pre,null,r.createElement(e.code,{className:"language-csharp"},"public override object PartTwo()\n{\n    Dictionary<int, int> cards = Parse(Input);\n    Dictionary<int, int> cache = [];\n    return cards.Sum(card => CountCardWinnings(cards, cache, card.Key));\n}\n\nprivate static int CountCardWinnings(Dictionary<int, int> cards, Dictionary<int, int> cache, int card)\n{\n    if (cache.TryGetValue(card, out int value))\n    {\n        return value;\n    }\n    else\n    {\n        int winSize = cards[card];\n        int sum = 1;\n        for (int i = card + 1; i <= card + winSize; i++)\n        {\n            sum += CountCardWinnings(cards, cache, i);\n        }\n        cache[card] = sum;\n        return sum;\n    }\n}\n"))))}var i=function(n){void 0===n&&(n={});const{wrapper:e}=Object.assign({},(0,a.RP)(),n.components);return e?r.createElement(e,n,r.createElement(c,n)):c(n)};var l=t(2779),o=t(7206),s=t(791),u=t(4813),m=t(572);const d={CodeBox:l.A};function p(n){let{pageContext:e,children:t}=n;return r.createElement(r.Fragment,null,r.createElement(u.A,null),r.createElement("div",{className:"min-h-screen bg-chicPrimary"},r.createElement(s.A,{props:e.list}),r.createElement("div",{className:"adventofcode max-w-[60%] ml-[20%]"},r.createElement("h1",null,r.createElement("a",{href:"https://adventofcode.com/"+e.year+"/day/"+e.puzz},e.year+" Day "+e.puzz+" - "+e.title)),r.createElement(a.xA,{components:d},t),e.puzz&&e.year?r.createElement(o.A,{year:e.year,puzz:e.puzz}):r.createElement(r.Fragment,null))),r.createElement(m.A,null))}function h(n){return r.createElement(p,n,r.createElement(i,n))}const g=()=>r.createElement(r.Fragment,null,r.createElement("title",null,"Joel-Allan-NZ - Advent of Code"),r.createElement("html",{lang:"en"}),r.createElement("link",{rel:"preconnect",href:"https://fonts.googleapis.com"}),r.createElement("link",{rel:"preconnect",href:"https://fonts.gstatic.com"}),r.createElement("link",{href:"https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&family=VT323&display=swap",rel:"stylesheet"}))}}]);
//# sourceMappingURL=component---src-components-layout-tsx-content-file-path-days-2023-4-mdx-2ecbc8f25670d40e54b5.js.map