{"version":3,"file":"component---src-components-layout-tsx-content-file-path-days-2023-22-mdx-3e395a3443bb20ee2da0.js","mappings":"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","sources":["webpack://joel-allan-nz.github.io/./days/2023/22.mdx","webpack://joel-allan-nz.github.io/./src/components/Layout.tsx"],"sourcesContent":["/*@jsxRuntime classic @jsx React.createElement @jsxFrag React.Fragment*/\nimport {useMDXComponents as _provideComponents} from \"@mdx-js/react\";\nimport React from \"react\";\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    p: \"p\",\n    pre: \"pre\",\n    code: \"code\"\n  }, _provideComponents(), props.components), {CodeBox} = _components;\n  if (!CodeBox) _missingMdxReference(\"CodeBox\", true);\n  return React.createElement(React.Fragment, null, React.createElement(_components.h2, null, \"Part One\"), \"\\n\", React.createElement(_components.p, null, \"Yet another part one based around modeling a system. My lazy approach to brick falling is just to populate the cube coordinates of each brick, then take bricks from the lowest un-moved Z, and move those bricks downward to the lowest Z where a intersection with another brick or the ground doesn't exist.\"), \"\\n\", React.createElement(\"br\"), \"\\n\", React.createElement(_components.p, null, \"After moving each brick, I check for any bricks that are supporting it, and update\\nsets of supporting/being supported by. Finally, the number of disintegratable bricks\\nis equivalent to the total number of bricks, less any that are the sole support for\\nothers.\", ' '), \"\\n\", React.createElement(CodeBox, {\n    names: \"typescript|C#\"\n  }, React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-ts\"\n  }, \"export function partOne(input: string[]): number | string {\\n  const bricks = parse(input)\\n  bricksWithGravity(bricks)\\n  const removable = new Set<number>(bricks.map((brick) => brick.id))\\n\\n  bricks.forEach((brick) => {\\n    if (brick.supportedBy.size == 1)\\n      removable.delete(brick.supportedBy.values().toArray()[0])\\n  })\\n\\n  return removable.size\\n}\\n\\ninterface Brick {\\n  cubes: number[][]\\n  supportedBy: Set<number>\\n  supporting: Set<number>\\n  id: number\\n}\\n\\nfunction parse(input: string[]): Brick[] {\\n  const bricks: Brick[] = []\\n\\n  input.forEach((line, index) => {\\n    const brickEnds = line\\n      .split('~')\\n      .map((c) => c.split(',').map((c) => parseInt(c)))\\n\\n    const cubes: number[][] = []\\n    for (let x = brickEnds[0][0]; x <= brickEnds[1][0]; x++) {\\n      for (let y = brickEnds[0][1]; y <= brickEnds[1][1]; y++) {\\n        for (let z = brickEnds[0][2]; z <= brickEnds[1][2]; z++) {\\n          cubes.push([x, y, z])\\n        }\\n      }\\n    }\\n\\n    bricks.push({\\n      cubes,\\n      supportedBy: new Set<number>(),\\n      supporting: new Set<number>(),\\n      id: index,\\n    })\\n  })\\n\\n  return bricks\\n}\\n\\nfunction bricksWithGravity(bricks: Brick[]): void {\\n  const cubesOwnership = new Map<string, Brick>()\\n  const bricksByZ = new Map<number, Brick[]>()\\n\\n  bricks.forEach((brick) => {\\n    const lowestCubeZ = brick.cubes.reduce(\\n      (min, cube) => (min < cube[2] ? min : cube[2]),\\n      Infinity\\n    )\\n    if (bricksByZ.has(lowestCubeZ)) bricksByZ.get(lowestCubeZ)?.push(brick)\\n    else bricksByZ.set(lowestCubeZ, [brick])\\n  })\\n\\n  bricksByZ\\n    .keys()\\n    .toArray()\\n    .sort((x, y) => x - y)\\n    .forEach((key) => {\\n      bricksByZ\\n        .get(key)!\\n        .values()\\n        .forEach((brick) => dropBrick(brick, cubesOwnership))\\n    })\\n}\\n\\nfunction dropBrick(brick: Brick, cubesOwnership: Map<string, Brick>): void {\\n  const dropDistance = findBottomDistance(brick.cubes, cubesOwnership)\\n\\n  brick.cubes.forEach((cube) => {\\n    cube[2] -= dropDistance\\n    cubesOwnership.set(cube.join(','), brick)\\n    const below = cubesOwnership.get(\\n      cube[0] + ',' + cube[1] + ',' + (cube[2] - 1)\\n    )\\n\\n    if (below && below.id != brick.id) {\\n      below.supporting.add(brick.id)\\n      brick.supportedBy.add(below.id)\\n    }\\n  })\\n}\\n\\nfunction findBottomDistance(\\n  cubes: number[][],\\n  cubesOwnership: Map<string, Brick>\\n): number {\\n  return cubes.reduce((min, cube) => {\\n    for (let z = cube[2]; z > 0; z--) {\\n      if (cubesOwnership.has(cube[0] + ',' + cube[1] + ',' + (z - 1))) {\\n        return min < cube[2] - z ? min : cube[2] - z\\n      }\\n    }\\n    return min < cube[2] ? min : cube[2]\\n  }, Infinity)\\n}\\n\")), React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-csharp\"\n  }, \"public override object PartOne()\\n{\\n    var bricks = Parse(Input);\\n    BricksWithGravity(bricks);\\n    HashSet<int> removable = bricks.Select(x => x.ID).ToHashSet();\\n\\n    foreach (var brick in bricks)\\n    {\\n        if (brick.SupportedBy.Count == 1)\\n            removable.Remove(brick.SupportedBy.First());\\n    }\\n\\n    return removable.Count;\\n}\\n\\nprivate static List<Brick> Parse(string[] input)\\n{\\n    List<Brick> bricks = [];\\n    for (int i = 0; i < input.Length; i++)\\n    {\\n        var b = input[i].Split(\\\"~\\\")\\n                        .Select(x => x.Split(',')\\n                                      .Select(x => int.Parse(x))\\n                                      .ToArray()).ToArray();\\n\\n        bricks.Add(new(b[0], b[1], i));\\n    }\\n    return bricks;\\n}\\n\\nprivate static void BricksWithGravity(List<Brick> bricks)\\n{\\n    Dictionary<(int x, int y, int z), Brick> cubesOwnership = [];\\n    Dictionary<int, List<Brick>> bricksByZ = bricks.GroupBy(brick => brick.Cubes.Min(x => x[2]))\\n                                                   .ToDictionary(key => key.Key, value => value.ToList());\\n\\n    foreach (var brick in bricksByZ.OrderBy(x => x.Key).SelectMany(v => v.Value))\\n        DropBrick(brick, cubesOwnership);\\n}\\n\\nprivate static void DropBrick(Brick brick, Dictionary<(int x, int y, int z), Brick> cubesOwnership)\\n{\\n    var distance = FindBottomDistance(cubesOwnership, brick.Cubes);\\n    foreach (var cube in brick.Cubes)\\n        cube[2] -= distance;\\n\\n    foreach (var cube in brick.Cubes)\\n    {\\n        cubesOwnership[(cube[0], cube[1], cube[2])] = brick;\\n\\n        if (cubesOwnership.TryGetValue((cube[0], cube[1], cube[2] - 1), out var support) && support.ID != brick.ID)\\n        {\\n            support.Supporting.Add(brick.ID);\\n            brick.SupportedBy.Add(support.ID);\\n        }\\n    }\\n\\n    static int FindBottomDistance(Dictionary<(int x, int y, int z), Brick> cubesOwnership, List<int[]> cubes)\\n    {\\n        return (cubes.Min(cube =>\\n        {\\n            for (int z = cube[2]; z > 0; z--)\\n            {\\n                if (cubesOwnership.ContainsKey((cube[0], cube[1], z - 1)))\\n                    return cube[2] - z;\\n            }\\n            return cube[2];\\n        }));\\n    }\\n}\\n\\ninternal class Brick\\n{\\n    internal List<int[]> Cubes;\\n    internal HashSet<int> SupportedBy = [];\\n    internal HashSet<int> Supporting = [];\\n    internal int ID;\\n    public Brick(int[] coorda, int[] coordb, int iD)\\n    {\\n        ID = iD;\\n        Cubes = [];\\n        for (int x = coorda[0]; x <= coordb[0]; x++)\\n        {\\n            for (int y = coorda[1]; y <= coordb[1]; y++)\\n            {\\n                for (int z = coorda[2]; z <= coordb[2]; z++)\\n                {\\n                    Cubes.Add([x, y, z]);\\n                }\\n            }\\n        }\\n    }\\n}\\n\"))), \"\\n\", React.createElement(_components.h2, null, \"Part Two\"), \"\\n\", React.createElement(_components.p, null, \"After part 1 was a reasonably involved model (by the standards of part 1s), I was expecting a real brainteaser for part 2. Instead it played very nicely with my part 1 solution, and it simply requires walking up the pile of bricks testing which would no longer be supported. No tricks here!\"), \"\\n\", React.createElement(CodeBox, {\n    names: \"typescript|C#\"\n  }, React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-ts\"\n  }, \"export function partTwo(input: string[]): number | string {\\n  const bricks = parse(input)\\n  bricksWithGravity(bricks)\\n  const results = new Map<number, number>()\\n\\n  bricks.forEach((brick) =>\\n    results.set(\\n      brick.id,\\n      countSupported(bricks, brick.id, new Set<number>([brick.id]))\\n    )\\n  )\\n\\n  return results.values().reduce((total, value) => total + value, 0)\\n}\\n\\nfunction countSupported(\\n  bricks: Brick[],\\n  brickID: number,\\n  fallen: Set<number>\\n): number {\\n  const brick = bricks[brickID]\\n  if (\\n    fallen.has(brickID) ||\\n    brick.supportedBy.values().every((value) => fallen.has(value))\\n  ) {\\n    fallen.add(brickID)\\n    brick.supporting.values().forEach((supported) => {\\n      if (!fallen.has(supported)) countSupported(bricks, supported, fallen)\\n    })\\n  }\\n\\n  return fallen.size - 1\\n}\\n\")), React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-csharp\"\n  }, \"public override object PartTwo()\\n{\\n    var bricks = Parse(Input);\\n    BricksWithGravity(bricks);\\n\\n    Dictionary<int, int> results = [];\\n\\n    foreach (var brick in bricks)\\n        results[brick.ID] = CountSupported(bricks, brick.ID, [brick.ID]);\\n\\n    return results.Values.Sum();\\n\\n}\\n\\nprivate static int CountSupported(List<Brick> bricks, int brickID, HashSet<int> fallen)\\n{\\n    var brick = bricks[brickID];\\n\\n    if (fallen.Contains(brick.ID) || brick.SupportedBy.All(x => fallen.Contains(x)))\\n    {\\n        fallen.Add(brickID);\\n        foreach (var supported in brick.Supporting)\\n            if (!fallen.Contains(supported))\\n                CountSupported(bricks, supported, fallen);\\n\\n    }\\n    return fallen.Count - 1;\\n}\\n\"))));\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? React.createElement(MDXLayout, props, React.createElement(_createMdxContent, props)) : _createMdxContent(props);\n}\nexport default MDXContent;\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","import GATSBY_COMPILED_MDX from \"/home/joel/personal/advent-of-code/joel-allan-nz.github.io/days/2023/22.mdx\";\nimport React from 'react';\nimport {MDXProvider} from '@mdx-js/react';\nimport CodeBox from './CodeBox';\nimport TryYourself from './TryYourself';\nimport AdventSideNav from './AdventSideNav';\nimport Header from './Header';\nimport Footer from './Footer';\nconst shortcodes = {\n  CodeBox\n};\nfunction Layout(_ref) {\n  let {pageContext, children} = _ref;\n  return React.createElement(React.Fragment, null, React.createElement(Header, null), React.createElement(\"div\", {\n    className: \"min-h-screen bg-chicPrimary\"\n  }, React.createElement(AdventSideNav, {\n    props: pageContext.list\n  }), React.createElement(\"div\", {\n    className: \"adventofcode max-w-[60%] ml-[20%]\"\n  }, React.createElement(\"h1\", null, React.createElement(\"a\", {\n    href: \"https://adventofcode.com/\" + pageContext.year + \"/day/\" + pageContext.puzz\n  }, pageContext.year + \" Day \" + pageContext.puzz + \" - \" + pageContext.title)), React.createElement(MDXProvider, {\n    components: shortcodes\n  }, children), pageContext.puzz && pageContext.year ? React.createElement(TryYourself, {\n    year: pageContext.year,\n    puzz: pageContext.puzz\n  }) : React.createElement(React.Fragment, null))), React.createElement(Footer, null));\n}\nexport default function GatsbyMDXWrapper(props) {\n  return React.createElement(Layout, props, React.createElement(GATSBY_COMPILED_MDX, props));\n}\nexport const Head = () => React.createElement(React.Fragment, null, React.createElement(\"title\", null, \"Joel-Allan-NZ - Advent of Code\"), React.createElement(\"html\", {\n  lang: \"en\"\n}), React.createElement(\"link\", {\n  rel: \"preconnect\",\n  href: \"https://fonts.googleapis.com\"\n}), React.createElement(\"link\", {\n  rel: \"preconnect\",\n  href: \"https://fonts.gstatic.com\"\n}), React.createElement(\"link\", {\n  href: \"https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&family=VT323&display=swap\",\n  rel: \"stylesheet\"\n}));\n"],"names":["_createMdxContent","props","_components","Object","assign","h2","p","pre","code","_provideComponents","components","CodeBox","id","component","Error","_missingMdxReference","React","names","className","wrapper","MDXLayout","shortcodes","Layout","_ref","pageContext","children","Header","AdventSideNav","list","href","year","puzz","title","MDXProvider","TryYourself","Footer","GatsbyMDXWrapper","GATSBY_COMPILED_MDX","Head","lang","rel"],"sourceRoot":""}