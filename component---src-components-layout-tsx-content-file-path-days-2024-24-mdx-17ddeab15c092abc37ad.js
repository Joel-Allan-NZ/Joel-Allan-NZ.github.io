"use strict";(self.webpackChunkjoel_allan_nz_github_io=self.webpackChunkjoel_allan_nz_github_io||[]).push([[5142],{6527:function(e,t,n){n.r(t),n.d(t,{Head:function(){return m},default:function(){return f}});var a=n(8453),r=n(6540);function i(e){const t=Object.assign({h2:"h2",p:"p",pre:"pre",code:"code"},(0,a.RP)(),e.components),{CodeBox:n}=t;return n||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("CodeBox",!0),r.createElement(r.Fragment,null,r.createElement(t.h2,null,"Part One"),"\n",r.createElement(t.p,null,"As is so often the case with Advent of Code, the first part is mostly just setting things up."),"\n",r.createElement("br"),"\n",r.createElement(t.p,null,"All we need to do is model the system of wires, run the system until it's in its\nfinal state, and convert a binary string to a decimal number."),"\n",r.createElement(n,{boxname:"one",names:"typescript|C#"},r.createElement(t.pre,null,r.createElement(t.code,{className:"language-js"},"export function partOne(input: string[]): number | string {\n  const { wires, gatesByWire } = parse(input)\n  const binaryString = runSystem(wires, gatesByWire)\n  return parseInt(binaryString, 2)\n}\n\ninterface Gate {\n  a: string\n  b: string\n  operation: string\n  output: string\n}\n\nfunction parse(input: string[]): {\n  wires: Map<string, boolean | undefined>\n  gatesByWire: Map<string, Gate[]>\n} {\n  const wires = new Map<string, boolean | undefined>()\n  const gatesByWire = new Map<string, Gate[]>()\n  let gates = false\n\n  input.forEach((line) => {\n    if (!line || line.length == 0) {\n      gates = true\n    } else {\n      if (gates) {\n        const split = line.split(/ /)\n        const gate: Gate = {\n          a: split[0],\n          b: split[2],\n          operation: split[1],\n          output: split[4],\n        }\n        if (!gatesByWire.has(gate.a)) gatesByWire.set(gate.a, [gate])\n        else gatesByWire.get(gate.a)?.push(gate)\n        if (!gatesByWire.has(gate.b)) gatesByWire.set(gate.b, [gate])\n        else gatesByWire.get(gate.b)?.push(gate)\n\n        if (!wires.has(gate.a)) wires.set(gate.a, undefined)\n        if (!wires.has(gate.b)) wires.set(gate.b, undefined)\n        if (!wires.has(gate.output)) wires.set(gate.output, undefined)\n      } else {\n        const split = line.split(/: /)\n        wires.set(split[0], split[1] === '1')\n      }\n    }\n  })\n  return { wires, gatesByWire }\n}\n\nfunction runSystem(\n  wires: Map<string, boolean | undefined>,\n  gates: Map<string, Gate[]>\n): string {\n  let gatesToProcess = [...gates.values().toArray()].flatMap((x) => x)\n  let gatesToProcessNext: Gate[] = []\n\n  while (gatesToProcess.length > 0) {\n    const currentGate = gatesToProcess.shift()!\n    const gateResult = resolveGate(currentGate, wires)\n    if (wires.get(currentGate.output) != gateResult) {\n      wires.set(currentGate.output, gateResult)\n      if (gates.has(currentGate.output)) {\n        gatesToProcessNext = [\n          ...gatesToProcessNext,\n          ...gates.get(currentGate.output)!,\n        ]\n      }\n    }\n    if (gatesToProcess.length == 0) {\n      gatesToProcess = gatesToProcessNext\n      gatesToProcessNext = []\n    }\n  }\n\n  return wires\n    .keys()\n    .filter((x) => x.startsWith('z'))\n    .toArray()\n    .sort((x, y) => (y > x ? 1 : y == x ? 0 : -1))\n    .reduce(\n      (total, current) => (wires.get(current) ? total + '1' : total + '0'),\n      ''\n    )\n}\n\nfunction resolveGate(\n  gate: Gate,\n  wires: Map<string, boolean | undefined>\n): boolean | undefined {\n  const a = wires.get(gate.a)\n  const b = wires.get(gate.b)\n\n  if (a === undefined || b === undefined) return undefined\n  if (gate.operation == 'AND') return a && b\n  if (gate.operation == 'OR') return a || b\n  if (gate.operation == 'XOR') return a != b\n}\n")),r.createElement(t.pre,null,r.createElement(t.code,{className:"language-csharp"},"public override object PartOne()\n{\n    var (wires, gates) = Parse();\n    var binaryString = RunSystem(wires, gates);\n    return Convert.ToInt64(binaryString, 2);\n}\n\nprivate static string RunSystem(Dictionary<string, bool?> wires, Dictionary<string, List<Gate>> gates)\n{\n    Queue<Gate> gatesToProcess = new(gates.SelectMany(x => x.Value).ToHashSet());\n    Queue<Gate> gatesToProcessNextStep = [];\n\n    while (gatesToProcess.Count > 0)\n    {\n        var currentGate = gatesToProcess.Dequeue();\n        var gateResult = ResolveGate(currentGate, wires);\n        if (wires[currentGate.Output] != gateResult)\n        {\n            wires[currentGate.Output] = gateResult;\n            if (gates.TryGetValue(currentGate.Output, out var nextGates))\n            {\n                foreach (var potentiallyChangedGate in nextGates)\n                    gatesToProcessNextStep.Enqueue(potentiallyChangedGate);\n            }\n        }\n\n        if (gatesToProcess.Count == 0)\n        {\n            gatesToProcess = gatesToProcessNextStep;\n            gatesToProcessNextStep = [];\n        }\n    }\n\n    return wires.Where(x => x.Key.StartsWith('z'))\n                .OrderByDescending(x => x.Key)\n                .Aggregate(\"\", (x, y) => x + (y.Value == true ? \"1\" : \"0\"));\n}\n\nprivate (Dictionary<string, bool?> wires, Dictionary<string, List<Gate>> gates) Parse()\n{\n    Dictionary<string, bool?> wires = [];\n    Dictionary<string, List<Gate>> gatesByWire = [];\n    bool gates = false;\n\n    foreach (var line in Input)\n    {\n        if (string.IsNullOrEmpty(line))\n        {\n            gates = true;\n            continue;\n        }\n        if (gates)\n        {\n            var split = line.Split([' ', '-', '>'], StringSplitOptions.RemoveEmptyEntries);\n\n            Gate gate = new(split[0], split[2], OperationFromString(split[1]), split[3]);\n            gatesByWire.AddToOrCreateCollection(gate.A, gate);\n            gatesByWire.AddToOrCreateCollection(gate.B, gate);\n\n            if (!wires.ContainsKey(gate.A))\n                wires.Add(gate.A, null);\n            if (!wires.ContainsKey(gate.B))\n                wires.Add(gate.B, null);\n            if (!wires.ContainsKey(gate.Output))\n                wires.Add(gate.Output, null);\n        }\n        else\n        {\n            var split = line.Split([' ', ':'], StringSplitOptions.RemoveEmptyEntries);\n            wires.Add(split[0], split[1].Equals(\"1\"));\n        }\n    }\n\n    return (wires, gatesByWire);\n}\n\nprivate static bool? ResolveGate(Gate gate, Dictionary<string, bool?> wires)\n{\n    if (wires[gate.A] == null || wires[gate.B] == null)\n        return null;\n\n    bool a = wires[gate.A] == true, b = wires[gate.B] == true;\n    return gate.Operation switch\n    {\n        GateOperation.AND => a && b,\n        GateOperation.OR => a || b,\n        _ => a != b,\n    };\n}\n\nprivate static GateOperation OperationFromString(string s) => s switch\n{\n    \"AND\" => GateOperation.AND,\n    \"OR\" => GateOperation.OR,\n    _ => GateOperation.XOR,\n};\n\ninternal struct Gate(string wireA, string wireB, GateOperation operation, string outputWire)\n{\n    internal string A = wireA;\n    internal string B = wireB;\n    internal GateOperation Operation = operation;\n    internal string Output = outputWire;\n\n}\ninternal enum GateOperation { AND, OR, XOR };\n"))),"\n",r.createElement(t.h2,null,"Part Two"),"\n",r.createElement(t.p,null,"The puzzle gives us the critical piece of information without needing to deduce it: the system is simulating the addition of two binary numbers."),"\n",r.createElement("br"),"\n",r.createElement(t.p,null,"Once we know that, we can simplify the system a little to look for where logic gates\naren't currently correct for the ",r.createElement("a",{href:"https://www.electronics-tutorials.ws/combination/comb_7.html"},"binary addition")," process, which is exactly what we're looking for. So I simulate some ",r.createElement("a",{href:"https://en.wikipedia.org/wiki/Adder_(electronics)"},"adders")," to find the logic gate sets that aren't correct. It requires a little domain specific knowledge, but the actual code is pretty simple."),"\n",r.createElement(n,{boxname:"two",names:"typescript|C#"},r.createElement(t.pre,null,r.createElement(t.code,{className:"language-js"},"eexport function partTwo(input: string[]): number | string {\n  const { wires, gatesByWire } = parse(input)\n  const zBits =\n    'z' +\n    wires\n      .keys()\n      .reduce((sum, wire) => (wire.startsWith('z') ? sum + 1 : sum), -1)\n  const gates = [...new Set([...gatesByWire.values().flatMap((x) => x)])]\n  const incorrectGates = gates.filter(\n    (gate) => !isValidGate(gatesByWire, gate, zBits)\n  )\n\n  return incorrectGates\n    .map((x) => x.output)\n    .sort()\n    .join(',')\n}\n\nfunction isValidGate(\n  gatesByWire: Map<string, Gate[]>,\n  gate: Gate,\n  zBits: string\n): boolean {\n  if (isFullAdderStart(gate)) {\n    if (gatesByWire.has(gate.output)) {\n      const childGates = gatesByWire.get(gate.output)!\n      if (\n        gate.operation == 'AND' &&\n        childGates.some((x) => x.operation == 'AND')\n      )\n        return false\n      if (\n        gate.operation == 'XOR' &&\n        childGates.some((x) => x.operation == 'OR')\n      )\n        return false\n    }\n  }\n  if (isFullAdderEnd(gate, zBits) && gate.operation != 'XOR') return false\n  if (isAdderMiddle(gate) && gate.operation == 'XOR') return false\n  return true\n}\n\nfunction isAdderMiddle(gate: Gate): boolean {\n  return (\n    !gate.a.startsWith('x') &&\n    !gate.a.startsWith('y') &&\n    !gate.b.startsWith('x') &&\n    !gate.b.startsWith('y') &&\n    !gate.output.startsWith('z')\n  )\n}\n\nfunction isFullAdderEnd(gate: Gate, zBits: string): boolean {\n  return gate.output.startsWith('z') && gate.output != zBits\n}\n\nfunction isFullAdderStart(gate: Gate) {\n  return (\n    (gate.a.startsWith('x') || gate.a.startsWith('y')) &&\n    (gate.b.startsWith('x') || gate.b.startsWith('y')) &&\n    !gate.a.endsWith('00') &&\n    !gate.b.endsWith('00')\n  )\n}\n")),r.createElement(t.pre,null,r.createElement(t.code,{className:"language-csharp"},"public override object PartTwo()\n{\n    var (wires, gates) = Parse();\n    var bigEndianZ = \"z\" + (wires.Count(x => x.Key.StartsWith('z')) - 1);\n    var gatesList = gates.Values.SelectMany(x => x).ToHashSet();\n\n    var incorrectGates = gatesList.Where(x => !IsValidGate(gates, x, bigEndianZ));\n\n    return incorrectGates.OrderBy(x => x.Output)\n                         .Aggregate(\"\", (x, y) => x + ',' + y.Output)[1..];\n}\n\nprivate static bool IsValidGate(Dictionary<string, List<Gate>> gates, Gate gate, string zMax)\n{\n    if (IsFullAdderStart(gate))\n    {\n        if (gates.TryGetValue(gate.Output, out var childGates))\n        {\n            if (gate.Operation == GateOperation.AND && childGates.Any(x => x.Operation == GateOperation.AND))\n                return false;\n            if (gate.Operation == GateOperation.XOR && childGates.Any(x => x.Operation == GateOperation.OR))\n                return false;\n        }\n    }\n\n    if (IsFullAdderEnd(gate, zMax) && gate.Operation != GateOperation.XOR)\n        return false;\n\n    if (IsAdderMiddle(gate) && gate.Operation == GateOperation.XOR)\n        return false;\n\n    return true;\n}\n\nprivate static bool IsAdderMiddle(Gate gate) => (!gate.A.StartsWith(['x', 'y']) && !gate.B.StartsWith(['x', 'y']) && !gate.Output.StartsWith('z'));\n\nprivate static bool IsFullAdderEnd(Gate gate, string bigEndianStart) => gate.Output.StartsWith('z') && gate.Output != bigEndianStart;\n\nprivate static bool IsFullAdderStart(Gate gate) => gate.A.StartsWith(['x', 'y']) && gate.B.StartsWith(['x', 'y']) && !gate.A.EndsWith(\"00\") && !gate.B.EndsWith(\"00\");\n\n"))))}var s=function(e){void 0===e&&(e={});const{wrapper:t}=Object.assign({},(0,a.RP)(),e.components);return t?r.createElement(t,e,r.createElement(i,e)):i(e)};var o=n(2779),l=n(7206),g=n(791),u=n(4813),c=n(572);const p={CodeBox:o.A};function d(e){let{pageContext:t,children:n}=e;return r.createElement(r.Fragment,null,r.createElement(u.A,null),r.createElement("div",{className:"min-h-screen bg-chicPrimary"},r.createElement(g.A,{props:t.list}),r.createElement("div",{className:"adventofcode max-w-[60%] ml-[20%]"},r.createElement("h1",null,r.createElement("a",{href:"https://adventofcode.com/"+t.year+"/day/"+t.puzz},t.year+" Day "+t.puzz+" - "+t.title)),r.createElement(a.xA,{components:p},n),t.puzz&&t.year?r.createElement(l.A,{year:t.year,puzz:t.puzz}):r.createElement(r.Fragment,null))),r.createElement(c.A,null))}function f(e){return r.createElement(d,e,r.createElement(s,e))}const m=()=>r.createElement(r.Fragment,null,r.createElement("title",null,"Joel-Allan-NZ - Advent of Code"),r.createElement("html",{lang:"en"}),r.createElement("link",{rel:"preconnect",href:"https://fonts.googleapis.com"}),r.createElement("link",{rel:"preconnect",href:"https://fonts.gstatic.com"}),r.createElement("link",{href:"https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&family=VT323&display=swap",rel:"stylesheet"}))}}]);
//# sourceMappingURL=component---src-components-layout-tsx-content-file-path-days-2024-24-mdx-17ddeab15c092abc37ad.js.map