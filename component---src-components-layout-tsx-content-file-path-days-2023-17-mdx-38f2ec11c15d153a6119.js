"use strict";(self.webpackChunkjoel_allan_nz_github_io=self.webpackChunkjoel_allan_nz_github_io||[]).push([[5577],{2148:function(n,e,t){t.r(e),t.d(e,{Head:function(){return f},default:function(){return p}});var i=t(8453),r=t(6540);function o(n){const e=Object.assign({h2:"h2",p:"p",a:"a",pre:"pre",code:"code",em:"em"},(0,i.RP)(),n.components),{CodeBox:t}=e;return t||function(n,e){throw new Error("Expected "+(e?"component":"object")+" `"+n+"` to be defined: you likely forgot to import, pass, or provide it.")}("CodeBox",!0),r.createElement(r.Fragment,null,r.createElement(e.h2,null,"Part One"),"\n",r.createElement(e.p,null,"An Advent of Code staple: path-finding algorithms with some extra rules."),"\n",r.createElement("br"),"\n",r.createElement(e.p,null,"This particular solution is essentially ",r.createElement(e.a,{href:"https://en.wikipedia.org/wiki/Iterative_deepening_depth-first_search"},"IDDFS"),",\nwalking down sets of next positions until all reachable positions have been discovered."),"\n",r.createElement("br"),"\n",r.createElement(t,{names:"typescript|C#"},r.createElement(e.pre,null,r.createElement(e.code,{className:"language-ts"},"export function partOne(input: string[]): number | string {\n  return findPaths(input, 0, 3)\n}\ninterface HeatNode {\n  x: number\n  y: number\n  value: number\n  from: number[]\n}\n\nfunction findPaths(\n  input: string[],\n  minSteps: number,\n  maxSteps: number\n): number {\n  const grid = heatGrid(input)\n  grid[0][0].from = [0, 0, 0, 0]\n  let future: { x: number; y: number; nextVertical: boolean }[] = []\n  getNextVertical(grid, grid[0][0], minSteps, maxSteps, future)\n  getNextHorizontal(grid, grid[0][0], minSteps, maxSteps, future)\n\n  while (future.length > 0) {\n    const next = future\n    future = []\n    for (let state of next) {\n      if (state.nextVertical)\n        getNextVertical(\n          grid,\n          grid[state.y][state.x],\n          minSteps,\n          maxSteps,\n          future\n        )\n      else\n        getNextHorizontal(\n          grid,\n          grid[state.y][state.x],\n          minSteps,\n          maxSteps,\n          future\n        )\n    }\n  }\n  var last = grid[grid.length - 1][grid[0].length - 1]\n  return Math.min(last.from[0], last.from[1], last.from[2], last.from[3])\n}\n\nfunction heatGrid(input: string[]): HeatNode[][] {\n  const grid: HeatNode[][] = []\n  const big = 2 ** 31\n  for (let y = 0; y < input.length; y++) {\n    grid.push([])\n    for (let x = 0; x < input[y].length; x++) {\n      grid[y].push({\n        x,\n        y,\n        value: parseInt(input[y][x]),\n        from: [big, big, big, big],\n      })\n    }\n  }\n  return grid\n}\n\nfunction getNextVertical(\n  grid: HeatNode[][],\n  origin: HeatNode,\n  minSteps: number,\n  maxSteps: number,\n  next: { x: number; y: number; nextVertical: boolean }[]\n): void {\n  let originDistance = Math.min(origin.from[1], origin.from[3])\n\n  for (let i = 1; i <= maxSteps; i++) {\n    if (origin.y - i < 0) break\n\n    let node = grid[origin.y - i][origin.x]\n    originDistance += node.value\n    if (i >= minSteps && node.from[2] > originDistance) {\n      next.push({ x: node.x, y: node.y, nextVertical: false })\n      node.from[2] = originDistance\n    }\n  }\n\n  originDistance = Math.min(origin.from[1], origin.from[3])\n\n  for (let i = 1; i <= maxSteps; i++) {\n    if (origin.y + i > grid.length - 1) break\n\n    let node = grid[origin.y + i][origin.x]\n    originDistance += node.value\n    if (i >= minSteps && node.from[0] > originDistance) {\n      next.push({ x: node.x, y: node.y, nextVertical: false })\n      node.from[0] = originDistance\n    }\n  }\n}\n\nfunction getNextHorizontal(\n  grid: HeatNode[][],\n  origin: HeatNode,\n  minSteps: number,\n  maxSteps: number,\n  next: { x: number; y: number; nextVertical: boolean }[]\n): void {\n  let originDistance = Math.min(origin.from[0], origin.from[2])\n  for (let i = 1; i <= maxSteps; i++) {\n    if (origin.x + 1 > grid[0].length - i) break\n\n    let node = grid[origin.y][origin.x + i]\n    originDistance += node.value\n    if (i >= minSteps && node.from[3] > originDistance) {\n      next.push({ x: node.x, y: node.y, nextVertical: true })\n      node.from[3] = originDistance\n    }\n  }\n  originDistance = Math.min(origin.from[0], origin.from[2])\n  for (let i = 1; i <= maxSteps; i++) {\n    if (origin.x - i < 0) break\n\n    let node = grid[origin.y][origin.x - i]\n    originDistance += node.value\n    if (i >= minSteps && node.from[1] > originDistance) {\n      next.push({ x: node.x, y: node.y, nextVertical: true })\n      node.from[1] = originDistance\n    }\n  }\n}\n")),r.createElement(e.pre,null,r.createElement(e.code,{className:"language-csharp"},"public override object PartOne()\n{\n    return FindPaths(Input, 0, 3);\n}\n\nprivate class HeatNode(int x, int y, int value)\n{\n    internal int X = x;\n    internal int Y = y;\n    internal int Value = value;\n    internal int[] From = [int.MaxValue, int.MaxValue, int.MaxValue, int.MaxValue];\n}\n\nprivate static HeatNode[][] HeatGrid(string[] input)\n{\n    HeatNode[][] grid = new HeatNode[input.Length][];\n    for (int y = 0; y < input.Length; y++)\n    {\n        grid[y] = new HeatNode[input[y].Length];\n        for (int x = 0; x < input[y].Length; x++)\n        {\n            grid[y][x] = new HeatNode(x, y, input[y][x] - '0');\n        }\n    }\n    return grid;\n}\n\nprivate static int FindPaths(string[] input, int minSteps = 0, int maxSteps = int.MaxValue)\n{\n    var grid = HeatGrid(input);\n    grid[0][0].From = [0, 0, 0, 0];\n    List<(HeatNode origin, bool nextVertical)> next = [];\n    GetNextVertical(grid, grid[0][0], minSteps, maxSteps, next);\n    GetNextHorizontal(grid, grid[0][0], minSteps, maxSteps, next);\n\n    while (next.Count > 0)\n    {\n        var future = new List<(HeatNode origin, bool vertical)>();\n\n        foreach (var (origin, nextVertical) in next)\n        {\n            if (nextVertical)\n                GetNextVertical(grid, origin, minSteps, maxSteps, future);\n            else\n                GetNextHorizontal(grid, origin, minSteps, maxSteps, future);\n        }\n        next = future;\n    }\n    return grid[^1][^1].From.Min();\n}\n\n\nprivate static void GetNextVertical(HeatNode[][] grid, HeatNode origin, int minSteps, int maxSteps, List<(HeatNode origin, bool nextVertical)> next)\n{\n    var originDistance = Math.Min(origin.From[1], origin.From[3]);\n\n    for (int i = 1; i <= maxSteps; i++)\n    {\n        if (origin.Y - i < 0)\n            break;\n\n        var node = grid[origin.Y - i][origin.X];\n        originDistance += node.Value;\n\n        if (i >= minSteps && node.From[2] > originDistance)\n        {\n            next.Add((node, false));\n            node.From[2] = originDistance;\n\n        }\n\n    }\n\n\n    originDistance = Math.Min(origin.From[1], origin.From[3]);\n    for (int i = 1; i <= maxSteps; i++)\n    {\n        if (origin.Y + i > grid.Length - 1)\n            break;\n\n        var node = grid[origin.Y + i][origin.X];\n        originDistance += node.Value;\n\n        if (i >= minSteps && node.From[0] > originDistance)\n        {\n            next.Add((node, false));\n            node.From[0] = originDistance;\n        }\n\n    }\n}\n\nprivate static void GetNextHorizontal(HeatNode[][] grid, HeatNode origin, int minSteps, int maxSteps, List<(HeatNode origin, bool nextVertical)> next)\n{\n    var originDistance = Math.Min(origin.From[0], origin.From[2]);\n    for (int i = 1; i <= maxSteps; i++)\n    {\n        if (origin.X + 1 > grid[0].Length - i)\n            break;\n\n        var node = grid[origin.Y][origin.X + i];\n        originDistance += node.Value;\n\n        if (i >= minSteps && node.From[3] > originDistance)\n        {\n            next.Add((node, true));\n            node.From[3] = originDistance;\n        }\n\n    }\n\n    originDistance = Math.Min(origin.From[0], origin.From[2]);\n    for (int i = 1; i <= maxSteps; i++)\n    {\n        if (origin.X - i < 0)\n            break;\n\n        var node = grid[origin.Y][origin.X - i];\n        originDistance += node.Value;\n        if (i >= minSteps && node.From[1] > originDistance)\n        {\n            next.Add((node, true));\n            node.From[1] = originDistance;\n        }\n    }\n}\n"))),"\n",r.createElement(e.h2,null,"Part Two"),"\n",r.createElement(e.p,null,"The same thing, but with slightly different numbers. It's actually ",r.createElement(e.em,null,"faster")," than part one, a real rarity for AoC!"),"\n",r.createElement(t,{names:"typescript|C#"},r.createElement(e.pre,null,r.createElement(e.code,{className:"language-ts"},"export function partTwo(input: string[]): number | string {\n  return findPaths(input, 4, 10)\n}\n")),r.createElement(e.pre,null,r.createElement(e.code,{className:"language-csharp"},"public override object PartTwo()\n{\n    return FindPaths(Input, 4, 10);\n}\n"))))}var a=function(n){void 0===n&&(n={});const{wrapper:e}=Object.assign({},(0,i.RP)(),n.components);return e?r.createElement(e,n,r.createElement(o,n)):o(n)};var l=t(2779),s=t(7206),g=t(791),m=t(4813),c=t(572);const d={CodeBox:l.A};function u(n){let{pageContext:e,children:t}=n;return r.createElement(r.Fragment,null,r.createElement(m.A,null),r.createElement("div",{className:"min-h-screen bg-chicPrimary"},r.createElement(g.A,{props:e.list}),r.createElement("div",{className:"adventofcode max-w-[60%] ml-[20%]"},r.createElement("h1",null,r.createElement("a",{href:"https://adventofcode.com/"+e.year+"/day/"+e.puzz},e.year+" Day "+e.puzz+" - "+e.title)),r.createElement(i.xA,{components:d},t),e.puzz&&e.year?r.createElement(s.A,{year:e.year,puzz:e.puzz}):r.createElement(r.Fragment,null))),r.createElement(c.A,null))}function p(n){return r.createElement(u,n,r.createElement(a,n))}const f=()=>r.createElement(r.Fragment,null,r.createElement("title",null,"Joel-Allan-NZ - Advent of Code"),r.createElement("html",{lang:"en"}),r.createElement("link",{rel:"preconnect",href:"https://fonts.googleapis.com"}),r.createElement("link",{rel:"preconnect",href:"https://fonts.gstatic.com"}),r.createElement("link",{href:"https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&family=VT323&display=swap",rel:"stylesheet"}))}}]);
//# sourceMappingURL=component---src-components-layout-tsx-content-file-path-days-2023-17-mdx-38f2ec11c15d153a6119.js.map