{"version":3,"file":"component---src-components-layout-tsx-content-file-path-days-2023-16-mdx-b735047ac7486a720bcb.js","mappings":"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","sources":["webpack://joel-allan-nz.github.io/./days/2023/16.mdx","webpack://joel-allan-nz.github.io/./src/components/Layout.tsx"],"sourcesContent":["/*@jsxRuntime classic @jsx React.createElement @jsxFrag React.Fragment*/\nimport {useMDXComponents as _provideComponents} from \"@mdx-js/react\";\nimport React from \"react\";\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    p: \"p\",\n    a: \"a\",\n    pre: \"pre\",\n    code: \"code\"\n  }, _provideComponents(), props.components), {CodeBox} = _components;\n  if (!CodeBox) _missingMdxReference(\"CodeBox\", true);\n  return React.createElement(React.Fragment, null, React.createElement(_components.h2, null, \"Part One\"), \"\\n\", React.createElement(_components.p, null, React.createElement(_components.a, {\n    href: \"https://en.wikipedia.org/wiki/Breadth-first_search\"\n  }, \"BFS\"), \" with some rules about how nodes are connected. \", React.createElement(\"br\"), \"\\nI opted not to manipulate the input to avoid complicating things - the BFS just walks along the cardinal directions, changing direction when required.\"), \"\\n\", React.createElement(CodeBox, {\n    names: \"typescript|C#\"\n  }, React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-ts\"\n  }, \"export function partOne(input: string[]): number | string {\\n  return countEnergizedTiles(0, 0, 1, input)\\n}\\n\\nfunction countEnergizedTiles(\\n  x: number,\\n  y: number,\\n  direction: number,\\n  input: string[]\\n): number {\\n  const energizedTiles = new Set<number>()\\n  const beamed = new Set<number>()\\n  const beams: number[][] = []\\n\\n  energizedTiles.add(x * input.length + 1 + y)\\n  beamed.add(x * input.length * 10 + y * 10 + direction)\\n  beams.push([x, y, direction])\\n\\n  while (beams.length > 0) {\\n    let beam = beams.pop()!\\n    for (let next of nextBeamState(beam, input)) {\\n      if (\\n        next[1] > -1 &&\\n        next[1] < input.length &&\\n        next[0] > -1 &&\\n        next[0] < input[next[1]].length\\n      ) {\\n        const beamedNumber =\\n          next[0] * input.length * 10 + next[1] * 10 + next[2]\\n        if (!beamed.has(beamedNumber)) {\\n          energizedTiles.add(next[0] * input.length + 1 + next[1])\\n          beams.push(next)\\n          beamed.add(beamedNumber)\\n        }\\n      }\\n    }\\n  }\\n  return energizedTiles.size\\n}\\n\\nfunction nextBeamPosition(beam: number[], direction: number) {\\n  return [\\n    beam[0] + (direction == 1 ? 1 : direction == 3 ? -1 : 0),\\n    beam[1] + (direction == 0 ? -1 : direction == 2 ? 1 : 0),\\n    direction,\\n  ]\\n}\\n\\nfunction nextBeamState(beam: number[], input: string[]): number[][] {\\n  const currentTile = input[beam[1]][beam[0]]\\n  let direction = beam[2]\\n\\n  if (currentTile == '|' && (direction == 1 || direction == 3)) {\\n    return [nextBeamPosition(beam, 2), nextBeamPosition(beam, 0)]\\n  } else if (currentTile == '-' && (direction == 0 || direction == 2)) {\\n    return [nextBeamPosition(beam, 1), nextBeamPosition(beam, 3)]\\n  } else if (currentTile == '/') {\\n    direction = direction % 2 == 0 ? (direction + 5) % 4 : (direction + 3) % 4\\n  } else if (currentTile == '\\\\\\\\') {\\n    direction = direction % 2 == 0 ? (direction + 3) % 4 : (direction + 5) % 4\\n  }\\n  return [nextBeamPosition(beam, direction)]\\n}\\n\")), React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-csharp\"\n  }, \"public override object PartOne()\\n{\\n    return CountEnergizedTiles(0, 0, 1, Input);\\n}\\n\\nprivate static int[][] NextBeamState(int[] beam, string[] input)\\n{\\n    char currentTile = input[beam[1]][beam[0]];\\n    var direction = beam[2];\\n\\n    if (currentTile == '|' && (direction == 1 || direction == 3))\\n    {\\n        return [NextBeamPosition(beam, 2), NextBeamPosition(beam, 0)];\\n    }\\n    else if (currentTile == '-' && (direction == 0 || direction == 2))\\n    {\\n        return [NextBeamPosition(beam, 1), NextBeamPosition(beam, 3)];\\n    }\\n    else if (currentTile == '/')\\n    {\\n        direction = direction % 2 == 0 ? (direction + 5) % 4 : (direction + 3) % 4;\\n    }\\n    else if (currentTile == '\\\\\\\\')\\n    {\\n        direction = direction % 2 == 0 ? (direction + 3) % 4 : (direction + 5) % 4;\\n    }\\n    return [NextBeamPosition(beam, direction)];\\n}\\n\\nprivate static int[] NextBeamPosition(int[] beam, int direction)\\n{\\n    return [beam[0] + (direction == 1 ? 1 : direction == 3 ? -1 : 0), beam[1] + (direction == 0 ? -1 : direction == 2 ? 1 : 0), direction];\\n}\\n\\nprivate static int CountEnergizedTiles(int x, int y, int direction, string[] input)\\n{\\n    HashSet<int> energizedTiles = [];\\n    HashSet<int> beamed = [];\\n    Stack<int[]> beams = [];\\n\\n    energizedTiles.Add(x * input.Length + 1 + y);\\n    beamed.Add(x * input.Length * 10 + y * 10 + direction);\\n    beams.Push([x, y, direction]);\\n\\n    while (beams.Count > 0)\\n    {\\n        var beam = beams.Pop();\\n        foreach (var next in NextBeamState(beam, input))\\n        {\\n            if (next[1] > -1 && next[1] < input.Length && next[0] > -1 && next[0] < input[next[1]].Length)\\n            {\\n                int beamedNumber = next[0] * input.Length * 10 + next[1] * 10 + next[2];\\n                if (!beamed.Contains(beamedNumber))\\n                {\\n                    energizedTiles.Add(next[0] * input.Length + 1 + next[1]);\\n                    beams.Push(next);\\n                    beamed.Add(beamedNumber);\\n                }\\n            }\\n        }\\n    }\\n    return energizedTiles.Count;\\n}\\n\"))), \"\\n\", React.createElement(_components.h2, null, \"Part Two\"), \"\\n\", React.createElement(_components.p, null, \"The same thing, but more :). I played around with a few optimization approaches with various takes on memoization, but the truth is that brute-forcing it works just as quickly for me, and without adding a lot of complexity to the code (memoization is a little tricky here: beams split, which adds complexity to cycles etc).\"), \"\\n\", React.createElement(CodeBox, {\n    names: \"typescript|C#\"\n  }, React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-ts\"\n  }, \"export function partTwo(input: string[]): number | string {\\n  let max = 0\\n\\n  for (let y = 0; y < input.length; y++) {\\n    let result = countEnergizedTiles(0, y, 1, input)\\n    if (result > max) max = result\\n    result = countEnergizedTiles(input[0].length - 1, y, 3, input)\\n    if (result > max) max = result\\n  }\\n  for (let x = 0; x < input.length; x++) {\\n    let result = countEnergizedTiles(x, 0, 2, input)\\n    if (result > max) max = result\\n    result = countEnergizedTiles(x, input.length - 1, 0, input)\\n    if (result > max) max = result\\n  }\\n\\n  return max\\n}\\n\")), React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-csharp\"\n  }, \"public override object PartTwo()\\n{\\n    int max = 0;\\n    for (int y = 0; y < Input.Length; y++)\\n    {\\n        var result = CountEnergizedTiles(0, y, 1, Input);\\n        if (result > max)\\n            max = result;\\n        result = CountEnergizedTiles(Input[0].Length - 1, y, 3, Input);\\n        if (result > max)\\n            max = result;\\n    }\\n    for (int x = 0; x < Input[0].Length; x++)\\n    {\\n        var result = CountEnergizedTiles(x, 0, 2, Input);\\n        if (result > max)\\n            max = result;\\n        result = CountEnergizedTiles(x, Input.Length - 1, 0, Input);\\n        if (result > max)\\n            max = result;\\n    }\\n    return max;\\n}\\n\"))));\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? React.createElement(MDXLayout, props, React.createElement(_createMdxContent, props)) : _createMdxContent(props);\n}\nexport default MDXContent;\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","import GATSBY_COMPILED_MDX from \"/home/joel/personal/advent-of-code/joel-allan-nz.github.io/days/2023/16.mdx\";\nimport React from 'react';\nimport {MDXProvider} from '@mdx-js/react';\nimport CodeBox from './CodeBox';\nimport TryYourself from './TryYourself';\nimport AdventSideNav from './AdventSideNav';\nimport Header from './Header';\nimport Footer from './Footer';\nconst shortcodes = {\n  CodeBox\n};\nfunction Layout(_ref) {\n  let {pageContext, children} = _ref;\n  return React.createElement(React.Fragment, null, React.createElement(Header, null), React.createElement(\"div\", {\n    className: \"min-h-screen bg-chicPrimary\"\n  }, React.createElement(AdventSideNav, {\n    props: pageContext.list\n  }), React.createElement(\"div\", {\n    className: \"adventofcode max-w-[60%] ml-[20%]\"\n  }, React.createElement(\"h1\", null, React.createElement(\"a\", {\n    href: \"https://adventofcode.com/\" + pageContext.year + \"/day/\" + pageContext.puzz\n  }, pageContext.year + \" Day \" + pageContext.puzz + \" - \" + pageContext.title)), React.createElement(MDXProvider, {\n    components: shortcodes\n  }, children), pageContext.puzz && pageContext.year ? React.createElement(TryYourself, {\n    year: pageContext.year,\n    puzz: pageContext.puzz\n  }) : React.createElement(React.Fragment, null))), React.createElement(Footer, null));\n}\nexport default function GatsbyMDXWrapper(props) {\n  return React.createElement(Layout, props, React.createElement(GATSBY_COMPILED_MDX, props));\n}\nexport const Head = () => React.createElement(React.Fragment, null, React.createElement(\"title\", null, \"Joel-Allan-NZ - Advent of Code\"), React.createElement(\"html\", {\n  lang: \"en\"\n}), React.createElement(\"link\", {\n  rel: \"preconnect\",\n  href: \"https://fonts.googleapis.com\"\n}), React.createElement(\"link\", {\n  rel: \"preconnect\",\n  href: \"https://fonts.gstatic.com\"\n}), React.createElement(\"link\", {\n  href: \"https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&family=VT323&display=swap\",\n  rel: \"stylesheet\"\n}));\n"],"names":["_createMdxContent","props","_components","Object","assign","h2","p","a","pre","code","_provideComponents","components","CodeBox","id","component","Error","_missingMdxReference","React","href","names","className","wrapper","MDXLayout","shortcodes","Layout","_ref","pageContext","children","Header","AdventSideNav","list","year","puzz","title","MDXProvider","TryYourself","Footer","GatsbyMDXWrapper","GATSBY_COMPILED_MDX","Head","lang","rel"],"sourceRoot":""}