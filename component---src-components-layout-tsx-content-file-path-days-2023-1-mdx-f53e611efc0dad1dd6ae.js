"use strict";(self.webpackChunkjoel_allan_nz_github_io=self.webpackChunkjoel_allan_nz_github_io||[]).push([[46],{197:function(e,n,t){t.r(n),t.d(n,{Head:function(){return f},default:function(){return m}});var i=t(8453),l=t(6540);function a(e){const n=Object.assign({h2:"h2",p:"p",pre:"pre",code:"code"},(0,i.RP)(),e.components),{CodeBox:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("CodeBox",!0),l.createElement(l.Fragment,null,l.createElement(n.h2,null,"Part One"),"\n",l.createElement(n.p,null,"A typical first puzzle of the year, just making sure we're capable of reading and parsing strings."),"\n",l.createElement(t,{names:"typescript|C#"},l.createElement(n.pre,null,l.createElement(n.code,{className:"language-js"},"export function partOne(input: string[]): number | string {\n  return input.reduce((total, line) => total + readCalibrationValue(line), 0)\n}\n\nfunction readCalibrationValue(line: string): number {\n  const digits = ['a', 'a']\n\n  line.split('').forEach((c) => {\n    if (!isNaN(parseInt(c))) {\n      if (digits[0] == 'a') digits[0] = c\n      digits[1] = c\n    }\n  })\n  return parseInt(digits.join(''))\n}\n")),l.createElement(n.pre,null,l.createElement(n.code,{className:"language-csharp"},"public override object PartOne()\n{\n    return Input.Sum(line => ReadCalibrationValue(line));\n}\n\nprivate static int ReadCalibrationValue(string line)\n{\n    char[] digits = ['a', 'a'];\n\n    foreach (char c in line)\n    {\n        if (char.IsDigit(c))\n        {\n            if (digits[0] == 'a')\n                digits[0] = c;\n            digits[1] = c;\n        }\n    }\n    return int.Parse(digits);\n}\n"))),"\n",l.createElement(n.h2,null,"Part Two"),"\n",l.createElement(n.p,null,"A slightly more complex problem with matching substrings, but still very simple stuff without a lot of discussion to be had."),"\n",l.createElement("br"),"\n",l.createElement(n.p,null,"The C# version is slightly wordier + performant compared to the Typescript version...\nit just felt 'right' to cut fewer corners in a statically typed language."),"\n",l.createElement(t,{names:"typescript|C#"},l.createElement(n.pre,null,l.createElement(n.code,{className:"language-ts"},"export function partTwo(input: string[]): number | string {\n  const spelled = [\n    'one',\n    'two',\n    'three',\n    'four',\n    'five',\n    'six',\n    'seven',\n    'eight',\n    'nine',\n  ]\n  return input.reduce(\n    (total, line) =>\n      total +\n      parseInt(readCalibrationWithSpelledValues(line, spelled).join('')),\n    0\n  )\n}\n\nfunction readCalibrationWithSpelledValues(\n  line: string,\n  spelled: string[]\n): string[] {\n  const digits: string[] = []\n\n  line.split('').forEach((c, index) => {\n    if (!isNaN(parseInt(c))) {\n      digits.push(c)\n    } else {\n      let value = spelled.find((x) => line.slice(index).startsWith(x))\n      if (value) {\n        value = (spelled.findIndex((v) => v == value) + 1).toString()\n        digits.push(value)\n      }\n    }\n  })\n  return [digits[0], digits.slice(-1)[0]]\n}\n")),l.createElement(n.pre,null,l.createElement(n.code,{className:"language-csharp"},'public override object PartTwo()\n{\n    List<string> spelled = [\n        "one",\n        "two",\n        "three",\n        "four",\n        "five",\n        "six",\n        "seven",\n        "eight",\n        "nine"\n    ];\n    return Input.Sum(line => ReadCalibrationValueWithSpelledValues(line, spelled));\n}\n\nprivate static int ReadCalibrationValueWithSpelledValues(string line, List<string> spelled)\n{\n    char[] digits = [\'a\', \'a\'];\n\n    for (int i = 0; i < line.Length; i++)\n    {\n        if (char.IsDigit(line[i]))\n        {\n            if (digits[0] == \'a\')\n                digits[0] = line[i];\n            digits[1] = line[i];\n        }\n        else if (HasSpelledValue(spelled, line[i..], out char value))\n        {\n            if (digits[0] == \'a\')\n                digits[0] = value;\n            digits[1] = value;\n        }\n    }\n    return int.Parse(digits);\n}\n\nprivate static bool HasSpelledValue(List<string> validSpelled, string subString, out char spelledValue)\n{\n    spelledValue = \'a\';\n\n    for (int i = 0; i < validSpelled.Count; i++)\n    {\n        if (subString.StartsWith(validSpelled[i]))\n        {\n            spelledValue = (i + 1).ToString()[0];\n            return true;\n        }\n    }\n    return false;\n}\n'))))}var r=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,i.RP)(),e.components);return n?l.createElement(n,e,l.createElement(a,e)):a(e)};var s=t(2779),c=t(7206),o=t(791),u=t(4813),p=t(572);const d={CodeBox:s.A};function g(e){let{pageContext:n,children:t}=e;return l.createElement(l.Fragment,null,l.createElement(u.A,null),l.createElement("div",{className:"min-h-screen bg-chicPrimary"},l.createElement(o.A,{props:n.list}),l.createElement("div",{className:"adventofcode max-w-[60%] ml-[20%]"},l.createElement("h1",null,l.createElement("a",{href:"https://adventofcode.com/"+n.year+"/day/"+n.puzz},n.year+" Day "+n.puzz+" - "+n.title)),l.createElement(i.xA,{components:d},t),n.puzz&&n.year?l.createElement(c.A,{year:n.year,puzz:n.puzz}):l.createElement(l.Fragment,null))),l.createElement(p.A,null))}function m(e){return l.createElement(g,e,l.createElement(r,e))}const f=()=>l.createElement(l.Fragment,null,l.createElement("title",null,"Joel-Allan-NZ - Advent of Code"),l.createElement("html",{lang:"en"}),l.createElement("link",{rel:"preconnect",href:"https://fonts.googleapis.com"}),l.createElement("link",{rel:"preconnect",href:"https://fonts.gstatic.com"}),l.createElement("link",{href:"https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&family=VT323&display=swap",rel:"stylesheet"}))}}]);
//# sourceMappingURL=component---src-components-layout-tsx-content-file-path-days-2023-1-mdx-f53e611efc0dad1dd6ae.js.map