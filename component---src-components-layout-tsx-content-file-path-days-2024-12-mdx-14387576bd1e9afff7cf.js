"use strict";(self.webpackChunkjoel_allan_nz_github_io=self.webpackChunkjoel_allan_nz_github_io||[]).push([[9913],{638:function(e,n,t){t.r(n),t.d(n,{Head:function(){return m},default:function(){return p}});var r=t(8453),o=t(6540);function i(e){const n=Object.assign({h2:"h2",p:"p",ol:"ol",li:"li",pre:"pre",code:"code",ul:"ul",strong:"strong",em:"em"},(0,r.RP)(),e.components),{CodeBox:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("CodeBox",!0),o.createElement(o.Fragment,null,o.createElement(n.h2,null,"Part One"),"\n",o.createElement(n.p,null,"The first part was pretty straight-forward:"),"\n",o.createElement(n.ol,null,"\n",o.createElement(n.li,null,"Read the input and divide it up into the various garden regions."),"\n",o.createElement(n.li,null,"Count the total perimeter of each region (in my case by counting the number of sides without a neighbour for every node in the region), and multiply it by the area of the region (the number of elements within that region)"),"\n"),"\n",o.createElement(n.p,null,"Almost all of the code is just to read and model that data"),"\n",o.createElement(t,{boxname:"one",names:"typescript|C#"},o.createElement(n.pre,null,o.createElement(n.code,{className:"language-js"},"export function partOne(input: string[]): number | string {\n  var regions = parse(input)\n  return regions\n    .values()\n    .reduce(\n      (total, current) =>\n        total +\n        current.length * current.reduce((t, c) => t + 4 - c.Edges.length, 0),\n      0\n    )\n}\n\ninterface Node {\n  X: number\n  Y: number\n  C: string\n  Region: number\n  Edges: Node[]\n}\n\nfunction parse(input: string[]): Map<number, Node[]> {\n  const nodes: Node[] = []\n  let lastRow: Node[] = []\n  input.forEach((line, y) => {\n    const currentRow: Node[] = []\n    line.split('').forEach((c, x) => {\n      currentRow.push({ X: x, Y: y, C: c, Region: 0, Edges: [] })\n      nodes.push(currentRow[x])\n      if (x > 0 && currentRow[x - 1].C == c) {\n        currentRow[x - 1].Edges.push(currentRow[x])\n        currentRow[x].Edges.push(currentRow[x - 1])\n      }\n      if (y > 0 && lastRow[x].C == c) {\n        currentRow[x].Edges.push(lastRow[x])\n        lastRow[x].Edges.push(currentRow[x])\n      }\n    })\n    lastRow = currentRow\n  })\n\n  let region = 1\n  nodes.forEach((node) => {\n    if (node.Region == 0) {\n      node.Region = region\n      region++\n      findRegion(node)\n    }\n  })\n  return Map.groupBy(nodes, (node) => node.Region)\n}\n\nfunction findRegion(node: Node) {\n  node.Edges.forEach((neighbour) => {\n    if (neighbour.Region == 0) {\n      neighbour.Region = node.Region\n      findRegion(neighbour)\n    }\n  })\n}\n")),o.createElement(n.pre,null,o.createElement(n.code,{className:"language-csharp"},"public override object PartOne()\n{\n    var regions = Parse();\n\n    return regions.Values.Sum(region => region.Count * region.Sum(FindTotalPerimeter()));\n\n    static Func<NodeData, int> FindTotalPerimeter() => y => 4 - y.Edges.Count;\n}\n\ninternal class NodeData(int x, int y, char c, int region)\n{\n    internal int X = x;\n    internal int Y = y;\n    internal char C = c;\n    internal int Region = region;\n    internal List<NodeData> Edges = [];\n}\n\nprivate Dictionary<int, List<NodeData>> Parse()\n{\n    Dictionary<(int x, int y), NodeData> graph = [];\n    for (int y = 0; y < Input.Length; y++)\n    {\n        for (int x = 0; x < Input.Length; x++)\n        {\n            NodeData n = new(x, y, Input[y][x], 0);\n            if (graph.TryGetValue((x - 1, y), out var left) && left.C == n.C)\n            {\n                left.Edges.Add(n);\n                n.Edges.Add(left);\n            }\n            if (graph.TryGetValue((x, y - 1), out var up) && up.C == n.C)\n            {\n                up.Edges.Add(n);\n                n.Edges.Add(up);\n            }\n            graph.Add((x, y), n);\n        }\n    }\n\n    int region = 1;\n    foreach (var node in graph.Values)\n    {\n        if (node.Region == 0)\n        {\n            node.Region = region;\n            region++;\n            FindRegion(node);\n        }\n    }\n    return graph.Values.GroupBy(x => x.Region).ToDictionary(key => key.Key, value => value.ToList());\n}\n\nprivate static void FindRegion(NodeData node)\n{\n    foreach (var neighbour in node.Edges)\n    {\n        if (neighbour.Region == 0)\n        {\n            neighbour.Region = node.Region;\n            FindRegion(neighbour);\n        }\n    }\n}\n"))),"\n",o.createElement(n.h2,null,"Part Two"),"\n",o.createElement(n.p,null,"This one took a little more thinking."),"\n",o.createElement("br"),"\n",o.createElement(n.p,null,"My approach is based on counting the number of vertices a region has - a polygon\nhas the same number of sides as vertices, and it seemed more straight-forward."),"\n",o.createElement("br"),"\n",o.createElement(n.p,null,"The algorithm works by counting the corners on each node in a region as such:"),"\n",o.createElement(n.ul,null,"\n",o.createElement(n.li,null,"\n",o.createElement(n.p,null,"If the node has 0 edges, it has 4 corners (ie it's a single node region). 4 corners = 4 sides."),"\n"),"\n",o.createElement(n.li,null,"\n",o.createElement(n.p,null,"If the node has 1 edge, it has two corners. This can be a little tricky to visualize, but consider a chunky ",o.createElement(n.strong,null,"T"),". It has 3 pairs of 2 corners, and a 1 edge node looks much the same."),"\n"),"\n",o.createElement(n.li,null,"\n",o.createElement(n.p,null,"If it has 2 or more edges, it can represent an internal corner (think ",o.createElement(n.strong,null,"E"),"; there are internal corners on each tine), or a 90 degree angle external corner (or even both)."),"\n",o.createElement("ul",null,o.createElement("li",null,o.createElement(n.p,null,"We can check if it's an external corner by seeing if it has two direct\nneighbours in either the horizontal or vertical planes. If it has them, we\ncan confirm it's not that kind of corner.")),o.createElement("li",null,o.createElement(n.p,null,"The internal corner is slightly trickier - we check if any two of its\nneighbours also ",o.createElement(n.em,null,"share")," a neighbour with each other. Consider a 2x2 square\n- for any given node each pair of neighbours also shares another\nneighbour that the original node doesn't have; it's in a diagonal position\nto the original node. If that diagonal node doesn't exist in the region,\nit's an internal corner."))),"\n"),"\n",o.createElement(n.li,null,"\n",o.createElement(n.p,null,"Count 'em up, and multiply by the number of values in that region, and you have your region fence price."),"\n",o.createElement("br"),"\n",o.createElement(n.p,null,"It's not a terribly elegant approach, but it does the job very well."),"\n"),"\n"),"\n",o.createElement(t,{boxname:"two",names:"typescript|C#"},o.createElement(n.pre,null,o.createElement(n.code,{className:"language-js"},"export function partTwo(input: string[]): number | string {\n  var regions = parse(input)\n\n  return regions.values().reduce((total, region) => {\n    return (\n      total +\n      region.reduce((t, node) => t + region.length * countNodeVertices(node), 0)\n    )\n  }, 0)\n}\n\nfunction countNodeVertices(node: Node): number {\n  if (node.Edges.length == 0) return 4\n  if (node.Edges.length == 1) return 2\n\n  const edgeCombinations = node.Edges.slice(0, -1).flatMap((edge, index) => {\n    return node.Edges.slice(index + 1).map((e) => [edge, e])\n  })\n\n  let outsideCorner = true\n  const pairSum = edgeCombinations.reduce((total, pair) => {\n    if (\n      (pair[0].X == pair[1].X && pair[1].X == node.X) ||\n      (pair[0].Y == pair[1].Y && pair[1].Y == node.Y)\n    )\n      outsideCorner = false\n    else {\n      let insideCorner =\n        pair[0].Edges.filter((e) => pair[1].Edges.includes(e)).length == 1\n      if (insideCorner) return total + 1\n    }\n    return total\n  }, 0)\n  return outsideCorner ? pairSum + 1 : pairSum\n}\n")),o.createElement(n.pre,null,o.createElement(n.code,{className:"language-csharp"},"public override object PartTwo()\n{\n    var regions = Parse();\n\n    return regions.Values.Sum(region => FindRegionCost(region));\n\n    static int FindRegionCost(List<NodeData> region)\n    {\n        return region.Sum(node => CountNodeVertices(node)) * region.Count;\n    }\n}\n\nprivate static int CountNodeVertices(NodeData node)\n{\n    if (node.Edges.Count == 0)\n        return 4;\n\n    if (node.Edges.Count == 1)\n        return 2;\n\n    var pairCombinations = node.Edges.UniquePairs();\n    // if the node is within a straight section of nodes, then it can't be an outside corner.\n    bool outsideCorner = true;\n    var pairSum = pairCombinations.Sum(pair =>\n    {\n        if (IsStraightLine(node, pair))\n            outsideCorner = false;\n        else\n        {\n            bool insideCorner = pair[0].Edges.Intersect(pair[1].Edges).Count() == 1;\n            if (insideCorner)\n                return 1;\n        }\n        return 0;\n\n        static bool IsStraightLine(NodeData node, NodeData[] pair)\n        {\n            return (pair[0].X == pair[1].X && pair[0].X == node.X) ||\n            (pair[0].Y == pair[1].Y && pair[0].Y == node.Y);\n        }\n    });\n\n    return outsideCorner ? pairSum + 1 : pairSum;\n}\n"))))}var a=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,r.RP)(),e.components);return n?o.createElement(n,e,o.createElement(i,e)):i(e)};var l=t(2779),s=t(7206),u=t(791),c=t(4813),d=t(572);const g={CodeBox:l.A};function h(e){let{pageContext:n,children:t}=e;return o.createElement(o.Fragment,null,o.createElement(c.A,null),o.createElement("div",{className:"min-h-screen bg-chicPrimary"},o.createElement(u.A,{props:n.list}),o.createElement("div",{className:"adventofcode max-w-[60%] ml-[20%]"},o.createElement("h1",null,o.createElement("a",{href:"https://adventofcode.com/"+n.year+"/day/"+n.puzz},n.year+" Day "+n.puzz+" - "+n.title)),o.createElement(r.xA,{components:g},t),n.puzz&&n.year?o.createElement(s.A,{year:n.year,puzz:n.puzz}):o.createElement(o.Fragment,null))),o.createElement(d.A,null))}function p(e){return o.createElement(h,e,o.createElement(a,e))}const m=()=>o.createElement(o.Fragment,null,o.createElement("title",null,"Joel-Allan-NZ - Advent of Code"),o.createElement("html",{lang:"en"}),o.createElement("link",{rel:"preconnect",href:"https://fonts.googleapis.com"}),o.createElement("link",{rel:"preconnect",href:"https://fonts.gstatic.com"}),o.createElement("link",{href:"https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&family=VT323&display=swap",rel:"stylesheet"}))}}]);
//# sourceMappingURL=component---src-components-layout-tsx-content-file-path-days-2024-12-mdx-14387576bd1e9afff7cf.js.map