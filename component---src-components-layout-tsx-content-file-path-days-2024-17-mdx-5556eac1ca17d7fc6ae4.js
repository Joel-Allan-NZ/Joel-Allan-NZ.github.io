"use strict";(self.webpackChunkjoel_allan_nz_github_io=self.webpackChunkjoel_allan_nz_github_io||[]).push([[6768],{7428:function(n,t,e){e.r(t),e.d(t,{Head:function(){return b},default:function(){return h}});var o=e(8453),r=e(6540);function a(n){const t=Object.assign({h2:"h2",p:"p",pre:"pre",code:"code"},(0,o.RP)(),n.components),{CodeBox:e}=t;return e||function(n,t){throw new Error("Expected "+(t?"component":"object")+" `"+n+"` to be defined: you likely forgot to import, pass, or provide it.")}("CodeBox",!0),r.createElement(r.Fragment,null,r.createElement(t.h2,null,"Part One"),"\n",r.createElement(t.p,null,"Modelling a not-quite-assembly-but-inspired-by-it program is an absolute Advent of Code classic."),"\n",r.createElement("br"),"\n",r.createElement(t.p,null,"This first part is entirely straightforward, with no real wrinkles : implement 8\ninstructions, handle the funky op-code reading, and run the instructions until the\nprogram halts."),"\n",r.createElement(e,{boxname:"one",names:"typescript|C#"},r.createElement(t.pre,null,r.createElement(t.code,{className:"language-js"},"export function partOne(input: string[]): number | string {\n  const { state, instructions } = parse(input)\n\n  while (\n    state.instructionPointer > -1 &&\n    state.instructionPointer < instructions.length - 1\n  )\n    operation(\n      instructions[state.instructionPointer],\n      instructions[state.instructionPointer + 1],\n      state\n    )\n\n  return state.output\n}\n\ninterface State {\n  A: number\n  B: number\n  C: number\n  output: string\n  instructionPointer: number\n}\n\nfunction parse(input: string[]): { state: State; instructions: number[] } {\n  const state: State = { A: 0, B: 0, C: 0, output: '', instructionPointer: 0 }\n  state.A = parseInt(input[0].match(/(\\d+)/)![0])\n  state.B = parseInt(input[1].match(/(\\d+)/)![0])\n  state.C = parseInt(input[2].match(/(\\d+)/)![0])\n\n  const instructions = input[4]\n    .split(/[\\, ]/)\n    .slice(1)\n    .map((x) => parseInt(x))\n  return { state, instructions }\n}\n\nfunction operation(opCode: number, operand: number, state: State) {\n  switch (opCode) {\n    case 0:\n      adv(comboOperand(operand, state), state)\n      break\n    case 1:\n      bxl(operand, state)\n      break\n    case 2:\n      bst(comboOperand(operand, state), state)\n      break\n    case 3:\n      jnz(operand, state)\n      break\n    case 4:\n      bxc(state)\n      break\n    case 5:\n      out(comboOperand(operand, state), state)\n      break\n    case 6:\n      bdv(comboOperand(operand, state), state)\n      break\n    case 7:\n      cdv(comboOperand(operand, state), state)\n  }\n  if (opCode != 3) state.instructionPointer += 2\n}\n\nfunction comboOperand(operand: number, state: State): number {\n  switch (operand) {\n    case 4:\n      return state.A\n    case 5:\n      return state.B\n    case 6:\n      return state.C\n    default:\n      return operand\n  }\n}\n\nfunction adv(comboOperand: number, state: State) {\n  state.A = Math.floor(state.A / 2 ** comboOperand)\n}\nfunction bdv(comboOperand: number, state: State) {\n  state.B = Math.floor(state.A / 2 ** comboOperand)\n}\nfunction cdv(comboOperand: number, state: State) {\n  state.C = Math.floor(state.A / 2 ** comboOperand)\n}\nfunction bxl(operand: number, state: State) {\n  state.B ^= operand\n}\nfunction bst(comboOperand: number, state: State) {\n  state.B = comboOperand % 8\n}\nfunction jnz(operand: number, state: State) {\n  state.instructionPointer =\n    state.A == 0 ? state.instructionPointer + 2 : operand\n}\nfunction bxc(state: State) {\n  state.B ^= state.C\n}\nfunction out(comboOperand: number, state: State) {\n  state.output =\n    state.output.length > 0\n      ? `${state.output},${((comboOperand % 8) + 8) % 8}`\n      : `${((comboOperand % 8) + 8) % 8}`\n}\n")),r.createElement(t.pre,null,r.createElement(t.code,{className:"language-csharp"},'long A = 0;\nlong B = 0;\nlong C = 0;\nstring output = "";\n\npublic override object PartOne()\n{\n    var instructions = Parse();\n    int instructionPointer = 0;\n    while (instructionPointer >= 0 && instructionPointer < instructions.Count - 1)\n    {\n        Operation(instructions[instructionPointer], instructions[instructionPointer + 1], ref instructionPointer);\n    }\n    return output;\n}\n\nprivate void Operation(int opCode, int operand, ref int instructionPointer) => instructionPointer = opCode switch\n{\n    0 => Adv(ComboOperand(operand), instructionPointer),\n    1 => Bxl(operand, instructionPointer),\n    2 => Bst(ComboOperand(operand), instructionPointer),\n    3 => Jnz(operand, instructionPointer),\n    4 => Bxc(instructionPointer),\n    5 => Out(ComboOperand(operand), instructionPointer),\n    6 => Bdv(ComboOperand(operand), instructionPointer),\n    7 => Cdv(ComboOperand(operand), instructionPointer),\n    _ => throw new ArgumentException($"{opCode} isn\'t a valid opcode")\n};\n\nprivate long ComboOperand(int operand) => operand switch\n{\n    4 => A,\n    5 => B,\n    6 => C,\n    _ => operand,\n};\n\nprivate List<int> Parse()\n{\n    A = long.Parse(Regex.Match(Input[0], @"[\\d]+").Value);\n    B = int.Parse(Regex.Match(Input[1], @"[\\d]+").Value);\n    C = int.Parse(Regex.Match(Input[2], @"[\\d]+").Value);\n\n    return Input[4].Split([\',\', \' \'])\n                   .Skip(1)\n                   .Select(x => int.Parse(x))\n                   .ToList();\n}\n\nprivate int Adv(long comboOperand, int instructionPointer)\n{\n    A = (long)Math.Floor(A / Math.Pow(2, comboOperand));\n    return instructionPointer + 2;\n}\n\nprivate int Bdv(long comboOperand, int instructionPointer)\n{\n    B = (long)Math.Floor(A / Math.Pow(2, comboOperand));\n    return instructionPointer + 2;\n}\n\nprivate int Cdv(long comboOperand, int instructionPointer)\n{\n    C = (long)Math.Floor(A / Math.Pow(2, comboOperand));\n    return instructionPointer + 2;\n}\n\nprivate int Bxl(int operand, int instructionPointer)\n{\n    B ^= operand;\n    return instructionPointer + 2;\n}\n\nprivate int Bst(long comboOperand, int instructionPointer)\n{\n    B = comboOperand % 8;\n    return instructionPointer + 2;\n}\n\nprivate int Jnz(int operand, int instructionPointer)\n{\n    if (A == 0)\n        return instructionPointer + 2;\n\n    return operand;\n}\n\nprivate int Bxc(int instructionPointer)\n{\n    B ^= C;\n    return instructionPointer + 2;\n}\n\nprivate int Out(long comboOperand, int instructionPointer)\n{\n    output = output.Length > 0 ? $"{output},{comboOperand % 8}" : $"{comboOperand % 8}";\n    return instructionPointer + 2;\n}\n'))),"\n",r.createElement(t.h2,null,"Part Two"),"\n",r.createElement(t.p,null,"A tradition for these pretend code problems, is for part 2 to be about peering through the problem statement and understanding the actual mechanics of the 'program' that's running. Be your own decompiler. My solution may not give accurate results for you, depending on if all inputs are ultimately \"the same type of program\" or not."),"\n",r.createElement("br"),"\n",r.createElement(t.p,null,"Personally, I dread these ones; some people love 'em, but it's not my cup of tea."),"\n",r.createElement("br"),"\n",r.createElement(t.p,null,"With the knowledge that the ",r.createElement(t.code,null,"out")," instruction has a modulo 8, we know that output\nvalues are always in the range 0-7; a 3-bit number. That 3-bit concept comes up in\nthe actual problem description, so it doesn't take a huge deductive leap to guess\nthat we can handle this problem 3 bits at a time. Some quick checks of possible start\nvalues and their results seemed to confirm that possibility, so that's the direction\nI persued."),"\n",r.createElement("br"),"\n",r.createElement(t.p,null,"My solution looks for solutions to each output/instruction digit one at a time, from\nleast-to-most significant. I start by checking all 3-bit start values that could\nreturn an output equal to my last input value (in my case, ",r.createElement(t.code,null,"0"),"). I take each of these\ncandidate solution values, shift them left by three bits, and then check the shifted\nvalue + all 3 bit numbers checking for solutions that also include the next most\nsignificant output value. These new candidate solutions are shifted to the left again,\nand the process continues until all output digits are accounted for."),"\n",r.createElement("br"),"\n",r.createElement(t.p,null,"There's very likely a better/faster solution for my specific input (just completely\nunderstand and reverse the process!), but I'm hoping this approach functions as a\nlittle bit more of a general case."),"\n",r.createElement(e,{boxname:"two",names:"typescript|C#"},r.createElement(t.pre,null,r.createElement(t.code,{className:"language-js"},"export function partTwo(input: string[]): number | string {\n  const { state, instructions } = parse(input)\n  let candidates = new Set<number>([0])\n\n  for (let i = 1; i <= instructions.length; i++) {\n    let nextCandidates = new Set<number>()\n    candidates.forEach((candidate) => {\n      nextCandidates = nextCandidates.union(\n        findNextCandidates(candidate, i, state, instructions)\n      )\n    })\n    candidates = nextCandidates\n  }\n  return candidates\n    .values()\n    .toArray()\n    .reduce((total, x) => (total < x ? total : x), 2 ** 63)\n}\n\nfunction findNextCandidates(\n  start: number,\n  position: number,\n  state: State,\n  instructions: number[]\n): Set<number> {\n  const candidates = new Set<number>()\n  for (let offset = 0; offset < 8; offset++) {\n    state.output = ''\n    state.instructionPointer = 0\n    state.A = start + offset\n\n    while (\n      state.instructionPointer > -1 &&\n      state.instructionPointer < instructions.length - 1\n    ) {\n      operation(\n        instructions[state.instructionPointer],\n        instructions[state.instructionPointer + 1],\n        state\n      )\n    }\n\n    let numberOut = state.output.split(/,/).map((x) => parseInt(x))\n    if (\n      position > 0 &&\n      numberOut[numberOut.length - position] ==\n        instructions[instructions.length - position]\n    ) {\n      candidates.add(\n        position < instructions.length ? (start + offset) * 8 : start + offset\n      )\n    }\n  }\n  return candidates\n}\n")),r.createElement(t.pre,null,r.createElement(t.code,{className:"language-csharp"},"public override object PartTwo()\n{\n    var instructions = Parse();\n    HashSet<long> candidates = [];\n    candidates.Add(0);\n\n    for (int i = 1; i <= instructions.Count; i++)\n    {\n        HashSet<long> nextCandidates = [];\n        foreach (var candidate in candidates)\n            nextCandidates.UnionWith(FindNextCandidates(candidate, i, instructions));\n\n        candidates = nextCandidates;\n    }\n    return candidates.Min();\n}\n\n\nprivate HashSet<long> FindNextCandidates(long start, int position, List<int> instructions)\n{\n    HashSet<long> candidates = [];\n    for (int offset = 0; offset < 8; offset++)\n    {\n        output = \"\";\n        int instructionPointer = 0;\n        A = start + offset;\n        while (instructionPointer >= 0 && instructionPointer < instructions.Count - 1)\n        {\n            Operation(instructions[instructionPointer], instructions[instructionPointer + 1], ref instructionPointer);\n        }\n\n        var numericOutput = output.Split(',').Select(x => int.Parse(x)).ToArray();\n\n        if (numericOutput[^position] == instructions[^position])\n            candidates.Add(position < instructions.Count ? (start + offset) << 3 : (start + offset));\n    }\n    return candidates;\n}\n"))))}var i=function(n){void 0===n&&(n={});const{wrapper:t}=Object.assign({},(0,o.RP)(),n.components);return t?r.createElement(t,n,r.createElement(a,n)):a(n)};var s=e(2779),c=e(7206),u=e(791),l=e(4813),p=e(572);const d={CodeBox:s.A};function m(n){let{pageContext:t,children:e}=n;return r.createElement(r.Fragment,null,r.createElement(l.A,null),r.createElement("div",{className:"min-h-screen bg-chicPrimary"},r.createElement(u.A,{props:t.list}),r.createElement("div",{className:"adventofcode max-w-[60%] ml-[20%]"},r.createElement("h1",null,r.createElement("a",{href:"https://adventofcode.com/"+t.year+"/day/"+t.puzz},t.year+" Day "+t.puzz+" - "+t.title)),r.createElement(o.xA,{components:d},e),t.puzz&&t.year?r.createElement(c.A,{year:t.year,puzz:t.puzz}):r.createElement(r.Fragment,null))),r.createElement(p.A,null))}function h(n){return r.createElement(m,n,r.createElement(i,n))}const b=()=>r.createElement(r.Fragment,null,r.createElement("title",null,"Joel-Allan-NZ - Advent of Code"),r.createElement("html",{lang:"en"}),r.createElement("link",{rel:"preconnect",href:"https://fonts.googleapis.com"}),r.createElement("link",{rel:"preconnect",href:"https://fonts.gstatic.com"}),r.createElement("link",{href:"https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&family=VT323&display=swap",rel:"stylesheet"}))}}]);
//# sourceMappingURL=component---src-components-layout-tsx-content-file-path-days-2024-17-mdx-5556eac1ca17d7fc6ae4.js.map