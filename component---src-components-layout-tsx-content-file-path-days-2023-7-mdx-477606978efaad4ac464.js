"use strict";(self.webpackChunkjoel_allan_nz_github_io=self.webpackChunkjoel_allan_nz_github_io||[]).push([[2924],{6030:function(n,e,t){t.r(e),t.d(e,{Head:function(){return y},default:function(){return h}});var a=t(8453),r=t(6540);function o(n){const e=Object.assign({h2:"h2",p:"p",pre:"pre",code:"code"},(0,a.RP)(),n.components),{CodeBox:t}=e;return t||function(n,e){throw new Error("Expected "+(e?"component":"object")+" `"+n+"` to be defined: you likely forgot to import, pass, or provide it.")}("CodeBox",!0),r.createElement(r.Fragment,null,r.createElement(e.h2,null,"Part One"),"\n",r.createElement(e.p,null,"Cards Time."),"\n",r.createElement("br"),"\n",r.createElement(e.p,null,"We need to be able to identify hand values, and also compare hands of the same type.\nNot too much to think about here, just diligence in making sure we evaluate hands\ncorrectly."),"\n",r.createElement(e.p,null,"I opted to compute the hand values before sorting to avoid recalculating each hand value when compared. There's some bleed over from part 2 in this solution, but it didn't make sense to duplicate the entirety of the process."),"\n",r.createElement(t,{names:"typescript|C#"},r.createElement(e.pre,null,r.createElement(e.code,{className:"language-js"},"export function partOne(input: string[]): number | string {\n  const hands = input.map((x) => {\n    let matches = x.split(' ')\n    return {\n      cards: matches[0],\n      handValue: findHandType(matches[0], false),\n      bid: parseInt(matches[1]),\n    }\n  })\n  console.log(hands)\n  hands.sort((x, y) => compareHandValue(x, y, false))\n  return hands.reduce((total, hand, index) => hand.bid * (index + 1) + total, 0)\n}\n\ninterface CamelCardHand {\n  cards: string\n  handValue: number\n  bid: number\n}\n\nfunction compareHandValue(\n  x: CamelCardHand,\n  y: CamelCardHand,\n  joker: boolean\n): number {\n  if (x.handValue != y.handValue) return x.handValue - y.handValue\n\n  for (let i = 0; i < x.cards.length; i++) {\n    if (x.cards[i] != y.cards[i])\n      return cardValue(x.cards[i], joker) - cardValue(y.cards[i], joker)\n  }\n  return 0\n}\n\nfunction cardValue(card: string, joker: boolean): number {\n  switch (card) {\n    case 'A':\n      return 14\n    case 'K':\n      return 13\n    case 'Q':\n      return 12\n    case 'J':\n      return joker ? 0 : 11\n    case 'T':\n      return 10\n    default:\n      return parseInt(card)\n  }\n}\n\nfunction findHandType(hand: string, joker: boolean): number {\n  const counted = new Map<string, number>()\n  let max = 1\n  hand.split('').forEach((c) => {\n    let d = counted.get(c)\n    if (d) {\n      counted.set(c, d + 1)\n      max = d + 1 > max ? d + 1 : max\n    } else counted.set(c, 1)\n  })\n\n  if (joker && counted.get('J'))\n    return findHandTypeJoker(counted.size, max, counted.get('J')!)\n\n  switch (counted.size) {\n    case 1:\n      return 7\n    case 2:\n      return counted.values().find((x) => x == 2 || x == 3) ? 5 : 6\n    case 3:\n      return max == 3 ? 4 : 3\n    case 4:\n      return 2\n    default:\n      return 1\n  }\n}\n")),r.createElement(e.pre,null,r.createElement(e.code,{className:"language-csharp"},"public override object PartOne()\n{\n    var comparer = new CamelHandComparer();\n    List<(string hand, int bid, HandType handType)> hands = [.. Input.Select(x => x.Split(' ', StringSplitOptions.RemoveEmptyEntries))\n                                                                     .Select(x => (hand: x[0], bid: int.Parse(x[1]), handType: FindHandType(x[0])))\n                                                                     .Order(comparer)];\n    long sum = 0;\n    for (int i = 0; i < hands.Count; i++)\n        sum += (i + 1) * hands[i].bid;\n\n    return sum;\n}\n\npublic static HandType FindHandType(string a, bool joker = false)\n{\n    var counted = new Dictionary<char, int>();\n    foreach (char ch in a)\n    {\n        if (counted.TryGetValue(ch, out var value))\n            counted[ch] = value + 1;\n        else\n            counted.Add(ch, 1);\n    }\n\n    if (joker && counted.TryGetValue('J', out var jokers))\n        return FindHandTypeJoker(counted.Keys.Count, counted.Values.Max(), jokers);\n\n    return counted.Keys.Count switch\n    {\n        1 => HandType.FiveOfAKind,\n        2 => counted.First().Value == 2 || counted.First().Value == 3 ? HandType.FullHouse : HandType.FourOfAKind,\n        3 => counted.Values.Max() == 3 ? HandType.ThreeOfAKind : HandType.TwoPair,\n        4 => HandType.OnePair,\n        _ => HandType.HighCard\n    };\n}\n\ninternal enum HandType\n{\n    FiveOfAKind, FourOfAKind, FullHouse, ThreeOfAKind, TwoPair, OnePair, HighCard\n}\n\ninternal class CamelHandComparer(bool joker = false) : IComparer<(string hand, int bid, HandType handType)>\n{\n    readonly bool Joker = joker;\n    public int Compare((string hand, int bid, HandType handType) x, (string hand, int bid, HandType handType) y)\n    {\n        if (x.handType != y.handType)\n            return y.handType - x.handType;\n\n        for (int i = 0; i < x.hand.Length; i++)\n        {\n            if (x.hand[i] == y.hand[i])\n                continue;\n            return CardValue(x.hand[i]) - CardValue(y.hand[i]);\n        }\n        return 0;\n    }\n\n    private int CardValue(char c) => c switch\n            {\n                'A' => 14,\n                'K' => 13,\n                'Q' => 12,\n                'J' => Joker ? 0 : 11,\n                'T' => 10,\n                _ => int.Parse(c.ToString())\n            };\n}\n"))),"\n",r.createElement(e.h2,null,"Part Two"),"\n",r.createElement(e.p,null,"As the previous part of the solution no doubt suggested: we now also have jokers. A small tweak to the value of a J and how hand values are calculated are required, but nothing taxing."),"\n",r.createElement(t,{names:"typescript|C#"},r.createElement(e.pre,null,r.createElement(e.code,{className:"language-ts"},"export function partTwo(input: string[]): number | string {\n  const hands = input.map((x) => {\n    let matches = x.split(' ')\n    return {\n      cards: matches[0],\n      handValue: findHandType(matches[0], true),\n      bid: parseInt(matches[1]),\n    }\n  })\n  hands.sort((x, y) => compareHandValue(x, y, true))\n  console.log(hands)\n  return hands.reduce((total, hand, index) => hand.bid * (index + 1) + total, 0)\n}\n\nfunction findHandTypeJoker(\n  keyCount: number,\n  maxCount: number,\n  jokers: number\n): number {\n  switch (keyCount) {\n    case 1:\n    case 2:\n      return 7\n    case 3:\n      return jokers == 1 && maxCount < 3 ? 5 : 6\n    case 4:\n      return jokers == 2 || maxCount == 2 ? 4 : 2\n    default:\n      return 2\n  }\n}\n")),r.createElement(e.pre,null,r.createElement(e.code,{className:"language-csharp"},"public override object PartTwo()\n{\n    var comparer = new CamelHandComparer(true);\n    List<(string hand, int bid, HandType handType)> hands = [.. Input.Select(x => x.Split(' ', StringSplitOptions.RemoveEmptyEntries))\n                                                                     .Select(x => (hand: x[0], bid: int.Parse(x[1]), handType: FindHandType(x[0], true)))\n                                                                     .Order(comparer)];\n    long sum = 0;\n    for (int i = 0; i < hands.Count; i++)\n        sum += (i + 1) * hands[i].bid;\n\n    return sum;\n}\n\npublic static HandType FindHandTypeJoker(int keyCount, int maxCount, int jokers) => keyCount switch\n{\n    < 3 => HandType.FiveOfAKind,\n    3 => jokers == 1 && maxCount < 3 ? HandType.FullHouse : HandType.FourOfAKind,\n    4 => jokers == 2 || maxCount == 2 ? HandType.ThreeOfAKind : HandType.OnePair,\n    _ => HandType.OnePair\n};\n"))))}var d=function(n){void 0===n&&(n={});const{wrapper:e}=Object.assign({},(0,a.RP)(),n.components);return e?r.createElement(e,n,r.createElement(o,n)):o(n)};var i=t(2779),l=t(7206),c=t(791),u=t(4813),s=t(572);const p={CodeBox:i.A};function m(n){let{pageContext:e,children:t}=n;return r.createElement(r.Fragment,null,r.createElement(u.A,null),r.createElement("div",{className:"min-h-screen bg-chicPrimary"},r.createElement(c.A,{props:e.list}),r.createElement("div",{className:"adventofcode max-w-[60%] ml-[20%]"},r.createElement("h1",null,r.createElement("a",{href:"https://adventofcode.com/"+e.year+"/day/"+e.puzz},e.year+" Day "+e.puzz+" - "+e.title)),r.createElement(a.xA,{components:p},t),e.puzz&&e.year?r.createElement(l.A,{year:e.year,puzz:e.puzz}):r.createElement(r.Fragment,null))),r.createElement(s.A,null))}function h(n){return r.createElement(m,n,r.createElement(d,n))}const y=()=>r.createElement(r.Fragment,null,r.createElement("title",null,"Joel-Allan-NZ - Advent of Code"),r.createElement("html",{lang:"en"}),r.createElement("link",{rel:"preconnect",href:"https://fonts.googleapis.com"}),r.createElement("link",{rel:"preconnect",href:"https://fonts.gstatic.com"}),r.createElement("link",{href:"https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&family=VT323&display=swap",rel:"stylesheet"}))}}]);
//# sourceMappingURL=component---src-components-layout-tsx-content-file-path-days-2023-7-mdx-477606978efaad4ac464.js.map