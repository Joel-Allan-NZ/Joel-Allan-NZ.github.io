{"version":3,"file":"component---src-components-layout-tsx-content-file-path-days-2023-8-mdx-ef09d73d63f461693751.js","mappings":"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","sources":["webpack://joel-allan-nz.github.io/./days/2023/8.mdx","webpack://joel-allan-nz.github.io/./src/components/Layout.tsx"],"sourcesContent":["/*@jsxRuntime classic @jsx React.createElement @jsxFrag React.Fragment*/\nimport {useMDXComponents as _provideComponents} from \"@mdx-js/react\";\nimport React from \"react\";\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    p: \"p\",\n    pre: \"pre\",\n    code: \"code\",\n    ul: \"ul\",\n    li: \"li\",\n    em: \"em\"\n  }, _provideComponents(), props.components), {CodeBox} = _components;\n  if (!CodeBox) _missingMdxReference(\"CodeBox\", true);\n  return React.createElement(React.Fragment, null, React.createElement(_components.h2, null, \"Part One\"), \"\\n\", React.createElement(_components.p, null, \"Parse the input, build a basic adjacency list, and traverse it according to the given directions until you reach the end point. Alarmingly simple, always a red flag for what you might expect for part 2\"), \"\\n\", React.createElement(CodeBox, {\n    names: \"typescript|C#\"\n  }, React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-js\"\n  }, \"export function partOne(input: string[]): number | string {\\n  const { directions, graph } = parse(input)\\n  let steps = 0\\n  let position = 'AAA'\\n  let directionIndex = 0\\n\\n  while (position != 'ZZZ') {\\n    const direction = directions[directionIndex]\\n    position =\\n      direction == 'L' ? graph.get(position)![0] : graph.get(position)![1]\\n    steps++\\n    directionIndex =\\n      directionIndex == directions.length - 1 ? 0 : directionIndex + 1\\n  }\\n  return steps\\n}\\n\\nfunction parse(input: string[]): {\\n  directions: string\\n  graph: Map<string, string[]>\\n} {\\n  const directions = input[0]\\n  const graph = new Map<string, string[]>()\\n  input.slice(2).forEach((line) => {\\n    const paths = [line.slice(7, 10), line.slice(12, 15)]\\n    graph.set(line.slice(0, 3), paths)\\n  })\\n  return { directions, graph }\\n}\\n\")), React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-csharp\"\n  }, \"public override object PartOne()\\n{\\n    var (directions, graph) = Parse();\\n    int steps = 0;\\n    string position = \\\"AAA\\\";\\n\\n    while (position != \\\"ZZZ\\\")\\n    {\\n        foreach (var direction in directions)\\n        {\\n            position = direction == 'L' ? graph[position][0] : graph[position][1];\\n            steps++;\\n            if (position == \\\"ZZZ\\\")\\n                break;\\n        }\\n    }\\n    return steps;\\n}\\n\\nprivate (string directions, Dictionary<string, string[]> graph) Parse()\\n{\\n    string directions = Input[0];\\n    Dictionary<string, string[]> graph = [];\\n    for (int i = 2; i < Input.Length; i++)\\n    {\\n        graph[Input[i][0..3]] = [Input[i][7..10], Input[i][12..15]];\\n    }\\n    return (directions, graph);\\n}\\n\"))), \"\\n\", React.createElement(_components.h2, null, \"Part Two\"), \"\\n\", React.createElement(_components.p, null, \"Ahhh, here we go.\"), \"\\n\", React.createElement(\"br\"), \"\\n\", React.createElement(_components.p, null, \"First things first, I need to outline a couple assumptions (knowing that this isn't\\na real world problem) that I've made in my solution in order to keep it simple:\", ' '), \"\\n\", React.createElement(_components.ul, null, \"\\n\", React.createElement(_components.li, null, \"\\n\", React.createElement(_components.p, null, \"Paths only contain one end. This makes sense based on having as many ends as starts, and my input validates the\\nassumption... but it is only an assumption. YMMV\"), \"\\n\"), \"\\n\", React.createElement(_components.li, null, \"\\n\", React.createElement(_components.p, null, \"Longest path loops share a \", React.createElement(_components.em, null, \"single\"), \"\\nGCD. This isn't necessarily true, but the result could be veeeeery big if it isn't.\\nTrue for my input at least.\"), \"\\n\"), \"\\n\", React.createElement(_components.li, null, \"\\n\", React.createElement(_components.p, null, \"Loop lengths have only two meaningful factors: the GCD,\\nand a prime number. It makes sense, and holds true for my input.\"), \"\\n\"), \"\\n\"), \"\\n\", React.createElement(\"br\"), \"\\n\", React.createElement(_components.p, null, \"With that housekeeping done, I can talk a little about my approach. The idea here\\nis that each of the A starts will have their own path, looping to a Z point after\\na consistent number of steps. So, I find those loop lengths.\"), \"\\n\", React.createElement(\"br\"), \"\\n\", React.createElement(_components.p, null, \"Armed with these lengths, all we need to do is find the smallest number that has\\neach loop length as a factor. I do this pretty lazily: for the first pair of loops,\\nI find the\\n\", React.createElement(\"a\", {\n    href: \"https://en.wikipedia.org/wiki/Greatest_common_divisor\"\n  }, \"GCD\"), \" via the\\n\", React.createElement(\"a\", {\n    href: \"https://en.wikipedia.org/wiki/Euclidean_algorithm\"\n  }, \"Euclidian\"), \"\\nalgorithm. As discussed above, I make the assumption that this single GCD will hold\\ntrue for all loop lengths, so I simply take the GCD + the other factor for each loop\\nlength. Then I take the product of all of those factors, yielding the\\n\", React.createElement(\"a\", {\n    href: \"https://en.wikipedia.org/wiki/Least_common_multiple\"\n  }, \"LCM\"), \", our\\nanswer.\"), \"\\n\", React.createElement(CodeBox, {\n    names: \"typescript|C#\"\n  }, React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-ts\"\n  }, \"export function partTwo(input: string[]): number | string {\\n  const { directions, graph } = parse(input)\\n  let loops = [...graph.keys().filter((x) => x.endsWith('A'))].map((x) =>\\n    findLoop(graph, x, directions)\\n  )\\n  const factors = new Set<number>()\\n  const g = gcd(loops[0], loops[1])\\n  factors.add(g)\\n  loops.forEach((loopLength) => factors.add(loopLength / g))\\n\\n  return factors.values().reduce((total, x) => x * total, 1)\\n}\\n\\nfunction findLoop(\\n  graph: Map<string, string[]>,\\n  position: string,\\n  directions: string\\n) {\\n  const travelled = new Map<string, number[]>([[position, [0]]])\\n  let steps = 0\\n  let directionIndex = 0\\n\\n  while (true) {\\n    const direction = directions[directionIndex]\\n    position =\\n      direction == 'L' ? graph.get(position)![0] : graph.get(position)![1]\\n    steps++\\n    directionIndex =\\n      directionIndex == directions.length - 1 ? 0 : directionIndex + 1\\n\\n    const been = travelled.get(position)\\n    if (!been) travelled.set(position, [steps])\\n    else travelled.set(position, [...been, steps])\\n\\n    if (been) {\\n      if (\\n        been[been.length - 1] % directions.length ==\\n        steps % directions.length\\n      )\\n        return been[been.length - 1]\\n    }\\n  }\\n}\\n\\nfunction gcd(a: number, b: number): number {\\n  while (b != 0) {\\n    let t = b\\n    b = a % b\\n    a = t\\n  }\\n  return a\\n}\\n\")), React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-csharp\"\n  }, \"public override object PartTwo()\\n{\\n    var (directions, graph) = Parse();\\n    var positions = graph.Keys.Where(key => key.EndsWith('A')).ToList();\\n    var loops = positions.Select(x => FindLoop(graph, x, directions)).ToList();\\n\\n    HashSet<long> factors = [];\\n    var gcd = GCD(loops[0], loops[1]);\\n    factors.Add(gcd);\\n    foreach (var loop in loops)\\n        factors.Add(loop / gcd);\\n\\n    return factors.Aggregate((x, y) => x * y);\\n}\\n\\nprivate static long FindLoop(Dictionary<string, string[]> graph, string start, string directions)\\n{\\n    Dictionary<string, List<long>> appearancesOnSteps = [];\\n    appearancesOnSteps[start] = [0];\\n    int dIndex = 0;\\n    long steps = 0;\\n\\n    while (true)\\n    {\\n        steps++;\\n        start = directions[dIndex] == 'L' ? graph[start][0] : graph[start][1];\\n        dIndex = dIndex == directions.Length - 1 ? 0 : dIndex + 1;\\n\\n        if (appearancesOnSteps.TryGetValue(start, out var s))\\n            s.Add(steps);\\n        else\\n            appearancesOnSteps[start] = [steps];\\n\\n        if (appearancesOnSteps[start].Count > 1)\\n        {\\n            if (appearancesOnSteps[start][^1] % directions.Length == appearancesOnSteps[start][^2] % directions.Length)\\n            {\\n                return appearancesOnSteps[start][^2];\\n            }\\n        }\\n    }\\n}\\n\\nprivate static long GCD(long a, long b)\\n{\\n    while (b != 0)\\n    {\\n        var t = b;\\n        b = a % b;\\n        a = t;\\n    }\\n    return a;\\n}\\n\"))));\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? React.createElement(MDXLayout, props, React.createElement(_createMdxContent, props)) : _createMdxContent(props);\n}\nexport default MDXContent;\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","import GATSBY_COMPILED_MDX from \"/home/joel/personal/advent-of-code/joel-allan-nz.github.io/days/2023/8.mdx\";\nimport React from 'react';\nimport {MDXProvider} from '@mdx-js/react';\nimport CodeBox from './CodeBox';\nimport TryYourself from './TryYourself';\nimport AdventSideNav from './AdventSideNav';\nimport Header from './Header';\nimport Footer from './Footer';\nconst shortcodes = {\n  CodeBox\n};\nfunction Layout(_ref) {\n  let {pageContext, children} = _ref;\n  return React.createElement(React.Fragment, null, React.createElement(Header, null), React.createElement(\"div\", {\n    className: \"min-h-screen bg-chicPrimary\"\n  }, React.createElement(AdventSideNav, {\n    props: pageContext.list\n  }), React.createElement(\"div\", {\n    className: \"adventofcode max-w-[60%] ml-[20%]\"\n  }, React.createElement(\"h1\", null, React.createElement(\"a\", {\n    href: \"https://adventofcode.com/\" + pageContext.year + \"/day/\" + pageContext.puzz\n  }, pageContext.year + \" Day \" + pageContext.puzz + \" - \" + pageContext.title)), React.createElement(MDXProvider, {\n    components: shortcodes\n  }, children), pageContext.puzz && pageContext.year ? React.createElement(TryYourself, {\n    year: pageContext.year,\n    puzz: pageContext.puzz\n  }) : React.createElement(React.Fragment, null))), React.createElement(Footer, null));\n}\nexport default function GatsbyMDXWrapper(props) {\n  return React.createElement(Layout, props, React.createElement(GATSBY_COMPILED_MDX, props));\n}\nexport const Head = () => React.createElement(React.Fragment, null, React.createElement(\"title\", null, \"Joel-Allan-NZ - Advent of Code\"), React.createElement(\"html\", {\n  lang: \"en\"\n}), React.createElement(\"link\", {\n  rel: \"preconnect\",\n  href: \"https://fonts.googleapis.com\"\n}), React.createElement(\"link\", {\n  rel: \"preconnect\",\n  href: \"https://fonts.gstatic.com\"\n}), React.createElement(\"link\", {\n  href: \"https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&family=VT323&display=swap\",\n  rel: \"stylesheet\"\n}));\n"],"names":["_createMdxContent","props","_components","Object","assign","h2","p","pre","code","ul","li","em","_provideComponents","components","CodeBox","id","component","Error","_missingMdxReference","React","names","className","href","wrapper","MDXLayout","shortcodes","Layout","_ref","pageContext","children","Header","AdventSideNav","list","year","puzz","title","MDXProvider","TryYourself","Footer","GatsbyMDXWrapper","GATSBY_COMPILED_MDX","Head","lang","rel"],"sourceRoot":""}