"use strict";(self.webpackChunkjoel_allan_nz_github_io=self.webpackChunkjoel_allan_nz_github_io||[]).push([[1890],{7515:function(e,n,t){t.r(n),t.d(n,{Head:function(){return m},default:function(){return h}});var r=t(8453),a=t(6540);function i(e){const n=Object.assign({h2:"h2",p:"p",a:"a",em:"em",pre:"pre",code:"code"},(0,r.RP)(),e.components),{CodeBox:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("CodeBox",!0),a.createElement(a.Fragment,null,a.createElement(n.h2,null,"Part One"),"\n",a.createElement(n.p,null,"The idea here is that we need to find a ",a.createElement(n.a,{href:"https://en.wikipedia.org/wiki/Minimum_cut"},"min cut")," of the input, such that with exactly 3 cuts we have two disjoint sets."),"\n",a.createElement("br"),"\n",a.createElement(n.p,null,"Purely for the novelty of it, I opted to use ",a.createElement(n.a,{href:"https://en.wikipedia.org/wiki/Karger%27s_algorithm"},"Karger's algorithm"),",\nwhich is non-deterministic! The implemented solution will run infinitely until a\nvalid cut is found, and depending on your luck this could be instant or take several\nseconds."),"\n",a.createElement("br"),"\n",a.createElement(n.p,null,"It breaks my general rule of fast and reliable solutions, but I can't remember the\nlast time I had a chance to acutally ",a.createElement(n.em,null,"use")," a non-deterministic algorithm. It's day\n25, I'm going to live a little."),"\n",a.createElement(t,{names:"typescript|C#"},a.createElement(n.pre,null,a.createElement(n.code,{className:"language-ts"},"export function partOne(input: string[]): number | string {\n  const graph = new Map<string, Map<string, number>>()\n  for (let line of input) {\n    const split = line.split(' ')\n    const a = split[0].slice(0, 3)\n\n    if (!graph.has(a)) graph.set(a, new Map<string, number>())\n\n    for (let add of split.slice(1)) {\n      if (!graph.has(add)) graph.set(add, new Map<string, number>())\n\n      graph.get(a)!.set(add, 1)\n      graph.get(add)!.set(a, 1)\n    }\n  }\n\n  while (true) {\n    const copy = new Map<string, Map<string, number>>()\n    graph.keys().forEach((key) => {\n      copy.set(key, new Map<string, number>())\n      graph\n        .get(key)!\n        .entries()\n        .forEach((v) => copy.get(key)!.set(v[0], v[1]))\n    })\n    const count = karger(copy)\n    const entries = copy.entries().toArray()\n\n    if (entries[0][1].get(entries[1][0]) == 3) {\n      return count.get(entries[0][0])! * count.get(entries[1][0])!\n    }\n  }\n}\n\nfunction karger(graph: Map<string, Map<string, number>>): Map<string, number> {\n  const count = new Map<string, number>()\n  graph.keys().forEach((key) => count.set(key, 1))\n\n  while (graph.size > 2) {\n    const edge = getRandomEdge(graph)\n    merge(graph, edge)\n    const newCount = count.get(edge[0])! + count.get(edge[1])!\n    count.set(edge[0], newCount)\n  }\n  return count\n}\n\nfunction getRandomEdge(graph: Map<string, Map<string, number>>): string[] {\n  const u = graph.keys().toArray()[Math.floor(Math.random() * graph.size)]\n  const vSize = graph.get(u)!.size\n  const v = graph.get(u)!.keys().toArray()[Math.floor(Math.random() * vSize)]\n\n  return [u, v]\n}\n\nfunction merge(graph: Map<string, Map<string, number>>, edge: string[]): void {\n  const vEdges = graph.get(edge[1])!.entries().toArray()\n\n  for (let e of vEdges) {\n    if (e[0] != edge[0]) {\n      let uDistance = graph.get(edge[0])?.get(e[0])\n      uDistance ??= 0\n      graph.get(edge[0])?.set(e[0], e[1] + uDistance)\n\n      graph.get(e[0])?.set(edge[0], graph.get(edge[0])!.get(e[0])!)\n    }\n    graph.get(e[0])?.delete(edge[1])\n  }\n\n  graph.get(edge[0])?.delete(edge[1])\n  graph.delete(edge[1])\n}\n")),a.createElement(n.pre,null,a.createElement(n.code,{className:"language-csharp"},'public override object PartOne()\n{\n    Dictionary<string, Dictionary<string, int>> adjacent = [];\n\n    foreach (var line in Input)\n    {\n        var split = line.Split(" ");\n        if (!adjacent.ContainsKey(split[0][0..3]))\n            adjacent[split[0][0..3]] = [];\n\n        foreach (var add in split[1..])\n        {\n            if (!adjacent.ContainsKey(add))\n                adjacent[add] = [];\n\n            adjacent[split[0][0..3]].Add(add, 1);\n            adjacent[add].Add(split[0][0..3], 1);\n        }\n    }\n\n    return KargerMinCut(adjacent);\n}\n\nprivate static int KargerMinCut(Dictionary<string, Dictionary<string, int>> graph)\n{\n    Random rand = new();\n\n    while (true)\n    {\n        var copyGraph = graph.ToDictionary(entry => entry.Key, value => value.Value.ToDictionary(x => x.Key, y => y.Value));\n        var count = Karger(copyGraph, rand);\n        if (copyGraph.First().Value[copyGraph.Last().Key] == 3)\n            return count[copyGraph.First().Key] * count[copyGraph.Last().Key];\n    }\n}\n\nprivate static Dictionary<string, int> Karger(Dictionary<string, Dictionary<string, int>> graph, Random rand)\n{\n    Dictionary<string, int> count = [];\n    foreach (var key in graph.Keys)\n    {\n        count[key] = 1;\n    }\n\n    while (graph.Count > 2)\n    {\n        var (u, v) = GetRandomEdge(graph, rand);\n        Merge(graph, u, v);\n        count[u] += count[v];\n    }\n    return count;\n\n}\n\nprivate static (string, string) GetRandomEdge(Dictionary<string, Dictionary<string, int>> graph, Random rand)\n{\n    var u = graph.Keys.ElementAt(rand.Next(graph.Count));\n    var v = graph[u].ElementAt(rand.Next(graph[u].Count));\n    return (u, v.Key);\n}\n\nprivate static void Merge(Dictionary<string, Dictionary<string, int>> graph, string edge, string v)\n{\n    foreach (var e in graph[v].ToList())\n    {\n        if (e.Key != edge)\n        {\n            if (graph[edge].ContainsKey(e.Key))\n                graph[edge][e.Key] += e.Value;\n            else\n                graph[edge][e.Key] = e.Value;\n\n            graph[e.Key][edge] = graph[edge][e.Key];\n\n        }\n        graph[e.Key].Remove(v);\n    }\n    graph[edge].Remove(v);\n    graph.Remove(v);\n}\n'))),"\n",a.createElement(n.h2,null,"Part Two"),"\n",a.createElement(n.p,null,"Part two of Christmas Day is always a free star ⭐"),"\n",a.createElement("br"))}var o=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,r.RP)(),e.components);return n?a.createElement(n,e,a.createElement(i,e)):i(e)};var s=t(2779),c=t(7206),l=t(791),g=t(4813),p=t(572);const u={CodeBox:s.A};function d(e){let{pageContext:n,children:t}=e;return a.createElement(a.Fragment,null,a.createElement(g.A,null),a.createElement("div",{className:"min-h-screen bg-chicPrimary"},a.createElement(l.A,{props:n.list}),a.createElement("div",{className:"adventofcode max-w-[60%] ml-[20%]"},a.createElement("h1",null,a.createElement("a",{href:"https://adventofcode.com/"+n.year+"/day/"+n.puzz},n.year+" Day "+n.puzz+" - "+n.title)),a.createElement(r.xA,{components:u},t),n.puzz&&n.year?a.createElement(c.A,{year:n.year,puzz:n.puzz}):a.createElement(a.Fragment,null))),a.createElement(p.A,null))}function h(e){return a.createElement(d,e,a.createElement(o,e))}const m=()=>a.createElement(a.Fragment,null,a.createElement("title",null,"Joel-Allan-NZ - Advent of Code"),a.createElement("html",{lang:"en"}),a.createElement("link",{rel:"preconnect",href:"https://fonts.googleapis.com"}),a.createElement("link",{rel:"preconnect",href:"https://fonts.gstatic.com"}),a.createElement("link",{href:"https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&family=VT323&display=swap",rel:"stylesheet"}))}}]);
//# sourceMappingURL=component---src-components-layout-tsx-content-file-path-days-2023-25-mdx-b9bb3196e4678ee73ded.js.map