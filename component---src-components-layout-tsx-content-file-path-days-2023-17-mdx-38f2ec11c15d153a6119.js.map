{"version":3,"file":"component---src-components-layout-tsx-content-file-path-days-2023-17-mdx-38f2ec11c15d153a6119.js","mappings":"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","sources":["webpack://joel-allan-nz.github.io/./days/2023/17.mdx","webpack://joel-allan-nz.github.io/./src/components/Layout.tsx"],"sourcesContent":["/*@jsxRuntime classic @jsx React.createElement @jsxFrag React.Fragment*/\nimport {useMDXComponents as _provideComponents} from \"@mdx-js/react\";\nimport React from \"react\";\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    p: \"p\",\n    a: \"a\",\n    pre: \"pre\",\n    code: \"code\",\n    em: \"em\"\n  }, _provideComponents(), props.components), {CodeBox} = _components;\n  if (!CodeBox) _missingMdxReference(\"CodeBox\", true);\n  return React.createElement(React.Fragment, null, React.createElement(_components.h2, null, \"Part One\"), \"\\n\", React.createElement(_components.p, null, \"An Advent of Code staple: path-finding algorithms with some extra rules.\"), \"\\n\", React.createElement(\"br\"), \"\\n\", React.createElement(_components.p, null, \"This particular solution is essentially \", React.createElement(_components.a, {\n    href: \"https://en.wikipedia.org/wiki/Iterative_deepening_depth-first_search\"\n  }, \"IDDFS\"), \",\\nwalking down sets of next positions until all reachable positions have been discovered.\"), \"\\n\", React.createElement(\"br\"), \"\\n\", React.createElement(CodeBox, {\n    names: \"typescript|C#\"\n  }, React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-ts\"\n  }, \"export function partOne(input: string[]): number | string {\\n  return findPaths(input, 0, 3)\\n}\\ninterface HeatNode {\\n  x: number\\n  y: number\\n  value: number\\n  from: number[]\\n}\\n\\nfunction findPaths(\\n  input: string[],\\n  minSteps: number,\\n  maxSteps: number\\n): number {\\n  const grid = heatGrid(input)\\n  grid[0][0].from = [0, 0, 0, 0]\\n  let future: { x: number; y: number; nextVertical: boolean }[] = []\\n  getNextVertical(grid, grid[0][0], minSteps, maxSteps, future)\\n  getNextHorizontal(grid, grid[0][0], minSteps, maxSteps, future)\\n\\n  while (future.length > 0) {\\n    const next = future\\n    future = []\\n    for (let state of next) {\\n      if (state.nextVertical)\\n        getNextVertical(\\n          grid,\\n          grid[state.y][state.x],\\n          minSteps,\\n          maxSteps,\\n          future\\n        )\\n      else\\n        getNextHorizontal(\\n          grid,\\n          grid[state.y][state.x],\\n          minSteps,\\n          maxSteps,\\n          future\\n        )\\n    }\\n  }\\n  var last = grid[grid.length - 1][grid[0].length - 1]\\n  return Math.min(last.from[0], last.from[1], last.from[2], last.from[3])\\n}\\n\\nfunction heatGrid(input: string[]): HeatNode[][] {\\n  const grid: HeatNode[][] = []\\n  const big = 2 ** 31\\n  for (let y = 0; y < input.length; y++) {\\n    grid.push([])\\n    for (let x = 0; x < input[y].length; x++) {\\n      grid[y].push({\\n        x,\\n        y,\\n        value: parseInt(input[y][x]),\\n        from: [big, big, big, big],\\n      })\\n    }\\n  }\\n  return grid\\n}\\n\\nfunction getNextVertical(\\n  grid: HeatNode[][],\\n  origin: HeatNode,\\n  minSteps: number,\\n  maxSteps: number,\\n  next: { x: number; y: number; nextVertical: boolean }[]\\n): void {\\n  let originDistance = Math.min(origin.from[1], origin.from[3])\\n\\n  for (let i = 1; i <= maxSteps; i++) {\\n    if (origin.y - i < 0) break\\n\\n    let node = grid[origin.y - i][origin.x]\\n    originDistance += node.value\\n    if (i >= minSteps && node.from[2] > originDistance) {\\n      next.push({ x: node.x, y: node.y, nextVertical: false })\\n      node.from[2] = originDistance\\n    }\\n  }\\n\\n  originDistance = Math.min(origin.from[1], origin.from[3])\\n\\n  for (let i = 1; i <= maxSteps; i++) {\\n    if (origin.y + i > grid.length - 1) break\\n\\n    let node = grid[origin.y + i][origin.x]\\n    originDistance += node.value\\n    if (i >= minSteps && node.from[0] > originDistance) {\\n      next.push({ x: node.x, y: node.y, nextVertical: false })\\n      node.from[0] = originDistance\\n    }\\n  }\\n}\\n\\nfunction getNextHorizontal(\\n  grid: HeatNode[][],\\n  origin: HeatNode,\\n  minSteps: number,\\n  maxSteps: number,\\n  next: { x: number; y: number; nextVertical: boolean }[]\\n): void {\\n  let originDistance = Math.min(origin.from[0], origin.from[2])\\n  for (let i = 1; i <= maxSteps; i++) {\\n    if (origin.x + 1 > grid[0].length - i) break\\n\\n    let node = grid[origin.y][origin.x + i]\\n    originDistance += node.value\\n    if (i >= minSteps && node.from[3] > originDistance) {\\n      next.push({ x: node.x, y: node.y, nextVertical: true })\\n      node.from[3] = originDistance\\n    }\\n  }\\n  originDistance = Math.min(origin.from[0], origin.from[2])\\n  for (let i = 1; i <= maxSteps; i++) {\\n    if (origin.x - i < 0) break\\n\\n    let node = grid[origin.y][origin.x - i]\\n    originDistance += node.value\\n    if (i >= minSteps && node.from[1] > originDistance) {\\n      next.push({ x: node.x, y: node.y, nextVertical: true })\\n      node.from[1] = originDistance\\n    }\\n  }\\n}\\n\")), React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-csharp\"\n  }, \"public override object PartOne()\\n{\\n    return FindPaths(Input, 0, 3);\\n}\\n\\nprivate class HeatNode(int x, int y, int value)\\n{\\n    internal int X = x;\\n    internal int Y = y;\\n    internal int Value = value;\\n    internal int[] From = [int.MaxValue, int.MaxValue, int.MaxValue, int.MaxValue];\\n}\\n\\nprivate static HeatNode[][] HeatGrid(string[] input)\\n{\\n    HeatNode[][] grid = new HeatNode[input.Length][];\\n    for (int y = 0; y < input.Length; y++)\\n    {\\n        grid[y] = new HeatNode[input[y].Length];\\n        for (int x = 0; x < input[y].Length; x++)\\n        {\\n            grid[y][x] = new HeatNode(x, y, input[y][x] - '0');\\n        }\\n    }\\n    return grid;\\n}\\n\\nprivate static int FindPaths(string[] input, int minSteps = 0, int maxSteps = int.MaxValue)\\n{\\n    var grid = HeatGrid(input);\\n    grid[0][0].From = [0, 0, 0, 0];\\n    List<(HeatNode origin, bool nextVertical)> next = [];\\n    GetNextVertical(grid, grid[0][0], minSteps, maxSteps, next);\\n    GetNextHorizontal(grid, grid[0][0], minSteps, maxSteps, next);\\n\\n    while (next.Count > 0)\\n    {\\n        var future = new List<(HeatNode origin, bool vertical)>();\\n\\n        foreach (var (origin, nextVertical) in next)\\n        {\\n            if (nextVertical)\\n                GetNextVertical(grid, origin, minSteps, maxSteps, future);\\n            else\\n                GetNextHorizontal(grid, origin, minSteps, maxSteps, future);\\n        }\\n        next = future;\\n    }\\n    return grid[^1][^1].From.Min();\\n}\\n\\n\\nprivate static void GetNextVertical(HeatNode[][] grid, HeatNode origin, int minSteps, int maxSteps, List<(HeatNode origin, bool nextVertical)> next)\\n{\\n    var originDistance = Math.Min(origin.From[1], origin.From[3]);\\n\\n    for (int i = 1; i <= maxSteps; i++)\\n    {\\n        if (origin.Y - i < 0)\\n            break;\\n\\n        var node = grid[origin.Y - i][origin.X];\\n        originDistance += node.Value;\\n\\n        if (i >= minSteps && node.From[2] > originDistance)\\n        {\\n            next.Add((node, false));\\n            node.From[2] = originDistance;\\n\\n        }\\n\\n    }\\n\\n\\n    originDistance = Math.Min(origin.From[1], origin.From[3]);\\n    for (int i = 1; i <= maxSteps; i++)\\n    {\\n        if (origin.Y + i > grid.Length - 1)\\n            break;\\n\\n        var node = grid[origin.Y + i][origin.X];\\n        originDistance += node.Value;\\n\\n        if (i >= minSteps && node.From[0] > originDistance)\\n        {\\n            next.Add((node, false));\\n            node.From[0] = originDistance;\\n        }\\n\\n    }\\n}\\n\\nprivate static void GetNextHorizontal(HeatNode[][] grid, HeatNode origin, int minSteps, int maxSteps, List<(HeatNode origin, bool nextVertical)> next)\\n{\\n    var originDistance = Math.Min(origin.From[0], origin.From[2]);\\n    for (int i = 1; i <= maxSteps; i++)\\n    {\\n        if (origin.X + 1 > grid[0].Length - i)\\n            break;\\n\\n        var node = grid[origin.Y][origin.X + i];\\n        originDistance += node.Value;\\n\\n        if (i >= minSteps && node.From[3] > originDistance)\\n        {\\n            next.Add((node, true));\\n            node.From[3] = originDistance;\\n        }\\n\\n    }\\n\\n    originDistance = Math.Min(origin.From[0], origin.From[2]);\\n    for (int i = 1; i <= maxSteps; i++)\\n    {\\n        if (origin.X - i < 0)\\n            break;\\n\\n        var node = grid[origin.Y][origin.X - i];\\n        originDistance += node.Value;\\n        if (i >= minSteps && node.From[1] > originDistance)\\n        {\\n            next.Add((node, true));\\n            node.From[1] = originDistance;\\n        }\\n    }\\n}\\n\"))), \"\\n\", React.createElement(_components.h2, null, \"Part Two\"), \"\\n\", React.createElement(_components.p, null, \"The same thing, but with slightly different numbers. It's actually \", React.createElement(_components.em, null, \"faster\"), \" than part one, a real rarity for AoC!\"), \"\\n\", React.createElement(CodeBox, {\n    names: \"typescript|C#\"\n  }, React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-ts\"\n  }, \"export function partTwo(input: string[]): number | string {\\n  return findPaths(input, 4, 10)\\n}\\n\")), React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-csharp\"\n  }, \"public override object PartTwo()\\n{\\n    return FindPaths(Input, 4, 10);\\n}\\n\"))));\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? React.createElement(MDXLayout, props, React.createElement(_createMdxContent, props)) : _createMdxContent(props);\n}\nexport default MDXContent;\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","import GATSBY_COMPILED_MDX from \"/home/joel/personal/advent-of-code/joel-allan-nz.github.io/days/2023/17.mdx\";\nimport React from 'react';\nimport {MDXProvider} from '@mdx-js/react';\nimport CodeBox from './CodeBox';\nimport TryYourself from './TryYourself';\nimport AdventSideNav from './AdventSideNav';\nimport Header from './Header';\nimport Footer from './Footer';\nconst shortcodes = {\n  CodeBox\n};\nfunction Layout(_ref) {\n  let {pageContext, children} = _ref;\n  return React.createElement(React.Fragment, null, React.createElement(Header, null), React.createElement(\"div\", {\n    className: \"min-h-screen bg-chicPrimary\"\n  }, React.createElement(AdventSideNav, {\n    props: pageContext.list\n  }), React.createElement(\"div\", {\n    className: \"adventofcode max-w-[60%] ml-[20%]\"\n  }, React.createElement(\"h1\", null, React.createElement(\"a\", {\n    href: \"https://adventofcode.com/\" + pageContext.year + \"/day/\" + pageContext.puzz\n  }, pageContext.year + \" Day \" + pageContext.puzz + \" - \" + pageContext.title)), React.createElement(MDXProvider, {\n    components: shortcodes\n  }, children), pageContext.puzz && pageContext.year ? React.createElement(TryYourself, {\n    year: pageContext.year,\n    puzz: pageContext.puzz\n  }) : React.createElement(React.Fragment, null))), React.createElement(Footer, null));\n}\nexport default function GatsbyMDXWrapper(props) {\n  return React.createElement(Layout, props, React.createElement(GATSBY_COMPILED_MDX, props));\n}\nexport const Head = () => React.createElement(React.Fragment, null, React.createElement(\"title\", null, \"Joel-Allan-NZ - Advent of Code\"), React.createElement(\"html\", {\n  lang: \"en\"\n}), React.createElement(\"link\", {\n  rel: \"preconnect\",\n  href: \"https://fonts.googleapis.com\"\n}), React.createElement(\"link\", {\n  rel: \"preconnect\",\n  href: \"https://fonts.gstatic.com\"\n}), React.createElement(\"link\", {\n  href: \"https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&family=VT323&display=swap\",\n  rel: \"stylesheet\"\n}));\n"],"names":["_createMdxContent","props","_components","Object","assign","h2","p","a","pre","code","em","_provideComponents","components","CodeBox","id","component","Error","_missingMdxReference","React","href","names","className","wrapper","MDXLayout","shortcodes","Layout","_ref","pageContext","children","Header","AdventSideNav","list","year","puzz","title","MDXProvider","TryYourself","Footer","GatsbyMDXWrapper","GATSBY_COMPILED_MDX","Head","lang","rel"],"sourceRoot":""}