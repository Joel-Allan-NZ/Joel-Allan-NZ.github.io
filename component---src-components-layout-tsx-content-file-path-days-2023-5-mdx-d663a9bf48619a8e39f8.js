"use strict";(self.webpackChunkjoel_allan_nz_github_io=self.webpackChunkjoel_allan_nz_github_io||[]).push([[7754],{2930:function(e,n,t){t.r(n),t.d(n,{Head:function(){return p},default:function(){return m}});var a=t(8453),r=t(6540);function s(e){const n=Object.assign({h2:"h2",p:"p",code:"code",pre:"pre"},(0,a.RP)(),e.components),{CodeBox:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("CodeBox",!0),r.createElement(r.Fragment,null,r.createElement(n.h2,null,"Part One"),"\n",r.createElement(n.p,null,"Whew, that was pretty verbose."),"\n",r.createElement("br"),"\n",r.createElement(n.p,null,"The idea here is to map each map to the next map, then the result of those merged\nmaps to the next map, continuing until all maps have been merged. For discrete values\nthis would be vanishingly simple, but of course we're dealing with ranges of values."),"\n",r.createElement("br"),"\n",r.createElement(n.p,null,"To make it more readable for myself I switched up the three-value setup: instead\nof a new value, a start value, and a range value like the input, I opted for a start\nvalue, an end value, and an offset. So for the the first example ",r.createElement(n.code,null,"seed-to-soil")," map,\n",r.createElement(n.code,null,"50 98 2")," becomes ",r.createElement(n.code,null,"start: 98, end:99, offset:-48"),".\n",r.createElement("br")," From there it's a matter of merging each set of maps, creating new ranges\nthat reflect the offsets from each of the merged maps. I sort the values for\neach map in ascending order, then only consider the smallest at any given point\nin time, constructing new ranges from any overlap (or lackthereof)."),"\n",r.createElement("br"),"\n",r.createElement(t,{names:"typescript|C#"},r.createElement(n.pre,null,r.createElement(n.code,{className:"language-js"},"export function partOne(input: string[]): number | string {\n  const { seeds, reduced } = parseAndReduce(input)\n\n  return seeds.reduce((min, seed) => {\n    const inRange = reduced.find(\n      (range) => range.start <= seed && range.end >= seed\n    )\n    const value = inRange ? seed + inRange.offset : seed\n    return min < value ? min : value\n  }, 2 ** 63)\n}\n\ninterface OffsetRange {\n  start: number\n  end: number\n  offset: number\n}\n\nfunction parseAndReduce(input: string[]): {\n  seeds: number[]\n  reduced: OffsetRange[]\n} {\n  const seeds = input[0]\n    .split(' ')\n    .slice(1)\n    .map((x) => parseInt(x))\n\n  let reduced: OffsetRange[] = []\n  let next: OffsetRange[] = []\n\n  for (let i = 3; i < input.length; i++) {\n    const line = input[i]\n    if (!line || line.length == 0) {\n      i++\n      reduced = reduced.length == 0 ? next : merge(reduced, next)\n      next = []\n    } else {\n      const split = line.split(' ').map((x) => parseInt(x))\n      next.push({\n        start: split[1],\n        end: split[2] + split[1] - 1,\n        offset: split[0] - split[1],\n      })\n    }\n  }\n  return { seeds, reduced: merge(reduced, next) }\n}\n\nfunction merge(a: OffsetRange[], b: OffsetRange[]): OffsetRange[] {\n  const result: OffsetRange[] = []\n  a.sort((x, y) => x.start + x.offset - (y.start + y.offset))\n  b.sort((x, y) => x.start - y.start)\n  let aRange = a.shift()\n  let bRange = b.shift()\n\n  while (aRange && bRange) {\n    result.push(mergeRanges(aRange, bRange))\n\n    if (aRange.end < aRange.start) aRange = a.shift()\n    if (bRange.end < bRange.start) bRange = b.shift()\n  }\n\n  if (aRange && aRange.end >= aRange.start) result.push(aRange)\n  if (bRange && bRange.end >= bRange.start) result.push(bRange)\n\n  return [...result, ...b, ...a]\n}\n\nfunction mergeRanges(aRange: OffsetRange, bRange: OffsetRange): OffsetRange {\n  let result: OffsetRange = { start: 0, end: 0, offset: 0 }\n  if (aRange.start + aRange.offset == bRange.start) {\n    const end = Math.min(aRange.end + aRange.offset, bRange.end) - aRange.offset\n    result = { start: aRange.start, end, offset: aRange.offset + bRange.offset }\n    aRange.start = end + 1\n    bRange.start = end + aRange.offset + 1\n  } else {\n    let smaller = aRange\n    let end = 0\n    if (aRange.start + aRange.offset < bRange.start) {\n      end = Math.min(aRange.end, bRange.start - 1 - aRange.offset)\n    } else {\n      smaller = bRange\n      end = Math.min(bRange.end, aRange.start - 1 + aRange.offset)\n    }\n    result = { start: smaller.start, end, offset: smaller.offset }\n    smaller.start = end + 1\n  }\n  return result\n}\n")),r.createElement(n.pre,null,r.createElement(n.code,{className:"language-csharp"},"public override object PartOne()\n{\n    var (seeds, reduced) = ParseAndReduce();\n\n    return seeds.Min(seed =>\n    {\n        foreach (var range in reduced)\n        {\n            if (range.Start <= seed && range.End >= seed)\n                return seed + range.Offset;\n        }\n        return seed;\n    });\n}\n\nprivate (List<long> Seeds, List<OffsetRange>) ParseAndReduce()\n{\n    var seeds = Input[0].Split(' ')[1..].Select(x => long.Parse(x)).ToList();\n    List<OffsetRange> reduced = [];\n    List<OffsetRange> next = [];\n\n    for (int i = 3; i < Input.Length; i++)\n    {\n        var line = Input[i];\n        if (string.IsNullOrEmpty(line))\n        {\n            i++;\n            reduced = reduced.Count == 0 ? next : Merge(reduced, next);\n            next = [];\n        }\n        else\n        {\n            var split = line.Split(' ', StringSplitOptions.RemoveEmptyEntries).Select(x => long.Parse(x)).ToList();\n            next.Add(new(split[1], split[2] + split[1] - 1, split[0] - split[1]));\n        }\n    }\n    return (seeds, Merge(reduced, next));\n}\n\nprivate static List<OffsetRange> Merge(List<OffsetRange> a, List<OffsetRange> b)\n{\n    List<OffsetRange> result = [];\n    Queue<OffsetRange> sortedA = new(a.OrderBy(x => x.Start + x.Offset));\n    Queue<OffsetRange> sortedB = new(b.OrderBy(x => x.Start));\n    var aRange = sortedA.Dequeue();\n    var bRange = sortedB.Dequeue();\n\n    while (aRange != null && bRange != null)\n    {\n        result.Add(MergeRanges(aRange, bRange));\n\n        if (aRange.End < aRange.Start)\n            aRange = sortedA.Count > 0 ? sortedA.Dequeue() : null;\n\n        if (bRange.End < bRange.Start)\n            bRange = sortedB.Count > 0 ? sortedB.Dequeue() : null;\n    }\n\n    return [.. result, .. sortedB, .. sortedA];\n}\n\nprivate static OffsetRange MergeRanges(OffsetRange a, OffsetRange b)\n{\n    OffsetRange result;\n    if (a.Start + a.Offset == b.Start)\n    {\n        var end = Math.Min(a.End + a.Offset, b.End);\n        result = new(a.Start, end - a.Offset, a.Offset + b.Offset);\n        a.Start = end - a.Offset + 1;\n        b.Start = end + 1;\n    }\n    else\n    {\n        var smaller = a;\n        long end;\n        if (a.Start + a.Offset < b.Start)\n        {\n            end = Math.Min(a.End, b.Start - 1 - a.Offset);\n        }\n        else\n        {\n            smaller = b;\n            end = Math.Min(b.End, a.Start - 1 + a.Offset);\n        }\n        result = new(smaller.Start, end, smaller.Offset);\n        smaller.Start = end + 1;\n    }\n    return result;\n}\n\ninternal class OffsetRange(long start, long end, long offset)\n{\n    internal long Start = start;\n    internal long End = end;\n    internal long Offset = offset;\n}\n"))),"\n",r.createElement(n.h2,null,"Part Two"),"\n",r.createElement(n.p,null,"A simple approach here: After all the parsing and reducing maps of part one, all that is needed is to sort seed ranges by smallest to largest, and for each of those seed ranges in turn check for an overlap with any map range. The first we find is guaranteed to be the smallest possible"),"\n",r.createElement(t,{names:"typescript|C#"},r.createElement(n.pre,null,r.createElement(n.code,{className:"language-ts"},"export function partTwo(input: string[]): number | string {\n  const { seeds, reduced } = parseAndReduce(input)\n  reduced.sort((x, y) => x.start + x.offset - (y.start + y.offset))\n  const seedRanges = seeds\n    .slice(1)\n    .map((seed, index) => ({\n      start: seeds[index],\n      end: seeds[index] + seed - 1,\n    }))\n    .filter((x, i) => i % 2 == 0)\n    .toSorted((x, y) => x.start - y.start)\n\n  for (const range of reduced) {\n    for (const seedRange of seedRanges) {\n      if (seedRange.start >= range.start && seedRange.start <= range.end)\n        return seedRange.start + range.offset\n      if (seedRange.start <= range.start && seedRange.end >= range.start)\n        return range.start + range.offset\n    }\n  }\n  return 'Not Found'\n}\n")),r.createElement(n.pre,null,r.createElement(n.code,{className:"language-csharp"},"public override object PartTwo()\n{\n    var (seeds, reduced) = ParseAndReduce();\n    var sorted = reduced.ToArray().OrderBy(x => x.Start + x.Offset);\n    var seedRanges = seeds[1..].Select((x, index) => (start: seeds[index], end: seeds[index] + x - 1))\n                               .Where((x, i) => i % 2 == 0)\n                               .OrderBy(x => x.start)\n                               .ToList();\n\n    foreach (var range in sorted)\n    {\n        foreach (var seed in seedRanges)\n        {\n            var minimumOverlap = MinimumOverlap(range, seed);\n            if (minimumOverlap != -1)\n                return minimumOverlap + range.Offset;\n        }\n    }\n    return -1;\n\n    static long MinimumOverlap(OffsetRange a, (long start, long end) seed)\n    {\n        if (seed.start >= a.Start && seed.start <= a.End)\n            return seed.start;\n        if (seed.start <= a.Start && seed.end >= a.Start)\n            return a.Start;\n\n        return -1;\n    }\n}\n"))))}var l=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,a.RP)(),e.components);return n?r.createElement(n,e,r.createElement(s,e)):s(e)};var d=t(2779),i=t(7206),o=t(791),f=t(4813),g=t(572);const u={CodeBox:d.A};function c(e){let{pageContext:n,children:t}=e;return r.createElement(r.Fragment,null,r.createElement(f.A,null),r.createElement("div",{className:"min-h-screen bg-chicPrimary"},r.createElement(o.A,{props:n.list}),r.createElement("div",{className:"adventofcode max-w-[60%] ml-[20%]"},r.createElement("h1",null,r.createElement("a",{href:"https://adventofcode.com/"+n.year+"/day/"+n.puzz},n.year+" Day "+n.puzz+" - "+n.title)),r.createElement(a.xA,{components:u},t),n.puzz&&n.year?r.createElement(i.A,{year:n.year,puzz:n.puzz}):r.createElement(r.Fragment,null))),r.createElement(g.A,null))}function m(e){return r.createElement(c,e,r.createElement(l,e))}const p=()=>r.createElement(r.Fragment,null,r.createElement("title",null,"Joel-Allan-NZ - Advent of Code"),r.createElement("html",{lang:"en"}),r.createElement("link",{rel:"preconnect",href:"https://fonts.googleapis.com"}),r.createElement("link",{rel:"preconnect",href:"https://fonts.gstatic.com"}),r.createElement("link",{href:"https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&family=VT323&display=swap",rel:"stylesheet"}))}}]);
//# sourceMappingURL=component---src-components-layout-tsx-content-file-path-days-2023-5-mdx-d663a9bf48619a8e39f8.js.map