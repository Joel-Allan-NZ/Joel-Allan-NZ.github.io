"use strict";(self.webpackChunkjoel_allan_nz_github_io=self.webpackChunkjoel_allan_nz_github_io||[]).push([[3048],{3928:function(n,e,t){t.r(e),t.d(e,{Head:function(){return y},default:function(){return m}});var i=t(8453),r=t(6540);function o(n){const e=Object.assign({h2:"h2",p:"p",a:"a",pre:"pre",code:"code"},(0,i.RP)(),n.components),{CodeBox:t}=e;return t||function(n,e){throw new Error("Expected "+(e?"component":"object")+" `"+n+"` to be defined: you likely forgot to import, pass, or provide it.")}("CodeBox",!0),r.createElement(r.Fragment,null,r.createElement(e.h2,null,"Part One"),"\n",r.createElement(e.p,null,"As the slopes make the input a ",r.createElement(e.a,{href:"https://en.wikipedia.org/wiki/Directed_acyclic_graph"},"DAG"),", it's possible to find a longest path with a ",r.createElement(e.a,{href:"https://en.wikipedia.org/wiki/Breadth-first_search"},"BFS"),", with only a touch of logic to handle the slippery slopes. Although I opted not to bother, it would be trivial to treat this as a weighted graph: each point where slopes meet can also be treated as a node; the spaces between them are direct (albeit not 'straight') and allow for no decision making."),"\n",r.createElement(t,{names:"typescript|C#"},r.createElement(e.pre,null,r.createElement(e.code,{className:"language-ts"},"export function partOne(input: string[]): number | string {\n  const start = [input[0].indexOf('.'), 0]\n  const end = [input[input.length - 1].indexOf('.'), input.length - 1]\n  const queue: number[][] = [start]\n  const distances = new Map<string, number>()\n  distances.set(start.join(','), 0)\n\n  while (queue.length > 0) {\n    const current = queue.shift()!\n    const neighbours = findOrthogonalNeighbours(current, input)\n    const oldDistance = distances.get(current.join(','))!\n\n    neighbours.forEach((neighbour) => {\n      const distance = distances.get(neighbour.join(','))\n      if (!distance || distance < oldDistance - 1) {\n        distances.set(neighbour.join(','), oldDistance + 1)\n        const next = handleSlopes(input, neighbour)\n        if (next[0] != current[0] || next[1] != current[1]) {\n          if (next[0] != neighbour[0] || next[1] != neighbour[1]) {\n            distances.set(next.join(','), oldDistance + 2)\n          }\n          queue.push(next)\n        }\n      }\n    })\n  }\n\n  return distances.get(end.join(','))!\n}\n\nfunction handleSlopes(input: string[], coords: number[]): number[] {\n  switch (input[coords[1]][coords[0]]) {\n    case '>':\n      return [coords[0] + 1, coords[1]]\n    case '<':\n      return [coords[0] - 1, coords[1]]\n    case '^':\n      return [coords[0], coords[1] - 1]\n    case 'v':\n      return [coords[0], coords[1] + 1]\n    default:\n      return coords\n  }\n}\n\nfunction findOrthogonalNeighbours(\n  coords: number[],\n  input: string[]\n): number[][] {\n  return [\n    [coords[0] + 1, coords[1]],\n    [coords[0] - 1, coords[1]],\n    [coords[0], coords[1] - 1],\n    [coords[0], coords[1] + 1],\n  ].filter((step) => inBounds(step, input) && input[step[1]][step[0]] != '#')\n}\n\nfunction inBounds(coords: number[], input: string[]) {\n  return (\n    coords[0] > -1 &&\n    coords[1] > -1 &&\n    coords[0] < input[0].length &&\n    coords[1] < input.length\n  )\n}\n")),r.createElement(e.pre,null,r.createElement(e.code,{className:"language-csharp"},"public override object PartOne()\n{\n    var start = (Input[0].IndexOf('.'), 0);\n    var end = (Input[^1].IndexOf('.'), Input.Length - 1);\n    Queue<(int x, int y)> toVisit = new();\n    Dictionary<(int x, int y), int> distances = [];\n    toVisit.Enqueue(start);\n    distances[start] = 0;\n\n    while (toVisit.Count > 0)\n    {\n        var (x, y) = toVisit.Dequeue();\n        foreach (var neighbour in FindValidNeighbours([x, y], Input))\n        {\n            if (distances.TryGetValue((neighbour[0], neighbour[1]), out var dist) && dist >= distances[(x, y)] - 1)\n                continue;\n\n            distances[(neighbour[0], neighbour[1])] = distances[(x, y)] + 1;\n            var next = HandleSlopes(Input[neighbour[1]][neighbour[0]], neighbour[0], neighbour[1]);\n            if (next.x != x || next.y != y)\n            {\n                if (next.x != neighbour[0] || next.y != neighbour[1])\n                {\n                    distances[next] = distances[(x, y)] + 2;\n                }\n                toVisit.Enqueue(next);\n            }\n        }\n    }\n    return distances[end];\n}\n\nprivate static (int x, int y) HandleSlopes(char slope, int x, int y)\n{\n    return slope switch\n    {\n        '>' => (x + 1, y),\n        '<' => (x - 1, y),\n        '^' => (x, y - 1),\n        'v' => (x, y + 1),\n        _ => (x, y)\n    };\n}\n\nprivate static IEnumerable<int[]> FindValidNeighbours(int[] coord, string[] input)\n{\n    int[][] steps = [[coord[0] + 1, coord[1]], [coord[0] - 1, coord[1]], [coord[0], coord[1] + 1], [coord[0], coord[1] - 1]];\n    return steps.Where(x => InBounds(x[0], x[1], input) && input[x[1]][x[0]] != '#');\n\n    static bool InBounds(int x, int y, string[] input) => x > -1 && x < input.Length && y > -1 && y < input[0].Length;\n}\n"))),"\n",r.createElement(e.h2,null,"Part Two"),"\n",r.createElement(e.p,null,"This part was a little trickier to get to an appropriate speed!"),"\n",r.createElement("br"),"\n",r.createElement(e.p,null,"The ",r.createElement(e.a,{href:"https://en.wikipedia.org/wiki/Longest_path_problem"},"longest path problem")," states\nthis is ",r.createElement(e.a,{href:"https://en.wikipedia.org/wiki/NP-hardness"},"NP-hard"),", and to avoid cycles\nrequires remembering the path taken. It's fairly trivial to bruteforce with a ",r.createElement(e.a,{href:"https://en.wikipedia.org/wiki/Depth-first_search"},"DFS"),",\nbut that unsurprisingly has less-than-desirable speeds."),"\n",r.createElement("br"),"\n",r.createElement(e.p,null,"To simplify the problem, I processed it to the weighted graph I mentioned in part\n1, and used bitwise operations to efficiently remember nodes travelled on a path\n(which I usually avoid in these problems, for legibility). The performance was still\na little slower than my taste, and after trying half a dozen other approaches I resorted\nto checking for some community ideas. I came across one quite simple time-saver -\nthe edges between outer vertices of the graph can be treated as directed; only moving\nfrom the start towards the end. This is a property of the inputs given, rather than\na generic solution, but it cut the DFS time enough for me to pleased with the finished\nproduct."),"\n",r.createElement("br"),"\n",r.createElement(t,{names:"typescript|C#"},r.createElement(e.pre,null,r.createElement(e.code,{className:"language-ts"},"export function partTwo(input: string[]): number | string {\n  const start = [input[0].indexOf('.'), 0]\n  const end = [input.length - 1, input[input.length - 1].indexOf('.')]\n  const adjancencies = findAdjacencies(input, start, end)\n\n  return findLongest(adjancencies, 0, 0n, 0)\n}\n\nfunction findLongest(\n  nodes: Map<number, number>[],\n  current: number,\n  bitmask: bigint,\n  distance: number\n): number {\n  let max = distance\n  nodes[current].entries().forEach((child) => {\n    const big = 1n << BigInt(child[0])\n    if ((bitmask & big) == 0n) {\n      max = Math.max(\n        max,\n        findLongest(nodes, child[0], bitmask | big, distance + child[1])\n      )\n    }\n  })\n  return max\n}\n\nfunction findAdjacencies(\n  input: string[],\n  start: number[],\n  end: number[]\n): Map<number, number>[] {\n  const adjacencies: number[][] = [start, end]\n\n  input.forEach((line, y) => {\n    line.split('').forEach((c, x) => {\n      if (c == '.') {\n        const neighbours = findOrthogonalNeighbours([x, y], input).filter(\n          (x) => input[x[1]][x[0]] != '.'\n        )\n        if (neighbours.length > 2) adjacencies.push([x, y])\n      }\n    })\n  })\n\n  return connectNodes(adjacencies, input)\n}\n\nfunction connectNodes(\n  nodes: number[][],\n  input: string[]\n): Map<number, number>[] {\n  const queue: number[][] = []\n  const visited = new Set<string>()\n  const dicts: Map<number, number>[] = []\n  nodes.forEach((x) => dicts.push(new Map<number, number>()))\n\n  nodes.forEach((node) => {\n    visited.clear()\n    queue.push([...node, 0])\n\n    while (queue.length > 0) {\n      const current = queue.shift()!\n      const neighbours = findOrthogonalNeighbours(current, input)\n\n      for (let n of neighbours) {\n        if (n[0] == node[0] && n[1] == node[1]) continue\n        const index = nodes.findIndex((x) => x[0] == n[0] && x[1] == n[1])\n        if (index != -1) {\n          const existingIndex = nodes.indexOf(node)\n          let existing = dicts[existingIndex].get(index)\n          existing = Math.max(current[2] + 1, existing ?? 0)\n          dicts[existingIndex].set(index, existing)\n          dicts[index].set(existingIndex, existing)\n        } else if (!visited.has(n.join(','))) {\n          visited.add(n.join(','))\n          queue.push([...n, current[2] + 1])\n        }\n      }\n    }\n  })\n\n  communityOptimization(dicts, nodes)\n  return dicts\n}\n\nfunction communityOptimization(\n  dicts: Map<number, number>[],\n  nodes: number[][]\n): void {\n  const originalOrder = [...nodes]\n\n  const top = nodes\n    .sort((x, y) => x[1] - y[1])\n    .slice(0, 6)\n    .sort((x, y) => y[0] - x[0])\n    .map((t) => originalOrder.indexOf(t))\n\n  const bottom = nodes\n    .sort((x, y) => y[1] - x[1])\n    .slice(0, 6)\n    .sort((x, y) => y[0] - x[0])\n    .map((t) => originalOrder.indexOf(t))\n\n  const left = nodes\n    .sort((x, y) => x[0] - y[0])\n    .slice(0, 6)\n    .sort((x, y) => y[1] - x[1])\n    .map((t) => originalOrder.indexOf(t))\n  const right = nodes\n    .sort((x, y) => y[0] - x[0])\n    .slice(0, 6)\n    .sort((x, y) => y[1] - x[1])\n    .map((t) => originalOrder.indexOf(t))\n\n  for (let i = 0; i < 5; i++) {\n    top.slice(i + 1).forEach((node) => dicts[top[i]].delete(node))\n    bottom.slice(i + 1).forEach((node) => dicts[bottom[i]].delete(node))\n    left.slice(i + 1).forEach((node) => dicts[left[i]].delete(node))\n    right.slice(i + 1).forEach((node) => dicts[right[i]].delete(node))\n  }\n}\n")),r.createElement(e.pre,null,r.createElement(e.code,{className:"language-csharp"},"public override object PartTwo()\n{\n    var adjacencies = FindAdjacencies(Input);\n    var compressed = FindAdjacentDecisionsPoints(adjacencies, Input);\n\n    return FindLongest(compressed, 0, 0, 0);\n}\n\nprivate static int FindLongest(Dictionary<int, int>[] nodes, int current, long bitmask, int distance)\n{\n    var max = distance;\n    foreach (var child in nodes[current])\n    {\n        if ((bitmask & (1L << child.Key)) == 0)\n            max = Math.Max(max, FindLongest(nodes, child.Key, (bitmask | (1L << child.Key)), distance + child.Value));\n    }\n    return max;\n}\n\nprivate static Dictionary<(int x, int y), Dictionary<(int x, int y), int>> FindAdjacencies(string[] input)\n{\n    Dictionary<(int x, int y), Dictionary<(int x, int y), int>> adjacencies = [];\n    adjacencies.Add((x: input[0].IndexOf('.'), y: 0), []);\n    adjacencies.Add((x: input[^1].IndexOf('.'), y: input.Length - 1), []);\n\n    for (int y = 0; y < input.Length; y++)\n    {\n        for (int x = 0; x < input[0].Length; x++)\n        {\n            if (input[y][x] == '.' && FindValidNeighbours([x, y], input).Count(x => input[x[1]][x[0]] != '.') > 2)\n            {\n                adjacencies.Add((x, y), []);\n            }\n        }\n    }\n\n    return adjacencies;\n}\n\nprivate static Dictionary<int, int>[] FindAdjacentDecisionsPoints(Dictionary<(int x, int y), Dictionary<(int x, int y), int>> adjacencies, string[] input)\n{\n    Queue<(int x, int y, int distance)> toVisit = new();\n    HashSet<(int x, int y)> visited = [];\n    foreach (var adjacency in adjacencies.Keys)\n    {\n        visited.Clear();\n        toVisit.Enqueue((adjacency.x, adjacency.y, 0));\n        while (toVisit.Count > 0)\n        {\n            var (x, y, distance) = toVisit.Dequeue();\n            foreach (var neighbour in FindValidNeighbours([x, y], input))\n            {\n                var tuple = (neighbour[0], neighbour[1]);\n                if (adjacency.x == neighbour[0] && adjacency.y == neighbour[1] || visited.Contains(tuple))\n                    continue;\n\n                if (adjacencies.ContainsKey(tuple))\n                {\n                    if (!adjacencies[adjacency].TryGetValue(tuple, out int value) || value < distance + 1)\n                        adjacencies[adjacency][tuple] = distance + 1;\n                }\n                else if (!visited.Contains(tuple))\n                {\n                    toVisit.Enqueue((neighbour[0], neighbour[1], distance + 1));\n                }\n\n                visited.Add(tuple);\n            }\n        }\n    }\n\n    CommunityOptimization(adjacencies);\n    return Simplify(adjacencies);\n}\n\nprivate static Dictionary<int, int>[] Simplify(Dictionary<(int x, int y), Dictionary<(int x, int y), int>> adjacencies)\n{\n    List<(int x, int y)> keys = [.. adjacencies.Keys];\n    Dictionary<int, int>[] adj = new Dictionary<int, int>[keys.Count];\n\n    foreach (var kvp in adjacencies)\n    {\n        var index = keys.IndexOf(kvp.Key);\n        adj[index] = [];\n\n        foreach (var kvp2 in kvp.Value)\n        {\n            var i = keys.IndexOf(kvp2.Key);\n            adj[index].Add(i, kvp2.Value);\n        }\n    }\n    return adj;\n}\n\nprivate static void CommunityOptimization(Dictionary<(int x, int y), Dictionary<(int x, int y), int>> adjacencies)\n{\n    var top = adjacencies.OrderBy(x => x.Key.y).Take(6).OrderByDescending(y => y.Key.x).ToList();\n    var bottom = adjacencies.OrderByDescending(x => x.Key.y).Take(6).OrderByDescending(y => y.Key.x).ToList();\n    var left = adjacencies.OrderBy(x => x.Key.x).Take(6).OrderByDescending(y => y.Key.y).ToList();\n    var right = adjacencies.OrderByDescending(x => x.Key.x).Take(6).OrderByDescending(y => y.Key.y).ToList();\n\n    for (int i = 0; i < 5; i++)\n    {\n        top[(i + 1)..].ForEach(x => top[i].Value.Remove(x.Key));\n        bottom[(i + 1)..].ForEach(x => bottom[i].Value.Remove(x.Key));\n        left[(i + 1)..].ForEach(x => left[i].Value.Remove(x.Key));\n        right[(i + 1)..].ForEach(x => right[i].Value.Remove(x.Key));\n    }\n}\n"))))}var a=function(n){void 0===n&&(n={});const{wrapper:e}=Object.assign({},(0,i.RP)(),n.components);return e?r.createElement(e,n,r.createElement(o,n)):o(n)};var s=t(2779),c=t(7206),d=t(791),u=t(4813),l=t(572);const p={CodeBox:s.A};function h(n){let{pageContext:e,children:t}=n;return r.createElement(r.Fragment,null,r.createElement(u.A,null),r.createElement("div",{className:"min-h-screen bg-chicPrimary"},r.createElement(d.A,{props:e.list}),r.createElement("div",{className:"adventofcode max-w-[60%] ml-[20%]"},r.createElement("h1",null,r.createElement("a",{href:"https://adventofcode.com/"+e.year+"/day/"+e.puzz},e.year+" Day "+e.puzz+" - "+e.title)),r.createElement(i.xA,{components:p},t),e.puzz&&e.year?r.createElement(c.A,{year:e.year,puzz:e.puzz}):r.createElement(r.Fragment,null))),r.createElement(l.A,null))}function m(n){return r.createElement(h,n,r.createElement(a,n))}const y=()=>r.createElement(r.Fragment,null,r.createElement("title",null,"Joel-Allan-NZ - Advent of Code"),r.createElement("html",{lang:"en"}),r.createElement("link",{rel:"preconnect",href:"https://fonts.googleapis.com"}),r.createElement("link",{rel:"preconnect",href:"https://fonts.gstatic.com"}),r.createElement("link",{href:"https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&family=VT323&display=swap",rel:"stylesheet"}))}}]);
//# sourceMappingURL=component---src-components-layout-tsx-content-file-path-days-2023-23-mdx-9295ac0029e952f85d32.js.map