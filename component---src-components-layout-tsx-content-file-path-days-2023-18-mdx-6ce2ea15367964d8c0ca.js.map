{"version":3,"file":"component---src-components-layout-tsx-content-file-path-days-2023-18-mdx-6ce2ea15367964d8c0ca.js","mappings":"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","sources":["webpack://joel-allan-nz.github.io/./days/2023/18.mdx","webpack://joel-allan-nz.github.io/./src/components/Layout.tsx"],"sourcesContent":["/*@jsxRuntime classic @jsx React.createElement @jsxFrag React.Fragment*/\nimport {useMDXComponents as _provideComponents} from \"@mdx-js/react\";\nimport React from \"react\";\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    p: \"p\",\n    a: \"a\",\n    pre: \"pre\",\n    code: \"code\"\n  }, _provideComponents(), props.components), {CodeBox} = _components;\n  if (!CodeBox) _missingMdxReference(\"CodeBox\", true);\n  return React.createElement(React.Fragment, null, React.createElement(_components.h2, null, \"Part One\"), \"\\n\", React.createElement(_components.p, null, \"Geometry time!\"), \"\\n\", React.createElement(\"br\"), \"\\n\", React.createElement(_components.p, null, \"The input is well-structured with no back-tracking, so I was able to trivially build\\na list of vertex coordinates by recording the current position after each instruction.\\nWith a list of sequential corner coordinates, it's simple (and very speedy) to build\\na total area for a polygon using \", React.createElement(_components.a, {\n    href: \"https://en.wikipedia.org/wiki/Shoelace_formula\"\n  }, \"Gauss' area formula\"), \",\\nalso known as the shoelace formula.\"), \"\\n\", React.createElement(\"br\"), \"\\n\", React.createElement(_components.p, null, \"But that alone won't get you a correct answer, as we're working in a manhattan distance\\ncoordinate system that includes the perimeter! To get the total inclusive area you\\nalso need to add half of the total perimeter of the polygon, and an additional +1.\", ' '), \"\\n\", React.createElement(CodeBox, {\n    names: \"typescript|C#\"\n  }, React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-ts\"\n  }, \"export function partOne(input: string[]): number | string {\\n  const corners = digTrenches(input)\\n\\n  return gaussArea(corners) + calculatePerimeter(corners) / 2 + 1\\n}\\n\\nfunction digTrenches(input: string[]): number[][] {\\n  let x = 0,\\n    y = 0\\n  const corners: number[][] = []\\n\\n  for (let line of input) {\\n    const split = line.split(' ')\\n    const distance = parseInt(split[1])\\n    corners.push([x, y])\\n\\n    x = split[0] == 'R' ? x + distance : split[0] == 'L' ? x - distance : x\\n    y = split[0] == 'D' ? y + distance : split[0] == 'U' ? y - distance : y\\n  }\\n  return corners\\n}\\n\\nfunction gaussArea(corners: number[][]): number {\\n  const total = corners\\n    .map((corner, index) =>\\n      index == corners.length - 1\\n        ? [corner, corners[0]]\\n        : [corner, corners[index + 1]]\\n    )\\n    .reduce(\\n      (total, pair) =>\\n        total + pair[0][0] * pair[1][1] - pair[1][0] * pair[0][1],\\n      0\\n    )\\n\\n  return 0.5 * Math.abs(total)\\n}\\n\\nfunction calculatePerimeter(corners: number[][]) {\\n  return corners\\n    .map((corner, index) =>\\n      index == corners.length - 1\\n        ? [corner, corners[0]]\\n        : [corner, corners[index + 1]]\\n    )\\n    .reduce(\\n      (total, pair) =>\\n        total +\\n        Math.abs(pair[0][0] - pair[1][0]) +\\n        Math.abs(pair[0][1] - pair[1][1]),\\n      0\\n    )\\n}\\n\")), React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-csharp\"\n  }, \"public override object PartOne()\\n{\\n    var corners = DigTrenches(Input);\\n    var totalPerimeter = CalculateLength(corners);\\n\\n    return GaussArea(corners) + totalPerimeter / 2 + 1;\\n}\\n\\nprivate static long CalculateLength(List<long[]> corners)\\n{\\n    return corners.Zip([.. corners[1..], corners[0]])\\n                  .Sum(line => Math.Abs(line.First[0] - line.Second[0]) + Math.Abs(line.Second[1] - line.First[1]));\\n}\\n\\nprivate static List<long[]> DigTrenches(IEnumerable<string> input)\\n{\\n    int x = 0, y = 0;\\n    List<long[]> corners = [];\\n\\n    foreach (var line in input)\\n    {\\n        var split = line.Split(' ');\\n        var distance = int.Parse(split[1]);\\n        corners.Add([x, y]);\\n\\n        x = split[0] == \\\"R\\\" ? x + distance : split[0] == \\\"L\\\" ? x - distance : x;\\n        y = split[0] == \\\"D\\\" ? y + distance : split[0] == \\\"U\\\" ? y - distance : y;\\n    }\\n\\n    return corners;\\n}\\n\\nprivate static long GaussArea(List<long[]> corners)\\n{\\n    var total = corners.Zip([.. corners[1..], corners[0]])\\n                       .Sum((pair) => (pair.First[0] * pair.Second[1]) - (pair.Second[0] * pair.First[1]));\\n\\n    return (long)(Math.Abs(total) * 0.5);\\n}\\n\"))), \"\\n\", React.createElement(_components.h2, null, \"Part Two\"), \"\\n\", React.createElement(_components.p, null, \"Well, that's not at all what I expected from the hexcodes in the input. A bit of quick input parsing and we can run an identical algorithm to part one (albeit with much larger input distances). Our mathematical approach handles this with no issue; increasing the size of the sides of the polygon does nothing to increase big O complexity.\"), \"\\n\", React.createElement(CodeBox, {\n    names: \"typescript|C#\"\n  }, React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-ts\"\n  }, \"export function partTwo(input: string[]): number | string {\\n  var directions = ['R', 'D', 'L', 'U']\\n  const parsedInput = input.map((line) => {\\n    var split = line.split(' ')\\n    var direction = directions[parseInt(split[2][split[2].length - 2])]\\n    return `${direction} ${parseInt(split[2].slice(2, -2), 16)}`\\n  })\\n\\n  const corners = digTrenches(parsedInput)\\n\\n  return gaussArea(corners) + calculatePerimeter(corners) / 2 + 1\\n}\\n\")), React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-csharp\"\n  }, \"public override object PartTwo()\\n{\\n    Dictionary<long, List<long>> positions = [];\\n\\n    var parsedInput = Input.Select(line =>\\n    {\\n        var direction = line[^2] switch\\n        {\\n            '0' => 'R',\\n            '1' => 'D',\\n            '2' => 'L',\\n            _ => 'U'\\n        };\\n        return $\\\"{direction} {int.Parse(line.Split(' ')[2][2..^2], System.Globalization.NumberStyles.HexNumber)}\\\";\\n    });\\n\\n    var corners = DigTrenches(parsedInput);\\n    var totalPerimeter = CalculateLength(corners);\\n\\n    return GaussArea(corners) + totalPerimeter / 2 + 1;\\n}\\n\"))));\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? React.createElement(MDXLayout, props, React.createElement(_createMdxContent, props)) : _createMdxContent(props);\n}\nexport default MDXContent;\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","import GATSBY_COMPILED_MDX from \"/home/joel/personal/advent-of-code/joel-allan-nz.github.io/days/2023/18.mdx\";\nimport React from 'react';\nimport {MDXProvider} from '@mdx-js/react';\nimport CodeBox from './CodeBox';\nimport TryYourself from './TryYourself';\nimport AdventSideNav from './AdventSideNav';\nimport Header from './Header';\nimport Footer from './Footer';\nconst shortcodes = {\n  CodeBox\n};\nfunction Layout(_ref) {\n  let {pageContext, children} = _ref;\n  return React.createElement(React.Fragment, null, React.createElement(Header, null), React.createElement(\"div\", {\n    className: \"min-h-screen bg-chicPrimary\"\n  }, React.createElement(AdventSideNav, {\n    props: pageContext.list\n  }), React.createElement(\"div\", {\n    className: \"adventofcode max-w-[60%] ml-[20%]\"\n  }, React.createElement(\"h1\", null, React.createElement(\"a\", {\n    href: \"https://adventofcode.com/\" + pageContext.year + \"/day/\" + pageContext.puzz\n  }, pageContext.year + \" Day \" + pageContext.puzz + \" - \" + pageContext.title)), React.createElement(MDXProvider, {\n    components: shortcodes\n  }, children), pageContext.puzz && pageContext.year ? React.createElement(TryYourself, {\n    year: pageContext.year,\n    puzz: pageContext.puzz\n  }) : React.createElement(React.Fragment, null))), React.createElement(Footer, null));\n}\nexport default function GatsbyMDXWrapper(props) {\n  return React.createElement(Layout, props, React.createElement(GATSBY_COMPILED_MDX, props));\n}\nexport const Head = () => React.createElement(React.Fragment, null, React.createElement(\"title\", null, \"Joel-Allan-NZ - Advent of Code\"), React.createElement(\"html\", {\n  lang: \"en\"\n}), React.createElement(\"link\", {\n  rel: \"preconnect\",\n  href: \"https://fonts.googleapis.com\"\n}), React.createElement(\"link\", {\n  rel: \"preconnect\",\n  href: \"https://fonts.gstatic.com\"\n}), React.createElement(\"link\", {\n  href: \"https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&family=VT323&display=swap\",\n  rel: \"stylesheet\"\n}));\n"],"names":["_createMdxContent","props","_components","Object","assign","h2","p","a","pre","code","_provideComponents","components","CodeBox","id","component","Error","_missingMdxReference","React","href","names","className","wrapper","MDXLayout","shortcodes","Layout","_ref","pageContext","children","Header","AdventSideNav","list","year","puzz","title","MDXProvider","TryYourself","Footer","GatsbyMDXWrapper","GATSBY_COMPILED_MDX","Head","lang","rel"],"sourceRoot":""}