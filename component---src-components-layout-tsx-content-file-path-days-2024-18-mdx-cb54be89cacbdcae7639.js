"use strict";(self.webpackChunkjoel_allan_nz_github_io=self.webpackChunkjoel_allan_nz_github_io||[]).push([[6831],{5132:function(e,n,t){t.r(n),t.d(n,{Head:function(){return g},default:function(){return m}});var r=t(8453),o=t(6540);function i(e){const n=Object.assign({h2:"h2",p:"p",pre:"pre",code:"code"},(0,r.RP)(),e.components),{CodeBox:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("CodeBox",!0),o.createElement(o.Fragment,null,o.createElement(n.h2,null,"Part One"),"\n",o.createElement(n.p,null,"Veeery simple stuff here for this late into the year."),"\n",o.createElement("br"),"\n",o.createElement(n.p,null,"Pick your poison of path finding; they should all perform adequately in this small\ngrid size... which means part 2 will probably be tricksy."),"\n",o.createElement(t,{boxname:"one",names:"typescript|C#"},o.createElement(n.pre,null,o.createElement(n.code,{className:"language-js"},"export function partOne(input: string[]): number | string {\n  const graph = parse(input)\n  const start = graph.get(0)?.get(0)!\n  const end = graph.get(70)?.get(70)!\n  return findShortestExitDistance(graph, start, end)\n}\n\ninterface CoordAwareNode {\n  X: number\n  Y: number\n  Value: string\n  Edges: CoordAwareNode[]\n}\n\nfunction parse(input: string[]): Map<number, Map<number, CoordAwareNode>> {\n  const graph = new Map<number, Map<number, CoordAwareNode>>()\n\n  for (let y = 0; y < 71; y++) {\n    for (let x = 0; x < 71; x++) {\n      const node: CoordAwareNode = { X: x, Y: y, Value: '.', Edges: [] }\n      if (!graph.has(y)) graph.set(y, new Map<number, CoordAwareNode>())\n      graph.get(y)?.set(x, node)\n      const neighbours = [graph.get(y - 1)?.get(x), graph.get(y)?.get(x - 1)]\n      neighbours.forEach((neighbour) => {\n        if (neighbour) {\n          neighbour.Edges.push(node)\n          node.Edges.push(neighbour)\n        }\n      })\n    }\n  }\n  for (let i = 0; i < 1024; i++) {\n    let coords = input[i].split(/,/).map((x) => parseInt(x))\n    graph.get(coords[1])!.get(coords[0])!.Value = '#'\n  }\n  return graph\n}\n\nfunction findShortestExitDistance(\n  graph: Map<number, Map<number, CoordAwareNode>>,\n  start: CoordAwareNode,\n  end: CoordAwareNode\n): number {\n  const minimumDistances = new Map<CoordAwareNode, number>([\n    [end, 2 ** 31],\n    [start, 0],\n  ])\n  const toExplore = [start]\n\n  while (toExplore.length > 0) {\n    const node = toExplore.shift()!\n    const distance = minimumDistances.get(node)!\n\n    if (node == end) return distance\n\n    const possibleMin = minimumDistances.get(node)\n    if (possibleMin && possibleMin < distance) continue\n\n    node.Edges.forEach((node) => {\n      if (node.Value != '#') {\n        const nodeDistance = minimumDistances.get(node)\n        if (!nodeDistance || nodeDistance > distance + 1) {\n          minimumDistances.set(node, distance + 1)\n          toExplore.push(node)\n        }\n      }\n    })\n  }\n  return minimumDistances.get(end)!\n}\n")),o.createElement(n.pre,null,o.createElement(n.code,{className:"language-csharp"},"public override object PartOne()\n{\n    var graph = Parse();\n    var start = graph[(0, 0)];\n    var end = graph[(70, 70)];\n    return FindShortestExit(graph, start, end);\n}\n\nprivate static int FindShortestExit(Dictionary<(int x, int y), CoordAwareNode> graph, CoordAwareNode start, CoordAwareNode end)\n{\n    Dictionary<CoordAwareNode, int> minimumDistances = [];\n    minimumDistances[end] = int.MaxValue;\n    minimumDistances[start] = 0;\n\n    Queue<CoordAwareNode> toExplore = [];\n    toExplore.Enqueue(start);\n\n    while (toExplore.Count > 0)\n    {\n        var node = toExplore.Dequeue();\n        var distance = minimumDistances[node];\n        if (node == end)\n            return minimumDistances[end];\n        if (minimumDistances.TryGetValue(node, out var minimumDistance) && minimumDistance < distance)\n            continue;\n\n        foreach (var edge in node.Edges)\n        {\n            if (edge.Value != '#')\n            {\n                if (minimumDistances.TryGetValue(edge, out var edgeDistance) && edgeDistance <= distance + 1)\n                    continue;\n\n                minimumDistances[edge] = distance + 1;\n                toExplore.Enqueue(edge);\n            }\n        }\n    }\n    return minimumDistances[end];\n}\n\nprivate Dictionary<(int x, int y), CoordAwareNode> Parse()\n{\n    Dictionary<(int x, int y), CoordAwareNode> graph = [];\n\n    for (int y = 0; y < 71; y++)\n    {\n        for (int x = 0; x < 71; x++)\n        {\n            CoordAwareNode node = new(x, y, '.');\n            graph.Add((x, y), node);\n            if (graph.TryGetValue((x - 1, y), out var neighbour))\n            {\n                neighbour.Edges.Add(node);\n                node.Edges.Add(neighbour);\n            }\n            if (graph.TryGetValue((x, y - 1), out neighbour))\n            {\n                neighbour.Edges.Add(node);\n                node.Edges.Add(neighbour);\n            }\n        }\n    }\n\n    for (int i = 0; i < 1024; i++)\n    {\n        var byteCoords = Input[i].Split(',').Select(x => int.Parse(x)).ToArray();\n        graph[(byteCoords[1], byteCoords[0])].Value = '#';\n    }\n\n    return graph;\n}\n\ninternal class CoordAwareNode(int x, int y, char c)\n{\n    internal int X = x;\n    internal int Y = y;\n    internal char Value = c;\n    internal List<CoordAwareNode> Edges = [];\n}\n"))),"\n",o.createElement(n.h2,null,"Part Two"),"\n",o.createElement(n.p,null,"Well, my predictions of being tricksy were inaccurate. You could use your part one solution, updating the graph until the path-finding fails to complete... but the performance wouldn't be wonderful."),"\n",o.createElement(n.p,null,o.createElement("br"),"I opted for A* with a very simple heurisitic for the priority: consider\nnodes closest (by manhattan distance) to the end first. I also decided to\nremember which nodes had been visited while finding that valid path, and only\nrecheck for a valid path when one was modified by a line of the input."),"\n",o.createElement(t,{boxname:"two",names:"typescript|C#"},o.createElement(n.pre,null,o.createElement(n.code,{className:"language-js"},"export function partTwo(input: string[]): number | string {\n  const graph = parse(input)\n  const start = graph.get(0)?.get(0)!\n  const end = graph.get(70)?.get(70)!\n  const visitedNodes = new Set<CoordAwareNode>()\n\n  for (let i = 1024; i < input.length; i++) {\n    let coords = input[i].split(/,/).map((x) => parseInt(x))\n    graph.get(coords[1])!.get(coords[0])!.Value! = '#'\n\n    if (\n      visitedNodes.size == 0 ||\n      visitedNodes.has(graph.get(coords[1])!.get(coords[0])!)\n    ) {\n      if (!hasPossiblePath(graph, start, end, visitedNodes))\n        return `${coords[0]},${coords[1]}`\n    }\n  }\n  return 'Can still find a path.'\n}\n\nfunction hasPossiblePath(\n  graph: Map<number, Map<number, CoordAwareNode>>,\n  start: CoordAwareNode,\n  end: CoordAwareNode,\n  visited: Set<CoordAwareNode>\n): boolean {\n  const priority = new Map<number, CoordAwareNode[]>()\n  visited.clear()\n  visited.add(start)\n  addPriorityNode(priority, start)\n  while (priority.size > 0) {\n    let current = getPriorityNode(priority)\n    if (current == end) return true\n\n    current.Edges.forEach((neighbour) => {\n      if (neighbour.Value != '#' && !visited.has(neighbour)) {\n        visited.add(neighbour)\n        addPriorityNode(priority, neighbour)\n      }\n    })\n  }\n  return false\n}\n\nfunction addPriorityNode(\n  priority: Map<number, CoordAwareNode[]>,\n  node: CoordAwareNode\n) {\n  const distance = 140 - node.X - node.Y\n\n  if (!priority.has(distance)) priority.set(distance, [node])\n  else priority.get(distance)?.push(node)\n}\n\nfunction getPriorityNode(\n  priority: Map<number, CoordAwareNode[]>\n): CoordAwareNode {\n  const smallest = priority\n    .keys()\n    .reduce((min, current) => (min > current ? current : min), 2 ** 31)\n  const toReturn = priority.get(smallest)!.shift()!\n  if (priority.get(smallest)?.length == 0) {\n    priority.delete(smallest)\n  }\n  return toReturn\n}\n")),o.createElement(n.pre,null,o.createElement(n.code,{className:"language-csharp"},"public override object PartTwo()\n{\n    HashSet<CoordAwareNode> pathNodes = [];\n    var graph = Parse();\n    var start = graph[(0, 0)];\n    var end = graph[(70, 70)];\n\n    for (int i = 1024; i < Input.Length; i++)\n    {\n        var byteCoords = Input[i].Split(',').Select(x => int.Parse(x)).ToArray();\n        graph[(byteCoords[1], byteCoords[0])].Value = '#';\n\n        if (pathNodes.Count == 0 || pathNodes.Contains(graph[(byteCoords[1], byteCoords[0])]))\n        {\n            if (!HasPossiblePath(graph, start, end, out pathNodes))\n                return $\"{byteCoords[0]},{byteCoords[1]}\";\n        }\n    }\n    return -1;\n}\n\nprivate static bool HasPossiblePath(Dictionary<(int x, int y), CoordAwareNode> graph, CoordAwareNode start, CoordAwareNode end, out HashSet<CoordAwareNode> visited)\n{\n    PriorityQueue<CoordAwareNode, int> toVisit = new();\n    visited = [];\n    visited.Add(start);\n    toVisit.Enqueue(start, 0);\n\n    while (toVisit.Count > 0)\n    {\n        var current = toVisit.Dequeue();\n        if (current == end)\n            return true;\n\n        foreach (var neighbour in current.Edges)\n        {\n            if (neighbour.Value == '#' || visited.Contains(neighbour))\n                continue;\n\n            visited.Add(neighbour);\n            toVisit.Enqueue(neighbour, 140 - neighbour.X - neighbour.Y);\n        }\n    }\n    return false;\n}\n"))))}var a=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,r.RP)(),e.components);return n?o.createElement(n,e,o.createElement(i,e)):i(e)};var s=t(2779),d=t(7206),l=t(791),c=t(4813),u=t(572);const p={CodeBox:s.A};function h(e){let{pageContext:n,children:t}=e;return o.createElement(o.Fragment,null,o.createElement(c.A,null),o.createElement("div",{className:"min-h-screen bg-chicPrimary"},o.createElement(l.A,{props:n.list}),o.createElement("div",{className:"adventofcode max-w-[60%] ml-[20%]"},o.createElement("h1",null,o.createElement("a",{href:"https://adventofcode.com/"+n.year+"/day/"+n.puzz},n.year+" Day "+n.puzz+" - "+n.title)),o.createElement(r.xA,{components:p},t),n.puzz&&n.year?o.createElement(d.A,{year:n.year,puzz:n.puzz}):o.createElement(o.Fragment,null))),o.createElement(u.A,null))}function m(e){return o.createElement(h,e,o.createElement(a,e))}const g=()=>o.createElement(o.Fragment,null,o.createElement("title",null,"Joel-Allan-NZ - Advent of Code"),o.createElement("html",{lang:"en"}),o.createElement("link",{rel:"preconnect",href:"https://fonts.googleapis.com"}),o.createElement("link",{rel:"preconnect",href:"https://fonts.gstatic.com"}),o.createElement("link",{href:"https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&family=VT323&display=swap",rel:"stylesheet"}))}}]);
//# sourceMappingURL=component---src-components-layout-tsx-content-file-path-days-2024-18-mdx-cb54be89cacbdcae7639.js.map