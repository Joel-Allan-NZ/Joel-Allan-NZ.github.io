{"version":3,"file":"component---src-components-layout-tsx-content-file-path-days-2023-7-mdx-477606978efaad4ac464.js","mappings":"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","sources":["webpack://joel-allan-nz.github.io/./days/2023/7.mdx","webpack://joel-allan-nz.github.io/./src/components/Layout.tsx"],"sourcesContent":["/*@jsxRuntime classic @jsx React.createElement @jsxFrag React.Fragment*/\nimport {useMDXComponents as _provideComponents} from \"@mdx-js/react\";\nimport React from \"react\";\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    p: \"p\",\n    pre: \"pre\",\n    code: \"code\"\n  }, _provideComponents(), props.components), {CodeBox} = _components;\n  if (!CodeBox) _missingMdxReference(\"CodeBox\", true);\n  return React.createElement(React.Fragment, null, React.createElement(_components.h2, null, \"Part One\"), \"\\n\", React.createElement(_components.p, null, \"Cards Time.\"), \"\\n\", React.createElement(\"br\"), \"\\n\", React.createElement(_components.p, null, \"We need to be able to identify hand values, and also compare hands of the same type.\\nNot too much to think about here, just diligence in making sure we evaluate hands\\ncorrectly.\"), \"\\n\", React.createElement(_components.p, null, \"I opted to compute the hand values before sorting to avoid recalculating each hand value when compared. There's some bleed over from part 2 in this solution, but it didn't make sense to duplicate the entirety of the process.\"), \"\\n\", React.createElement(CodeBox, {\n    names: \"typescript|C#\"\n  }, React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-js\"\n  }, \"export function partOne(input: string[]): number | string {\\n  const hands = input.map((x) => {\\n    let matches = x.split(' ')\\n    return {\\n      cards: matches[0],\\n      handValue: findHandType(matches[0], false),\\n      bid: parseInt(matches[1]),\\n    }\\n  })\\n  console.log(hands)\\n  hands.sort((x, y) => compareHandValue(x, y, false))\\n  return hands.reduce((total, hand, index) => hand.bid * (index + 1) + total, 0)\\n}\\n\\ninterface CamelCardHand {\\n  cards: string\\n  handValue: number\\n  bid: number\\n}\\n\\nfunction compareHandValue(\\n  x: CamelCardHand,\\n  y: CamelCardHand,\\n  joker: boolean\\n): number {\\n  if (x.handValue != y.handValue) return x.handValue - y.handValue\\n\\n  for (let i = 0; i < x.cards.length; i++) {\\n    if (x.cards[i] != y.cards[i])\\n      return cardValue(x.cards[i], joker) - cardValue(y.cards[i], joker)\\n  }\\n  return 0\\n}\\n\\nfunction cardValue(card: string, joker: boolean): number {\\n  switch (card) {\\n    case 'A':\\n      return 14\\n    case 'K':\\n      return 13\\n    case 'Q':\\n      return 12\\n    case 'J':\\n      return joker ? 0 : 11\\n    case 'T':\\n      return 10\\n    default:\\n      return parseInt(card)\\n  }\\n}\\n\\nfunction findHandType(hand: string, joker: boolean): number {\\n  const counted = new Map<string, number>()\\n  let max = 1\\n  hand.split('').forEach((c) => {\\n    let d = counted.get(c)\\n    if (d) {\\n      counted.set(c, d + 1)\\n      max = d + 1 > max ? d + 1 : max\\n    } else counted.set(c, 1)\\n  })\\n\\n  if (joker && counted.get('J'))\\n    return findHandTypeJoker(counted.size, max, counted.get('J')!)\\n\\n  switch (counted.size) {\\n    case 1:\\n      return 7\\n    case 2:\\n      return counted.values().find((x) => x == 2 || x == 3) ? 5 : 6\\n    case 3:\\n      return max == 3 ? 4 : 3\\n    case 4:\\n      return 2\\n    default:\\n      return 1\\n  }\\n}\\n\")), React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-csharp\"\n  }, \"public override object PartOne()\\n{\\n    var comparer = new CamelHandComparer();\\n    List<(string hand, int bid, HandType handType)> hands = [.. Input.Select(x => x.Split(' ', StringSplitOptions.RemoveEmptyEntries))\\n                                                                     .Select(x => (hand: x[0], bid: int.Parse(x[1]), handType: FindHandType(x[0])))\\n                                                                     .Order(comparer)];\\n    long sum = 0;\\n    for (int i = 0; i < hands.Count; i++)\\n        sum += (i + 1) * hands[i].bid;\\n\\n    return sum;\\n}\\n\\npublic static HandType FindHandType(string a, bool joker = false)\\n{\\n    var counted = new Dictionary<char, int>();\\n    foreach (char ch in a)\\n    {\\n        if (counted.TryGetValue(ch, out var value))\\n            counted[ch] = value + 1;\\n        else\\n            counted.Add(ch, 1);\\n    }\\n\\n    if (joker && counted.TryGetValue('J', out var jokers))\\n        return FindHandTypeJoker(counted.Keys.Count, counted.Values.Max(), jokers);\\n\\n    return counted.Keys.Count switch\\n    {\\n        1 => HandType.FiveOfAKind,\\n        2 => counted.First().Value == 2 || counted.First().Value == 3 ? HandType.FullHouse : HandType.FourOfAKind,\\n        3 => counted.Values.Max() == 3 ? HandType.ThreeOfAKind : HandType.TwoPair,\\n        4 => HandType.OnePair,\\n        _ => HandType.HighCard\\n    };\\n}\\n\\ninternal enum HandType\\n{\\n    FiveOfAKind, FourOfAKind, FullHouse, ThreeOfAKind, TwoPair, OnePair, HighCard\\n}\\n\\ninternal class CamelHandComparer(bool joker = false) : IComparer<(string hand, int bid, HandType handType)>\\n{\\n    readonly bool Joker = joker;\\n    public int Compare((string hand, int bid, HandType handType) x, (string hand, int bid, HandType handType) y)\\n    {\\n        if (x.handType != y.handType)\\n            return y.handType - x.handType;\\n\\n        for (int i = 0; i < x.hand.Length; i++)\\n        {\\n            if (x.hand[i] == y.hand[i])\\n                continue;\\n            return CardValue(x.hand[i]) - CardValue(y.hand[i]);\\n        }\\n        return 0;\\n    }\\n\\n    private int CardValue(char c) => c switch\\n            {\\n                'A' => 14,\\n                'K' => 13,\\n                'Q' => 12,\\n                'J' => Joker ? 0 : 11,\\n                'T' => 10,\\n                _ => int.Parse(c.ToString())\\n            };\\n}\\n\"))), \"\\n\", React.createElement(_components.h2, null, \"Part Two\"), \"\\n\", React.createElement(_components.p, null, \"As the previous part of the solution no doubt suggested: we now also have jokers. A small tweak to the value of a J and how hand values are calculated are required, but nothing taxing.\"), \"\\n\", React.createElement(CodeBox, {\n    names: \"typescript|C#\"\n  }, React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-ts\"\n  }, \"export function partTwo(input: string[]): number | string {\\n  const hands = input.map((x) => {\\n    let matches = x.split(' ')\\n    return {\\n      cards: matches[0],\\n      handValue: findHandType(matches[0], true),\\n      bid: parseInt(matches[1]),\\n    }\\n  })\\n  hands.sort((x, y) => compareHandValue(x, y, true))\\n  console.log(hands)\\n  return hands.reduce((total, hand, index) => hand.bid * (index + 1) + total, 0)\\n}\\n\\nfunction findHandTypeJoker(\\n  keyCount: number,\\n  maxCount: number,\\n  jokers: number\\n): number {\\n  switch (keyCount) {\\n    case 1:\\n    case 2:\\n      return 7\\n    case 3:\\n      return jokers == 1 && maxCount < 3 ? 5 : 6\\n    case 4:\\n      return jokers == 2 || maxCount == 2 ? 4 : 2\\n    default:\\n      return 2\\n  }\\n}\\n\")), React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-csharp\"\n  }, \"public override object PartTwo()\\n{\\n    var comparer = new CamelHandComparer(true);\\n    List<(string hand, int bid, HandType handType)> hands = [.. Input.Select(x => x.Split(' ', StringSplitOptions.RemoveEmptyEntries))\\n                                                                     .Select(x => (hand: x[0], bid: int.Parse(x[1]), handType: FindHandType(x[0], true)))\\n                                                                     .Order(comparer)];\\n    long sum = 0;\\n    for (int i = 0; i < hands.Count; i++)\\n        sum += (i + 1) * hands[i].bid;\\n\\n    return sum;\\n}\\n\\npublic static HandType FindHandTypeJoker(int keyCount, int maxCount, int jokers) => keyCount switch\\n{\\n    < 3 => HandType.FiveOfAKind,\\n    3 => jokers == 1 && maxCount < 3 ? HandType.FullHouse : HandType.FourOfAKind,\\n    4 => jokers == 2 || maxCount == 2 ? HandType.ThreeOfAKind : HandType.OnePair,\\n    _ => HandType.OnePair\\n};\\n\"))));\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? React.createElement(MDXLayout, props, React.createElement(_createMdxContent, props)) : _createMdxContent(props);\n}\nexport default MDXContent;\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","import GATSBY_COMPILED_MDX from \"/home/joel/personal/advent-of-code/joel-allan-nz.github.io/days/2023/7.mdx\";\nimport React from 'react';\nimport {MDXProvider} from '@mdx-js/react';\nimport CodeBox from './CodeBox';\nimport TryYourself from './TryYourself';\nimport AdventSideNav from './AdventSideNav';\nimport Header from './Header';\nimport Footer from './Footer';\nconst shortcodes = {\n  CodeBox\n};\nfunction Layout(_ref) {\n  let {pageContext, children} = _ref;\n  return React.createElement(React.Fragment, null, React.createElement(Header, null), React.createElement(\"div\", {\n    className: \"min-h-screen bg-chicPrimary\"\n  }, React.createElement(AdventSideNav, {\n    props: pageContext.list\n  }), React.createElement(\"div\", {\n    className: \"adventofcode max-w-[60%] ml-[20%]\"\n  }, React.createElement(\"h1\", null, React.createElement(\"a\", {\n    href: \"https://adventofcode.com/\" + pageContext.year + \"/day/\" + pageContext.puzz\n  }, pageContext.year + \" Day \" + pageContext.puzz + \" - \" + pageContext.title)), React.createElement(MDXProvider, {\n    components: shortcodes\n  }, children), pageContext.puzz && pageContext.year ? React.createElement(TryYourself, {\n    year: pageContext.year,\n    puzz: pageContext.puzz\n  }) : React.createElement(React.Fragment, null))), React.createElement(Footer, null));\n}\nexport default function GatsbyMDXWrapper(props) {\n  return React.createElement(Layout, props, React.createElement(GATSBY_COMPILED_MDX, props));\n}\nexport const Head = () => React.createElement(React.Fragment, null, React.createElement(\"title\", null, \"Joel-Allan-NZ - Advent of Code\"), React.createElement(\"html\", {\n  lang: \"en\"\n}), React.createElement(\"link\", {\n  rel: \"preconnect\",\n  href: \"https://fonts.googleapis.com\"\n}), React.createElement(\"link\", {\n  rel: \"preconnect\",\n  href: \"https://fonts.gstatic.com\"\n}), React.createElement(\"link\", {\n  href: \"https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&family=VT323&display=swap\",\n  rel: \"stylesheet\"\n}));\n"],"names":["_createMdxContent","props","_components","Object","assign","h2","p","pre","code","_provideComponents","components","CodeBox","id","component","Error","_missingMdxReference","React","names","className","wrapper","MDXLayout","shortcodes","Layout","_ref","pageContext","children","Header","AdventSideNav","list","href","year","puzz","title","MDXProvider","TryYourself","Footer","GatsbyMDXWrapper","GATSBY_COMPILED_MDX","Head","lang","rel"],"sourceRoot":""}