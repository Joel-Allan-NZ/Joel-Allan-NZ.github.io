{"version":3,"file":"component---src-components-layout-tsx-content-file-path-days-2023-19-mdx-be5614a3fa36bd9b498b.js","mappings":"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","sources":["webpack://joel-allan-nz.github.io/./days/2023/19.mdx","webpack://joel-allan-nz.github.io/./src/components/Layout.tsx"],"sourcesContent":["/*@jsxRuntime classic @jsx React.createElement @jsxFrag React.Fragment*/\nimport {useMDXComponents as _provideComponents} from \"@mdx-js/react\";\nimport React from \"react\";\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    p: \"p\",\n    pre: \"pre\",\n    code: \"code\"\n  }, _provideComponents(), props.components), {CodeBox} = _components;\n  if (!CodeBox) _missingMdxReference(\"CodeBox\", true);\n  return React.createElement(React.Fragment, null, React.createElement(_components.h2, null, \"Part One\"), \"\\n\", React.createElement(_components.p, null, \"Pick your poison on how to parse the workflows and check their conditions. No real trick or classic algorithm here, just modelling a system.\"), \"\\n\", React.createElement(CodeBox, {\n    names: \"typescript|C#\"\n  }, React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-ts\"\n  }, \"export function partOne(input: string[]): number | string {\\n  const { flows, parts } = parse(input)\\n  const accepted: number[][] = []\\n\\n  parts.forEach((part) => {\\n    let result = 'in'\\n    while (true) {\\n      result = flows.get(result)!.find((x) => x.application(part))!.next\\n      if (result == 'R') break\\n      if (result == 'A') {\\n        accepted.push(part)\\n        break\\n      }\\n    }\\n  })\\n  return accepted.reduce(\\n    (total, part) => total + part[0] + part[1] + part[2] + part[3],\\n    0\\n  )\\n}\\n\\nclass Rule {\\n  next: string\\n  equality: string\\n  target: number\\n  xmas: number\\n  application: (part: number[]) => boolean\\n\\n  constructor(rule: string) {\\n    const split = rule.split(':')\\n    this.next = split.length > 1 ? split[1] : split[0]\\n    this.xmas = this.xmasToNumber(rule[0])\\n    this.target = split.length == 1 ? -1 : parseInt(split[0].slice(2))\\n    this.equality = rule.length > 1 ? rule[1] : rule[0]\\n\\n    if (this.target == -1) this.application = (r) => true\\n    else\\n      this.application =\\n        this.equality == '<'\\n          ? (r) => r[this.xmas] < this.target\\n          : (r) => r[this.xmas] > this.target\\n  }\\n\\n  xmasToNumber(xmas: string) {\\n    switch (xmas) {\\n      case 'x':\\n        return 0\\n      case 'm':\\n        return 1\\n      case 'a':\\n        return 2\\n      default:\\n        return 3\\n    }\\n  }\\n}\\n\\nfunction parse(input: string[]): {\\n  flows: Map<string, Rule[]>\\n  parts: number[][]\\n} {\\n  const flows = new Map<string, Rule[]>()\\n  const parts: number[][] = []\\n  let readingWorkFlows = true\\n\\n  input.forEach((line) => {\\n    if (!line || line.length == 0) {\\n      readingWorkFlows = false\\n    } else {\\n      const split = line.slice(0, -1).split(/[\\\\{\\\\,]/g)\\n      if (readingWorkFlows)\\n        flows.set(\\n          split[0],\\n          split.slice(1).map((x) => new Rule(x))\\n        )\\n      else parts.push(split.slice(1, 5).map((i) => parseInt(i.slice(2))))\\n    }\\n  })\\n  return { flows, parts }\\n}\\n\")), React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-csharp\"\n  }, \"public override object PartOne()\\n{\\n    var (flows, parts) = Parse(Input);\\n    List<Part> accepted = [];\\n    foreach (var part in parts)\\n    {\\n        var result = \\\"in\\\";\\n        while (true)\\n        {\\n            result = flows[result].First(x => x.Application(part))!.Next;\\n            if (result == \\\"R\\\")\\n                break;\\n            if (result == \\\"A\\\")\\n            {\\n                accepted.Add(part);\\n                break;\\n            }\\n        }\\n    }\\n    return accepted.Sum(acc => acc.X + acc.M + acc.A + acc.S);\\n}\\n\\nprivate static (Dictionary<string, Rule[]> flows, List<Part> parts) Parse(string[] input)\\n{\\n    Dictionary<string, Rule[]> flows = [];\\n    List<Part> parts = [];\\n\\n    bool readingWorkFlows = true;\\n    foreach (var line in input)\\n    {\\n        if (string.IsNullOrEmpty(line))\\n        {\\n            readingWorkFlows = false;\\n            continue;\\n        }\\n        var split = line.Split(['{', '}', ','], StringSplitOptions.RemoveEmptyEntries);\\n\\n        if (readingWorkFlows)\\n            flows.Add(split[0], split[1..].Select(x => new Rule(x)).ToArray());\\n        else\\n            parts.Add(new(int.Parse(split[0][2..]), int.Parse(split[1][2..]), int.Parse(split[2][2..]), int.Parse(split[3][2..])));\\n    }\\n    return (flows, parts);\\n}\\n\\ninternal class Rule\\n{\\n    internal char Equality;\\n    internal Func<Part, bool> Application;\\n    internal string Next;\\n    internal int Target;\\n    internal char XMAS;\\n\\n    public Rule(string rule)\\n    {\\n        var split = rule.Split(':');\\n        Next = split.Length > 1 ? split[1] : split[0];\\n        XMAS = rule[0];\\n        Target = split.Length == 1 ? -1 : int.Parse(split[0][2..]);\\n        Equality = rule.Length > 1 ? rule[1] : rule[0];\\n        Application = ParseRule();\\n    }\\n\\n\\n    internal Func<Part, bool> ParseRule()\\n    {\\n        if (Target == -1)\\n            return (r => true);\\n        else if (Equality == '<')\\n            return (r => r.GetXMASValue(XMAS) < Target);\\n        else\\n            return (r => r.GetXMASValue(XMAS) > Target);\\n    }\\n}\\n\\ninternal class Part(int x, int m, int a, int s)\\n{\\n    internal int X = x;\\n    internal int M = m;\\n    internal int A = a;\\n    internal int S = s;\\n\\n    internal int GetXMASValue(char s) => s switch\\n    {\\n        'x' => X,\\n        'm' => M,\\n        'a' => A,\\n        _ => S\\n    };\\n}\\n\"))), \"\\n\", React.createElement(_components.h2, null, \"Part Two\"), \"\\n\", React.createElement(_components.p, null, \"Instead of modelling the system for the parts list, you now have to find all valid parts. Rather than trying to enumerate the possible part values (4000^4 is big!), I opted to treat it as ranges of valid values. When a range encounters a rule that wouldn't pass for the entire range, the range is split into 2 ranges. Again, nothing complex, just execution.\"), \"\\n\", React.createElement(CodeBox, {\n    names: \"typescript|C#\"\n  }, React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-ts\"\n  }, \"export function partTwo(input: string[]): number | string {\\n  const { flows, parts } = parse(input)\\n  const queue: { ranges: number[][][]; rules: Rule[] }[] = [\\n    {\\n      ranges: [\\n        [\\n          [1, 4000],\\n          [1, 4000],\\n          [1, 4000],\\n          [1, 4000],\\n        ],\\n      ],\\n      rules: flows.get('in')!,\\n    },\\n  ]\\n  let valid: number[][][] = []\\n\\n  while (queue.length > 0) {\\n    const { ranges, rules } = queue.shift()!\\n    const result = applyRulesToRange(rules, ranges)\\n    result.entries().forEach((kvp) => {\\n      if (kvp[0] != 'R') {\\n        if (kvp[0] == 'A') valid = [...valid, ...kvp[1]]\\n        else queue.push({ ranges: kvp[1], rules: flows.get(kvp[0])! })\\n      }\\n    })\\n  }\\n\\n  return valid.reduce(\\n    (total, range) => total + range.reduce((t, r) => t * (r[1] - r[0] + 1), 1),\\n    0\\n  )\\n}\\n\\nfunction split(\\n  current: number[][],\\n  xmas: number,\\n  min: number,\\n  max: number\\n): number[][] {\\n  const other: number[][] = [\\n    [...current[0]],\\n    [...current[1]],\\n    [...current[2]],\\n    [...current[3]],\\n  ]\\n  other[xmas][1] = Math.min(max, current[xmas][1])\\n  other[xmas][0] = Math.max(min, current[xmas][0])\\n\\n  if (other[xmas][0] > current[xmas][0] && other[xmas][0] < current[xmas][1])\\n    current[xmas][1] = other[xmas][0] - 1\\n  else if (\\n    current[xmas][1] > other[xmas][1] &&\\n    other[xmas][1] > current[xmas][0]\\n  )\\n    current[xmas][0] = other[xmas][1] + 1\\n  else {\\n    current[xmas][0] = -1\\n    current[xmas][1] = -1\\n  }\\n  return other\\n}\\n\\nfunction applyRulesToRange(\\n  rules: Rule[],\\n  parts: number[][][]\\n): Map<string, number[][][]> {\\n  const continuing = new Map<string, number[][][]>()\\n\\n  for (let part of parts) {\\n    for (let rule of rules) {\\n      if (!continuing.has(rule.next)) continuing.set(rule.next, [])\\n      if (rule.target == -1) {\\n        continuing.get(rule.next)!.push(part)\\n        break\\n      }\\n      let range = part[rule.xmas]\\n\\n      if (range[0] <= rule.target && range[1] >= rule.target) {\\n        if (rule.equality == '>')\\n          continuing\\n            .get(rule.next)!\\n            .push(split(part, rule.xmas, rule.target + 1, Infinity))\\n        else\\n          continuing\\n            .get(rule.next)!\\n            .push(split(part, rule.xmas, -1, rule.target - 1))\\n      }\\n    }\\n  }\\n\\n  return continuing\\n}\\n\")), React.createElement(_components.pre, null, React.createElement(_components.code, {\n    className: \"language-csharp\"\n  }, \"public override object PartTwo()\\n{\\n    var (flows, parts) = Parse(Input);\\n    Queue<(List<PartRange> ranges, Rule[] flow)> toProcess = [];\\n    PartRange maxRange = new([1, 4000], [1, 4000], [1, 4000], [1, 4000]);\\n    toProcess.Enqueue(([maxRange], flows[\\\"in\\\"]));\\n    List<PartRange> valid = [];\\n\\n    while (toProcess.Count > 0)\\n    {\\n        var (ranges, flow) = toProcess.Dequeue();\\n        var result = ApplyWorkFlowRange(flow, ranges);\\n        foreach (var kvp in result)\\n        {\\n            if (kvp.Key == \\\"R\\\")\\n                continue;\\n            if (kvp.Key == \\\"A\\\")\\n            {\\n                valid.AddRange(kvp.Value);\\n                continue;\\n            }\\n            toProcess.Enqueue((kvp.Value, flows[kvp.Key]));\\n        }\\n    }\\n\\n    return valid.Sum(v => (long)(v.X[1] - v.X[0] + 1) * (v.A[1] - v.A[0] + 1) * (v.M[1] - v.M[0] + 1) * (v.S[1] - v.S[0] + 1));\\n\\n}\\n\\ninternal class PartRange(int[] x, int[] m, int[] a, int[] s)\\n{\\n    internal int[] X = x;\\n    internal int[] M = m;\\n    internal int[] A = a;\\n    internal int[] S = s;\\n\\n    internal int[] GetXMAS(char xmas) => xmas switch\\n    {\\n        'x' => X,\\n        'm' => M,\\n        'a' => A,\\n        _ => S,\\n    };\\n\\n    internal PartRange Split(char xmas, int min, int max)\\n    {\\n        var range = GetXMAS(xmas);\\n        PartRange other = new([X[0], X[1]], [M[0], M[1]], [A[0], A[1]], [S[0], S[1]]);\\n        var otherRange = other.GetXMAS(xmas);\\n\\n        otherRange[1] = Math.Min(max, range[1]);\\n        otherRange[0] = Math.Max(min, range[0]);\\n\\n        if (otherRange[0] > range[0] && otherRange[0] < range[1])\\n            range[1] = otherRange[0] - 1;\\n        else if (range[1] > otherRange[1] && otherRange[1] > range[0])\\n            range[0] = otherRange[1] + 1;\\n        else\\n        {\\n            range[0] = -1;\\n            range[1] = -1;\\n        }\\n        return other;\\n    }\\n}\\n\\nprivate static Dictionary<string, List<PartRange>> ApplyWorkFlowRange(Rule[] rules, List<PartRange> parts)\\n{\\n    Dictionary<string, List<PartRange>> continuing = [];\\n\\n    foreach (var part in parts)\\n    {\\n        foreach (var rule in rules)\\n        {\\n            if (!continuing.ContainsKey(rule.Next))\\n                continuing[rule.Next] = [];\\n            if (rule.Target == -1)\\n            {\\n                continuing[rule.Next].Add(part);\\n                break;\\n            }\\n            var range = part.GetXMAS(rule.XMAS);\\n\\n            if (range[0] <= rule.Target && range[1] >= rule.Target)\\n            {\\n                if (rule.Equality == '>')\\n                    continuing[rule.Next].Add(part.Split(rule.XMAS, rule.Target + 1, int.MaxValue));\\n                else\\n                    continuing[rule.Next].Add(part.Split(rule.XMAS, -1, rule.Target - 1));\\n            }\\n        }\\n    }\\n    return continuing;\\n}\\n\"))));\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? React.createElement(MDXLayout, props, React.createElement(_createMdxContent, props)) : _createMdxContent(props);\n}\nexport default MDXContent;\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","import GATSBY_COMPILED_MDX from \"/home/joel/personal/advent-of-code/joel-allan-nz.github.io/days/2023/19.mdx\";\nimport React from 'react';\nimport {MDXProvider} from '@mdx-js/react';\nimport CodeBox from './CodeBox';\nimport TryYourself from './TryYourself';\nimport AdventSideNav from './AdventSideNav';\nimport Header from './Header';\nimport Footer from './Footer';\nconst shortcodes = {\n  CodeBox\n};\nfunction Layout(_ref) {\n  let {pageContext, children} = _ref;\n  return React.createElement(React.Fragment, null, React.createElement(Header, null), React.createElement(\"div\", {\n    className: \"min-h-screen bg-chicPrimary\"\n  }, React.createElement(AdventSideNav, {\n    props: pageContext.list\n  }), React.createElement(\"div\", {\n    className: \"adventofcode max-w-[60%] ml-[20%]\"\n  }, React.createElement(\"h1\", null, React.createElement(\"a\", {\n    href: \"https://adventofcode.com/\" + pageContext.year + \"/day/\" + pageContext.puzz\n  }, pageContext.year + \" Day \" + pageContext.puzz + \" - \" + pageContext.title)), React.createElement(MDXProvider, {\n    components: shortcodes\n  }, children), pageContext.puzz && pageContext.year ? React.createElement(TryYourself, {\n    year: pageContext.year,\n    puzz: pageContext.puzz\n  }) : React.createElement(React.Fragment, null))), React.createElement(Footer, null));\n}\nexport default function GatsbyMDXWrapper(props) {\n  return React.createElement(Layout, props, React.createElement(GATSBY_COMPILED_MDX, props));\n}\nexport const Head = () => React.createElement(React.Fragment, null, React.createElement(\"title\", null, \"Joel-Allan-NZ - Advent of Code\"), React.createElement(\"html\", {\n  lang: \"en\"\n}), React.createElement(\"link\", {\n  rel: \"preconnect\",\n  href: \"https://fonts.googleapis.com\"\n}), React.createElement(\"link\", {\n  rel: \"preconnect\",\n  href: \"https://fonts.gstatic.com\"\n}), React.createElement(\"link\", {\n  href: \"https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&family=VT323&display=swap\",\n  rel: \"stylesheet\"\n}));\n"],"names":["_createMdxContent","props","_components","Object","assign","h2","p","pre","code","_provideComponents","components","CodeBox","id","component","Error","_missingMdxReference","React","names","className","wrapper","MDXLayout","shortcodes","Layout","_ref","pageContext","children","Header","AdventSideNav","list","href","year","puzz","title","MDXProvider","TryYourself","Footer","GatsbyMDXWrapper","GATSBY_COMPILED_MDX","Head","lang","rel"],"sourceRoot":""}